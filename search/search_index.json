{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Python Toggl API Wrapper","text":"<p>Simple Toggl API wrapper for non-premium features primarily focused on creating a cached framework for developing custom commands.</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>Install with pip:</p> <pre><code>pip install toggl-api-wrapper\n</code></pre> <p>Or if using SQLite cache:</p> <pre><code>pip install \"toggl-api-wrapper[sqlite]\"\n</code></pre> <p>Or if using async classes:</p> <pre><code>pip install \"toggl-api-wrapper[async]\"\n</code></pre>"},{"location":"index.html#usage","title":"Usage","text":"<ul> <li>Currently supports interacting with Trackers, Projects, Clients, Tags, Reports and some extras.</li> <li>Designed to be rudimentary to allow simple development of custom commands.</li> </ul>"},{"location":"index.html#examples","title":"Examples","text":"Tracker Endpoint <pre><code>from datetime import timedelta\nfrom pathlib import Path\n\nfrom toggl_api.config import generate_authentication\nfrom toggl_api import TrackerBody, TrackerEndpoint, JSONCache\n\n\nWORKSPACE_ID = 2313123123\nAUTH = generate_authentication()\ncache = JSONCache(Path(\"cache\"), timedelta(hours=24))\nendpoint = TrackerEndpoint(WORKSPACE_ID, AUTH, cache)\n\nbody = TrackerBody(\"My First Tracker\", tags=[\"My First Tag\"])\ntracker = endpoint.add(body)\nprint(tracker)\n</code></pre> Outputs: <pre><code>&gt;&gt;&gt; TogglTracker(\n        id=3482231563,\n        name=\"My First Tracker\",\n        workspace=2313123123,\n        start=datetime.datetime(2024, 6, 10, 14, 59, 20, tzinfo=datetime.timezone.utc),\n        duration=datetime.timedelta(seconds=1, microseconds=179158),\n        stop=None,\n        project=None,\n        tags=[],\n    )\n</code></pre> Project Endpoint <pre><code>from datetime import timedelta\nfrom pathlib import Path\n\nfrom toggl_api import ProjectBody, ProjectEndpoint, TogglProject\nfrom toggl_api.config import retrieve_togglrc_workspace_id, use_togglrc\nfrom toggl_api.meta.cache import JSONCache\n\nWORKSPACE_ID = retrieve_togglrc_workspace_id()\nAUTH = use_togglrc()\ncache = JSONCache[TogglProject](Path(\"cache\"), timedelta(hours=24))\nendpoint = ProjectEndpoint(WORKSPACE_ID, AUTH, cache)\n\ncolor = ProjectEndpoint.get_color(\"red\")\nbody = ProjectBody(\n    \"My First Project\",\n    client_name=\"My First Client\",\n    color=color,\n)\nproject = endpoint.add(body)\nprint(project)\n</code></pre> Outputs: <pre><code>&gt;&gt;&gt; TogglProject(\n        id=203366783,\n        name='My First Project',\n        workspace=2313123123,\n        color='#d92b2b',\n        client=65298912,\n        active=True,\n    )\n</code></pre>"},{"location":"index.html#documentation","title":"Documentation","text":"<ul> <li>Examples</li> <li>API Documentation</li> <li>User Guide</li> <li>Changelog</li> </ul>"},{"location":"index.html#contributing","title":"Contributing","text":"<p>See CONTRIBUTING.</p>"},{"location":"index.html#license","title":"License","text":"<p>MIT. Check LICENSE for more information.</p>"},{"location":"CHANGELOG.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"CHANGELOG.html#220-2025-05-10","title":"[2.2.0] - 2025-05-10","text":""},{"location":"CHANGELOG.html#features","title":"\ud83d\ude80 Features","text":"<ul> <li>(utility) Implement fake data generator</li> </ul>"},{"location":"CHANGELOG.html#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(clean-account) Check if file exists before removing</li> </ul>"},{"location":"CHANGELOG.html#refactor","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(models) Remove <code>str</code> type from <code>TogglTracker.stop</code></li> <li>(models) Remove automatic generation of <code>TogglTracker.duration</code></li> <li>(scripts) Move clean_account script to utility module</li> <li>(utility) Move helpers into utility module</li> <li>(utility) Convert <code>clean_account</code> to private module</li> <li>(generate-fake-data) Add additional checks for cache type</li> <li>(clean-account) Move <code>ArgumentParser</code> into separate function</li> </ul>"},{"location":"CHANGELOG.html#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>(utility) Add documentation for utility scripts</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(actions) Allow Windows in 3.10 configs</li> <li>(scripts) Add scripts into configuration</li> <li>(coverage) Omit utility scripts</li> </ul>"},{"location":"CHANGELOG.html#testing","title":"\ud83e\uddea Testing","text":"<ul> <li>(detail-report) Ignore partial coverage</li> </ul>"},{"location":"CHANGELOG.html#210-2025-04-15","title":"[2.1.0] - 2025-04-15","text":""},{"location":"CHANGELOG.html#features_1","title":"\ud83d\ude80 Features","text":"<ul> <li>(models) Add <code>TogglTracker.description</code> property</li> <li>(models) Add <code>TogglTracker.running_duration</code> property</li> </ul>"},{"location":"CHANGELOG.html#bug-fixes_1","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(async-sqlite-cache) Add <code>metadata</code> attribute type to class</li> </ul>"},{"location":"CHANGELOG.html#refactor_1","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(async-sqlite-cache) Remove unnecessary E402 noqa code</li> <li>(utils) Add return type to <code>cleanup</code> functionx</li> </ul>"},{"location":"CHANGELOG.html#documentation_1","title":"\ud83d\udcda Documentation","text":"<ul> <li>(schema) Add docstring to <code>register_tables</code> function</li> <li>(cache) Add <code>register_tabels</code> function</li> <li>(models) Update <code>as_dict_custom</code> helper function</li> <li>(models) Add <code>as_dict_custom</code> function</li> <li>(utils) Add docstring to module and <code>cleanup</code> function</li> </ul>"},{"location":"CHANGELOG.html#performance","title":"\u26a1 Performance","text":"<ul> <li>(schema) Index all high variance columns</li> </ul>"},{"location":"CHANGELOG.html#styling","title":"\ud83c\udfa8 Styling","text":"<ul> <li>(schema) Remove unncessary E402 code</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_1","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(tox) Add <code>--cov</code> parameter to tests</li> <li>(actions) Run all tests on both os 3.10 configs</li> <li>(tox) Only check coverage on 3.10 tests</li> <li>(coverage) Remove <code>requires</code> option</li> </ul>"},{"location":"CHANGELOG.html#testing_1","title":"\ud83e\uddea Testing","text":"<ul> <li>(cache) Add small delay on windows</li> </ul>"},{"location":"CHANGELOG.html#200-2025-04-08","title":"[2.0.0] - 2025-04-08","text":""},{"location":"CHANGELOG.html#features_2","title":"\ud83d\ude80 Features","text":"<ul> <li>(cached-endpoint) Allow for no cache to be assigned</li> <li>(reports) Abstract report methods</li> <li>(config) Add workspace missing error exception</li> <li>(sqlite_cache) Allow for an external engine param</li> <li>(cache) Allow for pathlike &amp; strings objects to be passed in</li> <li>(reports) Custom invalid extension error</li> <li>(sqlite_cache) Allow for an external engine param</li> <li>(cache) Allow for pathlike &amp; strings objects to be passed in</li> <li>(reports) Custom invalid extension error</li> <li>(async) Implement abstract endpoints</li> <li>(async) Implement abstract cache</li> <li>(async) Implement sqlite cache</li> <li>(async-tracker) Implement async tracker endpoint</li> <li>(async-project) Implement async project endpoint</li> <li>(async-client) Implement async client endpoint</li> <li>(async-org) Implement async org endpoint</li> <li>(async-tag) Implement async tag endpoint</li> <li>(async-workspace) Implement async workspace endpoint</li> <li>(async-user) Implement async user endpoint</li> <li>(async-reports) Implement async report endpoints</li> <li>(endpoints) Implement custom client parameter</li> </ul>"},{"location":"CHANGELOG.html#bug-fixes_2","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(scripts) Include scripts directory in pyproject</li> <li>(tracker) Body not converting timedeltas correctly</li> <li>(endpoints) Remove wrong types</li> <li>Small endpoint &amp; cache changes</li> <li>(scripts) Remove cache from utility script</li> <li>Implement basic import fixes</li> <li>(typing) Deal with extra mypy warnings</li> <li>(typing) Add generic and extra typing checks</li> <li>(typing) Add callable typing</li> <li>(typing) Remove all implicity re-exports</li> <li>(async-sqlite-cache) Make sure entry exists before deleting</li> <li>(models) Revert <code>TogglClass.from_kwargs</code> changes</li> </ul>"},{"location":"CHANGELOG.html#refactor_2","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(cache) [breaking] Simplify abstract cache methods</li> <li>(endpoints) Use new caching methods</li> <li>(body) [breaking] Replace ValueError with KeyError</li> <li>(body) [breaking] Convert BaseBody class into mapping</li> <li>(body) [breaking] Make verify_endpoint_parameter method private</li> <li>(user) [breaking] Remove deprecated check_authentication method</li> <li>(base_endpoint) [breaking] Remove 'workspace_id' parameter</li> <li>(base_endpoint) [breaking] Remove 'model' property</li> <li>(base_endpoint) [breaking] Remove 'endpoint' property</li> <li>(base_endpoint) [breaking] Remove 'method' helper method</li> <li>(tracker_endpoint) [breaking] Remove typeerror from add method</li> <li>(tracker) [breaking] Move 'current' method to tracker endpoint</li> <li>(tracker) [breaking] Move 'collect' method to tracker endpoint</li> <li>(user) User actual object for 'get_details' method</li> <li>(tracker) [breaking] Move 'get' method to tracker endpoint</li> <li>(user) [breaking] Remove tracker related info and attributes</li> <li>(endpoints) Use endpoint property within method</li> <li>(workspaces) [breaking] Remove deprecated workspace id param</li> <li>(reports) [breaking] Remove deprecated methods</li> <li>(trackers) [breaking] Remove start_date parameter from body</li> <li>(tags) [breaking] Remove deprecated optional type from 'edit' endpoint method</li> <li>(config) [breaking] Remove deprecated authentication error</li> <li>(config) [breaking] Togglrc helper function using workspace missing error</li> <li>(base_cache) [breaking] Remove deprecated value error from missing parent error exception</li> <li>(reports) Use invalid extension error for extension exceptions</li> <li>(reports) Use invalid extension error for extension exceptions</li> <li>(reports) [breaking] Move reports module into main folder</li> <li>[breaking] Make most modules private</li> <li>[breaking] Adjust imports to new directory structure</li> <li>(scripts) Remove cache requirement from cleanup utility</li> <li>(cache) Update schema generation</li> <li>(async) Update init file</li> <li>(workspace) [breaking] Make workspace module private</li> <li>(async) All async endpoints accept client</li> <li>(exceptions) Move exceptions into seperate module</li> <li>(project) [breaking] Convert 'active' param default to a boolean</li> <li>Use a src folder for the library</li> <li>(typing) Cast any returns to correct type</li> <li>Update all modules to new ruff rules</li> <li>(endpoint) Cast model to generic class</li> <li>(metadata) Convert _version.py to about.py</li> </ul>"},{"location":"CHANGELOG.html#documentation_2","title":"\ud83d\udcda Documentation","text":"<ul> <li>(user, tracker) Split up tracker &amp; user endpoint pages</li> <li>(user, tracker) Split up tracker &amp; user endpoint pages</li> <li>(scripts) Utility for generating project diagrams</li> <li>Update to project structure</li> <li>Small fixes &amp; config improvements</li> <li>(async) Add references for classes</li> <li>(examples) Add async example</li> <li>(examples) Fix outdated imports</li> <li>(contributing) Update contrib docs</li> <li>(api) Update diagrams</li> <li>(mkdocs) Update configurate for src layout</li> <li>(api-guide) Fix bad relative links</li> <li>(scripts) Update diagram script to new src layout</li> <li>(api-guide) Update diagrams</li> <li>(contributing) Update contributing guideline to uv</li> <li>(installation) Include aiosqlite in optional dependencies</li> <li>(mkdocs) Add inventories to mkdocstrings</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_2","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(dev-deps) Add pytest asyncio</li> <li>(pytest) Set asyncio mode</li> <li>(dev-deps) Added ruff formatter</li> <li>(dev-deps) Update mkdocstrings-python dependency</li> <li>(coverage) Keep coverage for tests</li> <li>(tox) Make sure to install all extras</li> <li>(actions) Do not run slow tests on most matrix combos</li> <li>(pre-commit) Update ruff &amp; mypy pre-commit</li> <li>(pre-commit) Update pre-commit configuration</li> <li>(git) Update .gitignore file</li> <li>(pre-commit) Add uv to configuration</li> <li>(ruff) Refactor configuration</li> <li>(ruff) Refactor ruff configuration</li> <li>(mypy) Remove unnecessary errors codes from tests</li> <li>(pre-commit) Make sure to fix in ruff pre-commit</li> <li>(ruff) Ignore ARG code in tests</li> <li>(tox) Update tox config to toml format</li> <li>(actions) Update actions to use uv</li> <li>(git-cliff) Handle ref type as a refactor</li> <li>(git-cliff) Add build section to commit parser</li> <li>(pyproject) Add keywords section to pyproject.toml</li> </ul>"},{"location":"CHANGELOG.html#build","title":"\ud83c\udfd7  Build","text":"<ul> <li>(project) Convert project management to uv</li> <li>(lint,type-check) Change target python version</li> <li>(pre-commit) Add SQLAlchemy stubs to pre-commit</li> </ul>"},{"location":"CHANGELOG.html#testing_2","title":"\ud83e\uddea Testing","text":"<ul> <li>Replace removed methods with alternatives</li> <li>(async) Base fixtures setup</li> <li>Tracker factory fixture</li> <li>(async-sqlite) All cache functionality</li> <li>Implement generator function fixtures</li> <li>Fix minor issues</li> <li>(tags) Tag get method</li> <li>(org) Mark organization tests slow</li> <li>(async) Set default fixture loop scope</li> <li>100% test suite usage</li> <li>(coverage) Add source folders</li> <li>Adjust tests to new linting rules</li> <li>(async-trackers) Use utc timezone with <code>datetime.now</code></li> </ul>"},{"location":"CHANGELOG.html#160-2024-12-19","title":"[1.6.0] - 2024-12-19","text":""},{"location":"CHANGELOG.html#features_3","title":"\ud83d\ude80 Features","text":"<ul> <li>(endpoints) Build request private helper method</li> <li>(cache) Model helper property</li> </ul>"},{"location":"CHANGELOG.html#refactor_3","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(endpoints) Remove unnecessary ruff ignore flag</li> <li>(endpoints) Convert process_models into clasmethod</li> <li>(endpoints) Make client attribute public</li> <li>(endpoints) Request handle error helper private method</li> <li>(endpoints) Process_response private helper method</li> <li>(endpoints) Improve request method readability</li> <li>(json-cache) Uses new model property</li> <li>(sqlite-cache) Uses new model property</li> <li>(reports) Adjust report endpoint to base</li> <li>(endpoints) Use MODEL classvar instead of property</li> <li>(cached_endpoint) Adjust subclass to new structure</li> <li>(cached_endpoint) Log info about cache expiration</li> <li>Remove all optional types</li> </ul>"},{"location":"CHANGELOG.html#deprecations","title":"\ud83d\udd78 Deprecations","text":"<ul> <li>(endpoints) Deprecate 'method' helper method in favour of build_request</li> <li>(endpoints) Deprecate model property in favour of class variable</li> <li>(endpoints) Deprecate 'endpoint' property in favour of 'BASE_ENDPOINT' ClassVar</li> </ul>"},{"location":"CHANGELOG.html#documentation_3","title":"\ud83d\udcda Documentation","text":"<ul> <li>(json_cache) Encoder &amp; decoder docstrings</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_3","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(ruff) Ignore tc006 code</li> <li>(cliff) Ignore merge commits</li> <li>(cliff) Merge cliff.toml with pyproject</li> </ul>"},{"location":"CHANGELOG.html#151-2024-11-26","title":"[1.5.1] - 2024-11-26","text":""},{"location":"CHANGELOG.html#bug-fixes_3","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(models) From_kwargs not incorporating organization id</li> </ul>"},{"location":"CHANGELOG.html#documentation_4","title":"\ud83d\udcda Documentation","text":"<ul> <li>(endpoints) Correct and improve docstrings</li> <li>(cache, config) Remove unnecessary type on return value in docstrings</li> </ul>"},{"location":"CHANGELOG.html#150-2024-11-25","title":"[1.5.0] - 2024-11-25","text":""},{"location":"CHANGELOG.html#features_4","title":"\ud83d\ude80 Features","text":"<ul> <li>(workspace) Organization id accepts a model</li> <li>(utility) Deprecation helper method</li> <li>(tags) Single get endpoint convenience method</li> <li>(models) Add start and end date to project model</li> <li>(utility) Get_timestamp helper function</li> <li>(models) Project status enum</li> <li>(models) Project get_status method</li> <li>(projects) Status to query helper method</li> <li>(endpoints) Implement re_raise parameter</li> <li>(endpoints) Implement retries parameter</li> <li>(trackers) Bulk edit item typed dict</li> <li>(trackers) Edit named tuple data structure</li> <li>(trackers) Bulk edit patch endpoint method</li> </ul>"},{"location":"CHANGELOG.html#bug-fixes_4","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(projects) Default color for using old gray hex code</li> <li>(models) Missing pound sign on project default color</li> <li>(projects) Edit &amp; add method return type had none</li> </ul>"},{"location":"CHANGELOG.html#refactor_4","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(workspace) Deprecate workspace_id argument correctly</li> <li>(user) Add workspace_id param to endpoint + model type</li> <li>(tracker) Add workspace_id param to endpoint + model type</li> <li>(projects) Add workspace_id param to endpoint + model type</li> <li>(clients) Add workspace_id param to endpoint + model type</li> <li>(tags) Add workspace_id param to endpoint + model type</li> <li>(user) Current endpoint will try refresh if no tracker is running</li> <li>(clients) Properly implement collect endpoint cache queries</li> <li>(cache) Json serializer formating date objects</li> <li>(user) Collect method uses get_timestamp helper</li> <li>(workspace) Collect method uses get_timestamp helper</li> <li>(projects) Add collect endpoint method body attributes</li> <li>(projects) Collect method endpoint format method helper</li> <li>(projects) Implement new body attributes into format method</li> <li>(projects) Update project collect method to include querying cache</li> <li>(models) Prevent unnecessary datetime call</li> <li>(endpoints) Change default timeout parameter</li> <li>(utility) [breaking] Turn requires into a private function</li> <li>(tracker) Improve edit endpoint method</li> <li>(endpoints) Request method accepts lists as a body</li> <li>(trackers) Update body parameters</li> </ul>"},{"location":"CHANGELOG.html#deprecations_1","title":"\ud83d\udd78 Deprecations","text":"<ul> <li>(meta) Base endpoint workspace_id argument removal</li> <li>(projects) Get color argument name</li> <li>(trackers) Body start_date parameter</li> </ul>"},{"location":"CHANGELOG.html#documentation_5","title":"\ud83d\udcda Documentation","text":"<ul> <li>(user) Update current endpoint docstring</li> <li>(tags) Update get method docstring</li> <li>(models) Helper method docstrngs</li> <li>(projects) Update basic color docstrings</li> <li>(projects) Add and update all endpoint + body docstrings</li> <li>(cache) Remove docstring newlines</li> <li>(endpoints) Improve all endpoint parameter documentation</li> <li>(trackers) Add new functionality</li> <li>(mermaid) Update package diagrams</li> <li>(models) Improve docstring parameters</li> <li>(models) Document from_kwargs classmethod</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_4","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(actions) Change release &amp; documentation workflow dependency</li> <li>(ruff) Ignore PLR0913 code</li> <li>(ruff) Ignore C901 code</li> </ul>"},{"location":"CHANGELOG.html#testing_3","title":"\ud83e\uddea Testing","text":"<ul> <li>(projects) Validate new body params</li> <li>(projects) Validate status_to_query method</li> <li>(projects) Sample data fixture</li> <li>(projects) Check collect method endpoint parameters</li> <li>(user) Validate re_raise works with current tracker</li> <li>(trackers) Validate bulk edit endpoint</li> <li>(utils) Improve version testing</li> </ul>"},{"location":"CHANGELOG.html#140-2024-11-11","title":"[1.4.0] - 2024-11-11","text":""},{"location":"CHANGELOG.html#features_5","title":"\ud83d\ude80 Features","text":"<ul> <li>(exceptions) Custom exceptions for commonly raised value errors</li> <li>(cache) Custom missing parent error</li> </ul>"},{"location":"CHANGELOG.html#bug-fixes_5","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(project) Wrong hex code for gray color</li> <li>(utils) Remove unnecessary import</li> </ul>"},{"location":"CHANGELOG.html#refactor_5","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(tag) Edit endpoint method accepts seperate name argument</li> <li>(tag) Validate minimum name length</li> <li>(endpoint) Use generics with base endpoint</li> <li>(cache) User generic type with cache</li> <li>(endpoint) Assign generics to all endpoints</li> <li>(endpoint) Cache query method always returns list</li> <li>(typing) Generics implementation</li> <li>(workspace) Use custom exceptions for raised errors</li> <li>(user) Use custom exceptions for raised errors</li> <li>(user) Use custom exceptions for raised errors</li> <li>(tag) Use custom exceptions for raised errors</li> <li>(project) Use custom exceptions for raised errors</li> <li>(client) Use custom exceptions for raised errors</li> <li>(models) Use naming error instead of value error</li> <li>(cache) Implement new error subclass</li> </ul>"},{"location":"CHANGELOG.html#deprecations_2","title":"\ud83d\udd78 Deprecations","text":"<ul> <li>(tag) Remove the internal usage of a modified name in a tag</li> <li>(trackers) Change exception type in add endpoint method</li> </ul>"},{"location":"CHANGELOG.html#documentation_6","title":"\ud83d\udcda Documentation","text":"<ul> <li>(tag) Update edit endpoint docstring</li> <li>(tag) Improve delete endpoint docstring</li> <li>(tag) Improve add endpoint method docstring</li> <li>(tag) Improve endpoint class docstring</li> <li>(organization) Use custom exceptions for raised errors docstring</li> <li>(exceptions) Document new exception classes</li> <li>(mkdocs) Enable symbols in table of contents</li> <li>(config) Reconfigure headings</li> </ul>"},{"location":"CHANGELOG.html#testing_4","title":"\ud83e\uddea Testing","text":"<ul> <li>(tag) Validate tag name length</li> <li>(conftest) Rate limit trackers teardown</li> <li>(utility) Make sure version is updated</li> </ul>"},{"location":"CHANGELOG.html#132-2024-11-05","title":"[1.3.2] - 2024-11-05","text":""},{"location":"CHANGELOG.html#bug-fixes_6","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(cache) Json query hashable type error</li> <li>(cache) Check for all sequences</li> </ul>"},{"location":"CHANGELOG.html#documentation_7","title":"\ud83d\udcda Documentation","text":"<ul> <li>(endpoint) Improve cached endpoint docstrings</li> <li>(cache) Improve base cache docstring</li> <li>(cache) Improve json cache docstrings</li> <li>(cache) Improve sqlite cache docstrings</li> </ul>"},{"location":"CHANGELOG.html#testing_5","title":"\ud83e\uddea Testing","text":"<ul> <li>(cache) Test for distinct flag and unhashable types</li> </ul>"},{"location":"CHANGELOG.html#131-2024-11-02","title":"[1.3.1] - 2024-11-02","text":""},{"location":"CHANGELOG.html#bug-fixes_7","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(user) Refresh not getting passed to request</li> <li>(cache) Json query distinct &amp; list comparisons</li> </ul>"},{"location":"CHANGELOG.html#refactor_6","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(endpoints) Add future type import</li> </ul>"},{"location":"CHANGELOG.html#documentation_8","title":"\ud83d\udcda Documentation","text":"<ul> <li>(tracker) Add examples to docstrings</li> </ul>"},{"location":"CHANGELOG.html#130-2024-10-31","title":"[1.3.0] - 2024-10-31","text":""},{"location":"CHANGELOG.html#features_6","title":"\ud83d\ude80 Features","text":"<ul> <li>(workspace) Workspace body dataclass</li> <li>(workspace) Add workspace endpoint</li> <li>(workspace) Collect workspaces endpoint</li> <li>(workspace) Edit workspace endpoint</li> <li>(workspace) Get time constraints</li> <li>(workspace) Statistics endpoint</li> <li>(models) Organization model</li> <li>(schema) Added organization model</li> <li>(endpoint) Added organization endpoint</li> <li>(organization) Add endpoint method</li> <li>(organization) Get endpoint method</li> <li>(models) Validate organization name</li> <li>(models) Validate workspace name</li> <li>(organization) Edit endpoint method</li> <li>(organization) Collect endpoint method</li> <li>(organization) Delete endpoint method</li> <li>(workspace) Organization id property</li> <li>(utility) Add org endpoint to cleanup</li> <li>Add organization objects to init</li> </ul>"},{"location":"CHANGELOG.html#bug-fixes_8","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(endpoint) Api status not catching json decode error</li> <li>(body) Verifying wrong variable</li> <li>(organization) Make sure edit method stores and returns model</li> </ul>"},{"location":"CHANGELOG.html#refactor_7","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(workspace) Use a blank endpoint property</li> <li>(endpoint) [breaking] Remove unnecessary class variables</li> <li>(workspace) Improve get method error handling</li> </ul>"},{"location":"CHANGELOG.html#deprecations_3","title":"\ud83d\udd78 Deprecations","text":"<ul> <li>(workspace) Accept organization instead of workspace</li> <li>(workspace) Turn get method workspace argument optional</li> </ul>"},{"location":"CHANGELOG.html#documentation_9","title":"\ud83d\udcda Documentation","text":"<ul> <li>(examples) Improve authentication information</li> <li>(workspace) Document new workspace features</li> <li>(workspace) Improve docstrings</li> <li>(api) Update project structure and mermaid</li> <li>(organization) Add organization to api reference</li> <li>(workspace) Add typed dicts to api documentation</li> <li>(config) Reword deprecation</li> <li>(models) Improve model documentation</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_5","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(dev-deps) Pytest dependency added</li> <li>(actions) Add new secrets to environment</li> </ul>"},{"location":"CHANGELOG.html#testing_6","title":"\ud83e\uddea Testing","text":"<ul> <li>(conftest) Organization id fixture</li> <li>(workspace) Cover new endpoint methods</li> <li>(tags) Extra delete method validation</li> <li>(user) Fix test date creation</li> <li>(workspace) Use org id instead</li> <li>(organization) Test all functionality</li> <li>(conftest) User id fixture</li> </ul>"},{"location":"CHANGELOG.html#120-2024-10-27","title":"[1.2.0] - 2024-10-27","text":""},{"location":"CHANGELOG.html#features_7","title":"\ud83d\ude80 Features","text":"<ul> <li>(user) User details endpoint</li> <li>(user) Verify authentication static method</li> </ul>"},{"location":"CHANGELOG.html#bug-fixes_9","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(user) Authentication verifier using wrong endpoint</li> </ul>"},{"location":"CHANGELOG.html#refactor_8","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(endpoint) User httpx error codes</li> <li>(user) Remove endpoint property forward slash</li> </ul>"},{"location":"CHANGELOG.html#deprecations_4","title":"\ud83d\udd78 Deprecations","text":"<ul> <li>(user) Check authentication method convert to staticmethod</li> </ul>"},{"location":"CHANGELOG.html#documentation_10","title":"\ud83d\udcda Documentation","text":"<ul> <li>(user) Update documentation</li> </ul>"},{"location":"CHANGELOG.html#111-2024-10-25","title":"[1.1.1] - 2024-10-25","text":""},{"location":"CHANGELOG.html#bug-fixes_10","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(config) Revert exception type change</li> <li>(cache) Check if the model has been deleted already</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_6","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(actions) Documentation requires test to pass</li> </ul>"},{"location":"CHANGELOG.html#110-2024-10-25","title":"[1.1.0] - 2024-10-25","text":""},{"location":"CHANGELOG.html#features_8","title":"\ud83d\ude80 Features","text":"<ul> <li>(cache) Json session refresh method</li> <li>(config) Get workspace helper function</li> <li>(config) Togglrc workspace retrieve helper function</li> </ul>"},{"location":"CHANGELOG.html#bug-fixes_11","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(cache) Json session diff method not including completely new models</li> </ul>"},{"location":"CHANGELOG.html#refactor_9","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(config) Extract togglrc retriever</li> </ul>"},{"location":"CHANGELOG.html#documentation_11","title":"\ud83d\udcda Documentation","text":"<ul> <li>(config) Add example to config helper functions</li> <li>(config) Add new helper functions</li> </ul>"},{"location":"CHANGELOG.html#testing_7","title":"\ud83e\uddea Testing","text":"<ul> <li>(cache) Test session refresh method and diffing</li> <li>Validate more errors</li> </ul>"},{"location":"CHANGELOG.html#104-2024-10-24","title":"[1.0.4] - 2024-10-24","text":""},{"location":"CHANGELOG.html#bug-fixes_12","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(cache) Json commit not syncing correctly</li> </ul>"},{"location":"CHANGELOG.html#documentation_12","title":"\ud83d\udcda Documentation","text":"<ul> <li>(cache) Improve json docstring</li> </ul>"},{"location":"CHANGELOG.html#103-2024-10-22","title":"[1.0.3] - 2024-10-22","text":""},{"location":"CHANGELOG.html#bug-fixes_13","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(client) Collect method not passing on refresh</li> <li>(endpoint) Methods are abiding refresh argument</li> <li>(user) Current tracker actually using cache</li> <li>(cache) Json not refreshing in find method</li> </ul>"},{"location":"CHANGELOG.html#documentation_13","title":"\ud83d\udcda Documentation","text":"<ul> <li>(contributing) Add more references</li> <li>(endpoint) Add a note for methods using external api every time</li> <li>(api) Update mermaid graphs</li> <li>(api) Project structure</li> </ul>"},{"location":"CHANGELOG.html#testing_8","title":"\ud83e\uddea Testing","text":"<ul> <li>(conftest) Change number fixture</li> </ul>"},{"location":"CHANGELOG.html#102-2024-10-18","title":"[1.0.2] - 2024-10-18","text":""},{"location":"CHANGELOG.html#deprecations_5","title":"\ud83d\udd78 Deprecations","text":"<ul> <li>(reports) Rename methods to be consistent across reports</li> </ul>"},{"location":"CHANGELOG.html#documentation_14","title":"\ud83d\udcda Documentation","text":"<ul> <li>(readme) Add changelog to links</li> <li>(reports) Add raises to docstrings</li> <li>(api) Small formatting changes</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_7","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(config) Coverage url</li> <li>(cliff) Fix toml escape characters</li> </ul>"},{"location":"CHANGELOG.html#101-2024-10-16","title":"[1.0.1] - 2024-10-16","text":""},{"location":"CHANGELOG.html#bug-fixes_14","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(endpoint) Logger name</li> <li>(user) Collect endpoint not returning anything without parameters</li> </ul>"},{"location":"CHANGELOG.html#documentation_15","title":"\ud83d\udcda Documentation","text":"<ul> <li>(cache) Fix docstring</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_8","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(precommit) Added gitleaks</li> <li>(config) Additional urls</li> </ul>"},{"location":"CHANGELOG.html#testing_9","title":"\ud83e\uddea Testing","text":"<ul> <li>(user) Collect method with no parameters</li> </ul>"},{"location":"CHANGELOG.html#100-2024-10-15","title":"[1.0.0] - 2024-10-15","text":""},{"location":"CHANGELOG.html#features_9","title":"\ud83d\ude80 Features","text":"<ul> <li>(utility) Requires decorator</li> <li>Python 3.13 support</li> <li>(cache) Comparison enumeration</li> <li>(cache) Toggl query dataclass</li> </ul>"},{"location":"CHANGELOG.html#bug-fixes_15","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(tracker) Adjust error type</li> <li>(utility) Swap datetime conditional</li> <li>(endpoint) Refactor server error retry logic</li> <li>(endpoints) Return none on 404</li> <li>(cache) Sqlite delete method</li> <li>(user) Collect method not correctly formatting time arguments</li> </ul>"},{"location":"CHANGELOG.html#refactor_10","title":"\ud83d\ude9c Refactor","text":"<ul> <li>[breaking] Merge modules with toggl_api</li> <li>(endpoints) [breaking] Remove deprecated methods</li> <li>(body) [breaking] Remove deprecated workspace_id parameter</li> <li>(deps) [breaking] Convert sqlalchemy to optional dependency</li> <li>(workspace) Improved get endpoint</li> <li>(client) Use literal for typing status strings</li> <li>(tag) Delete endpoint typing</li> <li>(reports) Make pagination options optional</li> <li>(cache) [breaking] Remove inverse flag</li> <li>(cache) Abstract class query method</li> <li>(cache) Json query method</li> <li>(cache) Sqlite query method</li> <li>(user) Fully implement collect method cache retrieval</li> <li>(endpoints) Logging for caught exceptions</li> <li>Additional debug logging</li> <li>(models) Remove optional type from timestamp</li> <li>(cache) Fix typing issues</li> </ul>"},{"location":"CHANGELOG.html#documentation_16","title":"\ud83d\udcda Documentation","text":"<ul> <li>(readme) Update readme</li> <li>(api) Update docs to new directory structure</li> <li>Update examples</li> <li>(mermaid) Update diagrams</li> <li>(cache) Improved metaclass</li> <li>(panzoom) Full screen enabled</li> <li>(endpoints) Add official api links</li> <li>Show source on endpoints</li> <li>(example) Reports example</li> <li>(readme) Add examples</li> <li>(cache) Query docstrings added</li> <li>(example) Logging example</li> <li>(contributing) Additional instructions</li> </ul>"},{"location":"CHANGELOG.html#styling_1","title":"\ud83c\udfa8 Styling","text":"<ul> <li>(cache) Remove optional type annotation as return</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_9","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Update coverage config</li> <li>(precommit) Added mypy</li> <li>(nvim) Function for generating official docstrings</li> <li>(actions) Simplify workflows</li> <li>(typing) Add py.typed file</li> </ul>"},{"location":"CHANGELOG.html#testing_10","title":"\ud83e\uddea Testing","text":"<ul> <li>(user) Additional status code tests</li> <li>(endpoints) Additional argument types</li> <li>(reports) Validate extensions</li> <li>(tracker) Mock http status code logic</li> <li>(sqlite) Additional tests</li> <li>(conftest) Only delay on integration tests</li> <li>(tracker) Verify creation dates logic</li> <li>More coverage</li> <li>(cache) Query conversion</li> </ul>"},{"location":"CHANGELOG.html#051-2024-10-07","title":"[0.5.1] - 2024-10-07","text":""},{"location":"CHANGELOG.html#bug-fixes_16","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(config) Removed interpolation</li> </ul>"},{"location":"CHANGELOG.html#documentation_17","title":"\ud83d\udcda Documentation","text":"<ul> <li>Update contributing</li> <li>(endpoints) Improve docstrings</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_10","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(actions) Fix release workflow</li> <li>(precommit) Add gh action validator to pre commit</li> <li>(precommit) Upgrade ruff</li> </ul>"},{"location":"CHANGELOG.html#050-2024-10-06","title":"[0.5.0] - 2024-10-06","text":""},{"location":"CHANGELOG.html#features_10","title":"\ud83d\ude80 Features","text":"<ul> <li>(endpoint) Api status endpoint</li> <li>(reports) Summary report endpoints</li> <li>(reports) Detailed report endpoints</li> <li>(reports) Weekly report endpoints</li> <li>(reports) Module level imports</li> <li>(body) Validate parameter classmethod</li> </ul>"},{"location":"CHANGELOG.html#bug-fixes_17","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(endpoint) Cache parent logic</li> <li>(utility) Date override</li> </ul>"},{"location":"CHANGELOG.html#refactor_11","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(meta) Basebody abstract class</li> <li>(endpoint) Remove final type from base endpoint</li> <li>(endpoint) Adjust to allow for more flexible models</li> <li>(reports) Adjust responses</li> <li>(util) Default cleanup delay</li> <li>(reports) Report body improvements</li> <li>(endpoints) Adjust to new body format signature</li> </ul>"},{"location":"CHANGELOG.html#deprecations_6","title":"\ud83d\udd78 Deprecations","text":"<ul> <li>Modules namespace</li> <li>(deps) Convert sqlalchemy to optional dependency</li> <li>(body) Workspace_id parameter</li> </ul>"},{"location":"CHANGELOG.html#documentation_18","title":"\ud83d\udcda Documentation","text":"<ul> <li>Show symbol type headings</li> <li>(reports) Documentation update</li> <li>Improve user guide</li> <li>Move about folder</li> <li>Update mermaid diagrams</li> <li>Update changelog</li> </ul>"},{"location":"CHANGELOG.html#styling_2","title":"\ud83c\udfa8 Styling","text":"<ul> <li>(endpoint) Removed optional as a return type</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_11","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Omit scripts folder from coverage</li> <li>(actions) Remove macos from matrix</li> <li>Git cliff configuration</li> </ul>"},{"location":"CHANGELOG.html#testing_11","title":"\ud83e\uddea Testing","text":"<ul> <li>Fix config encoding</li> <li>(reports) All endpoints</li> </ul>"},{"location":"CHANGELOG.html#040-2024-09-23","title":"[0.4.0] - 2024-09-23","text":""},{"location":"CHANGELOG.html#features_11","title":"\ud83d\ude80 Features","text":"<ul> <li>(scripts) Clean toggl script</li> </ul>"},{"location":"CHANGELOG.html#refactor_12","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(endpoint) Rename methods</li> <li>Cleanup utils</li> <li>(tags) Delete method accepts int</li> </ul>"},{"location":"CHANGELOG.html#documentation_19","title":"\ud83d\udcda Documentation","text":"<ul> <li>Fix config docstring</li> <li>Update documentation</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_12","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(nvim) .nvim.lua file</li> <li>Bump version 0.4.0</li> </ul>"},{"location":"CHANGELOG.html#testing_12","title":"\ud83e\uddea Testing","text":"<ul> <li>(client) Delete method int arg</li> </ul>"},{"location":"CHANGELOG.html#031-2024-08-13","title":"[0.3.1] - 2024-08-13","text":""},{"location":"CHANGELOG.html#refactor_13","title":"\ud83d\ude9c Refactor","text":"<ul> <li>Get custom workspace</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_13","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Fix urls</li> <li>Bump version 0.3.1</li> </ul>"},{"location":"CHANGELOG.html#testing_13","title":"\ud83e\uddea Testing","text":"<ul> <li>Extra coverage</li> </ul>"},{"location":"CHANGELOG.html#030-2024-06-26","title":"[0.3.0] - 2024-06-26","text":""},{"location":"CHANGELOG.html#refactor_14","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(cache) Allowing no expiration</li> <li>(cache) Json cache syncing</li> <li>(cache) Int allowed as argument</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_14","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Bump version 0.3.0</li> </ul>"},{"location":"CHANGELOG.html#023-2024-06-22","title":"[0.2.3] - 2024-06-22","text":""},{"location":"CHANGELOG.html#bug-fixes_18","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Tracker tag conversion</li> </ul>"},{"location":"CHANGELOG.html#documentation_20","title":"\ud83d\udcda Documentation","text":"<ul> <li>Other applications</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_15","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Updated ruff rules</li> <li>Bump version 0.2.3</li> </ul>"},{"location":"CHANGELOG.html#testing_14","title":"\ud83e\uddea Testing","text":"<ul> <li>Refactor conftest</li> </ul>"},{"location":"CHANGELOG.html#022-2024-06-21","title":"[0.2.2] - 2024-06-21","text":""},{"location":"CHANGELOG.html#bug-fixes_19","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(endpoints) Single model get methods</li> <li>Config issues</li> </ul>"},{"location":"CHANGELOG.html#refactor_15","title":"\ud83d\ude9c Refactor","text":"<ul> <li>Flexible arguments</li> </ul>"},{"location":"CHANGELOG.html#documentation_21","title":"\ud83d\udcda Documentation","text":"<ul> <li>Remove release notes</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_16","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Bump version 0.2.2</li> </ul>"},{"location":"CHANGELOG.html#021-2024-06-21","title":"[0.2.1] - 2024-06-21","text":""},{"location":"CHANGELOG.html#bug-fixes_20","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(tracker) Tag action only needed when editing</li> <li>Cached response inside list</li> </ul>"},{"location":"CHANGELOG.html#refactor_16","title":"\ud83d\ude9c Refactor","text":"<ul> <li>Logging</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_17","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Bump version 0.2.1</li> </ul>"},{"location":"CHANGELOG.html#testing_15","title":"\ud83e\uddea Testing","text":"<ul> <li>Sqlite workspace id set to random</li> </ul>"},{"location":"CHANGELOG.html#020-2024-06-20","title":"[0.2.0] - 2024-06-20","text":""},{"location":"CHANGELOG.html#features_12","title":"\ud83d\ude80 Features","text":"<ul> <li>(cache) Json max length</li> <li>(cache) Query method</li> <li>(cache) Connection close on delete</li> </ul>"},{"location":"CHANGELOG.html#bug-fixes_21","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(tracker) Bad body conditonal brackets</li> <li>(user) Missing raise</li> </ul>"},{"location":"CHANGELOG.html#refactor_17","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(model) Better str representation</li> </ul>"},{"location":"CHANGELOG.html#documentation_22","title":"\ud83d\udcda Documentation","text":"<ul> <li>Update readme</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_18","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Update httpx</li> <li>Bump version 0.2.0</li> </ul>"},{"location":"CHANGELOG.html#011-2024-06-11","title":"[0.1.1] - 2024-06-11","text":""},{"location":"CHANGELOG.html#bug-fixes_22","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Tracker start error handling</li> <li>(endpoint) Retry on server error</li> </ul>"},{"location":"CHANGELOG.html#refactor_18","title":"\ud83d\ude9c Refactor","text":"<ul> <li>Removed unnecessary method</li> <li>Base url added to client</li> </ul>"},{"location":"CHANGELOG.html#documentation_23","title":"\ud83d\udcda Documentation","text":"<ul> <li>Improved api documentation</li> </ul>"},{"location":"CHANGELOG.html#styling_3","title":"\ud83c\udfa8 Styling","text":"<ul> <li>Various changes</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_19","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Fix release drafter</li> <li>Version 0.1.1</li> </ul>"},{"location":"CHANGELOG.html#010-2024-06-10","title":"[0.1.0] - 2024-06-10","text":""},{"location":"CHANGELOG.html#features_13","title":"\ud83d\ude80 Features","text":"<ul> <li>Basic project structure</li> <li>Toggl client metaclass</li> <li>Tracker api</li> <li>Dataclasses</li> <li>User endpoint</li> <li>Project api</li> <li>Workspace api</li> <li>Tag api</li> <li>Client api</li> <li>Config utility</li> <li>Added classes to init</li> <li>Utility functions</li> <li>Workspace utility</li> <li>Sql schema</li> <li>Cache model</li> <li>(trackers) Body dataclass</li> <li>(projects) Body dataclass</li> <li>(clients) Body dataclass</li> <li>(trackers) Add tracker value checking</li> </ul>"},{"location":"CHANGELOG.html#bug-fixes_23","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(client) Wrong workspace id</li> <li>Python 3.10 compatibility</li> <li>Typing logic</li> <li>Python 3.10 datetime parsing</li> <li>(user) Missing refresh arg</li> <li>(models) Timezone issues with sechma</li> <li>(cache) Sqlite caching changes</li> <li>(trackers) Stop endpoint</li> </ul>"},{"location":"CHANGELOG.html#work-in-progress","title":"\ud83d\udea7 Work In Progress","text":"<ul> <li>Caching mechanism</li> <li>Cache mechanism</li> </ul>"},{"location":"CHANGELOG.html#refactor_19","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(meta) Cleaner classes</li> <li>Remove debugging code</li> <li>Renamed src directory</li> <li>Sql schema</li> <li>Model creation</li> <li>(models) Foreign keys &amp; dict converter</li> <li>(endpoint) Merged endpoints</li> <li>Endpoint changes</li> <li>Cache adjustments</li> <li>Model adjustments</li> <li>(cache) Various changes</li> <li>General typing</li> <li>(models) Missing timezone schema</li> <li>Small changes</li> <li>Simplified config utility</li> <li>(tags) Improved json body</li> <li>Typing</li> </ul>"},{"location":"CHANGELOG.html#documentation_24","title":"\ud83d\udcda Documentation","text":"<ul> <li>Readme</li> <li>Added license</li> <li>Class &amp; package layout</li> <li>Mkdocs config</li> <li>Documentation boilerplate</li> <li>Cache flowchart</li> <li>Moved images</li> <li>Updated class graph</li> <li>Docstring</li> <li>Api documentation</li> <li>Api documentation</li> <li>User guide</li> <li>Examples</li> <li>Changelog</li> <li>Coverage badge</li> <li>Readme badge</li> </ul>"},{"location":"CHANGELOG.html#styling_4","title":"\ud83c\udfa8 Styling","text":"<ul> <li>Small changes</li> <li>Typing &amp; version</li> </ul>"},{"location":"CHANGELOG.html#miscellaneous-tasks_20","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Basic setup</li> <li>Added gitignore</li> <li>Basic data</li> <li>Ignore direnv</li> <li>Lsp &amp; lint config</li> <li>Pytest env dependency</li> <li>Pytest config</li> <li>Pytest order dependency</li> <li>Tracker cache</li> <li>Ci dependencies &amp; config</li> <li>Github publishing workflow</li> <li>Tox gh actions tweaks</li> <li>Sqlalchemy dependency</li> <li>Docs generation</li> <li>Doc dependencies</li> <li>Release notes</li> <li>Test dependencies</li> <li>Mypy config</li> <li>Sqlalchemy type stubs</li> <li>Added pre commit</li> <li>Mkdocstrings depedency</li> <li>Mkdocs dependencies</li> <li>Coverage</li> <li>Pygments dependency</li> <li>Mkdocs changelog dependency</li> <li>Poetry urls</li> <li>Mkdocs callout dependency</li> <li>Coverage</li> </ul>"},{"location":"CHANGELOG.html#testing_16","title":"\ud83e\uddea Testing","text":"<ul> <li>Conftest</li> <li>Metaclasses</li> <li>Conftest</li> <li>Teardown fixture</li> <li>Workspace id</li> <li>Refactor directory structure</li> <li>Endpoint refactor</li> <li>Pytest configuration</li> <li>Sqlite cache</li> </ul>"},{"location":"CONTRIBUTING.html","title":"Contributing","text":"<ul> <li>Setup authentication through environment variables</li> <li>Preferably a testing account for integration testing</li> </ul>"},{"location":"CONTRIBUTING.html#basic-environment","title":"Basic Environment","text":"<ul> <li>Development is ran through UV.</li> </ul> <pre><code># Clone Repository\ngit clone https://github.com/ddkasa/toggl-api-wrapper &amp;&amp;\n# Change Directory Into Repository\ncd toggl-api-wrapper &amp;&amp;\n# Install all required dependencies\nuv sync --all-groups --all-extras &amp;&amp;\n# Activate the virtual environment\nsource .venv/bin/activate\n</code></pre> <ul> <li>Lint with <code>uv run ruff check src/toggl_api</code></li> <li>Check typing with <code>uv run mypy src/toggl_api</code></li> <li>Make sure to install pre-commit hook with <code>pre-commit install</code></li> </ul>"},{"location":"CONTRIBUTING.html#testing","title":"Testing","text":"<ul> <li>Make sure to set the environment variables plus the correct workspace id through the TOGGL_WORKSPACE_ID</li> <li>All tests are run through <code>pytest</code></li> <li>Basic unit tests through <code>pytest -m unit</code></li> <li>Integration tests through <code>pytest -m integration</code></li> <li>Slow tests are marked as well <code>pytest -m slow</code></li> <li>Test all supported python versions through <code>tox</code></li> <li>Test a specific version with the <code>-e</code> flag: <code>tox -e test-py310</code></li> </ul>"},{"location":"CONTRIBUTING.html#git","title":"Git","text":"<ul> <li>Commit messages are based on Conventional Commits</li> <li>Versioning follows Semver conventions</li> </ul>"},{"location":"CONTRIBUTING.html#documentation","title":"Documentation","text":"<ul> <li>Run <code>uv sync --group docs</code> to install doc dependencies.</li> <li>Run <code>mkdocs serve --strict</code> to build and preview documentation</li> <li>Run <code>git cliff -o docs/CHANGELOG.md</code> to generate new changelog. Requires git-cliff to be installed.</li> <li>Use Google styleguide for docstring format</li> <li>Run <code>sh ./scripts/create_diagrams.sh</code> to generate documentation mermaid diagrams and file tree.</li> </ul>"},{"location":"LICENSE.html","title":"License","text":"<p>Copyright (C) 2024 David Kasakaitis</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"api-guide/index.html","title":"Project Structure","text":"<pre><code>src/toggl_api\n\u251c\u2500\u2500 asyncio\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _async_cache.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _async_client.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _async_endpoint.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _async_organization.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _async_project.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _async_reports.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _async_sqlite_cache.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _async_tag.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _async_tracker.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _async_user.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _async_workspace.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 _client.py\n\u251c\u2500\u2500 config.py\n\u251c\u2500\u2500 _exceptions.py\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 meta\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _base_endpoint.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _body.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 cache\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 _base_cache.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 _json_cache.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 _sqlite_cache.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _cached_endpoint.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _enums.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 models\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _decorators.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _models.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 _schema.py\n\u251c\u2500\u2500 _organization.py\n\u251c\u2500\u2500 _project.py\n\u251c\u2500\u2500 py.typed\n\u251c\u2500\u2500 reports.py\n\u251c\u2500\u2500 _tag.py\n\u251c\u2500\u2500 _tracker.py\n\u251c\u2500\u2500 _user.py\n\u251c\u2500\u2500 _utility.py\n\u251c\u2500\u2500 _version.py\n\u2514\u2500\u2500 _workspace.py\n\n5 directories, 39 files\n</code></pre>"},{"location":"api-guide/index.html#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n  class AsyncClientEndpoint {\n    MODEL\n    endpoint\n    workspace_id\n    add(body: ClientBody) TogglClient\n    collect(body: ClientBody | None) list[TogglClient]\n    delete(client: TogglClient | int) None\n    edit(client: TogglClient | int, body: ClientBody) TogglClient\n    get(client_id: int | TogglClient) TogglClient | None\n  }\n  class AsyncDetailedReportEndpoint {\n    endpoint\n    export_report(body: ReportBody, extension: ReportFormats, pagination: PaginationOptions | None) PaginatedResult[bytes]\n    search_time_entries(body: ReportBody, pagination: PaginationOptions | None) PaginatedResult[list[dict[str, Any]]]\n    totals_report(body: ReportBody) dict[str, int]\n  }\n  class AsyncOrganizationEndpoint {\n    MODEL\n    add(name: str, workspace_name: str) TogglOrganization\n    collect() list[TogglOrganization]\n    delete(organization: TogglOrganization | int) None\n    edit(organization: TogglOrganization | int, name: str) TogglOrganization\n    get(organization: TogglOrganization | int) TogglOrganization | None\n  }\n  class AsyncProjectEndpoint {\n    BASIC_COLORS : Final[dict[str, str]]\n    MODEL\n    endpoint\n    workspace_id\n    add(body: ProjectBody) TogglProject\n    collect(body: ProjectBody | None) list[TogglProject]\n    delete(project: TogglProject | int) None\n    edit(project: TogglProject | int, body: ProjectBody) TogglProject\n    get(project_id: int | TogglProject) TogglProject | None\n    get_color(name: str) str\n    get_color_id(color: str) int\n    status_to_query(status: TogglProject.Status, statement: Select[Any]) Select[Any]\n  }\n  class AsyncReportEndpoint {\n    BASE_ENDPOINT : ClassVar[URL]\n    workspace_id\n    export_report(body: ReportBody)* Any\n    search_time_entries(body: ReportBody)* Any\n  }\n  class AsyncSqliteCache {\n    cache_path\n    database\n    metadata\n    add() None\n    delete() None\n    find(pk: int) T | None\n    load() list[T]\n    update() None\n  }\n  class AsyncSummaryReportEndpoint {\n    endpoint\n    export_report(body: ReportBody, extension: ReportFormats) bytes\n    project_summaries(start_date: date | str, end_date: date | str) list[dict[str, int]]\n    project_summary(project: TogglProject | int, start_date: date | str, end_date: date | str) dict[str, int]\n    search_time_entries(body: ReportBody) list[dict[str, int]]\n  }\n  class AsyncTagEndpoint {\n    MODEL\n    endpoint\n    workspace_id\n    add(name: str) TogglTag\n    collect() list[TogglTag]\n    delete(tag: TogglTag | int) None\n    edit(tag: TogglTag | int, name: str) TogglTag\n    get(tag: TogglTag | int) TogglTag | None\n  }\n  class AsyncTrackerEndpoint {\n    MODEL\n    TRACKER_ALREADY_STOPPED : Final[int]\n    TRACKER_NOT_RUNNING : Final[int]\n    endpoint\n    workspace_id\n    add(body: TrackerBody) TogglTracker\n    bulk_edit() Edits\n    collect(since: int | datetime | None, before: date | None, start_date: date | None, end_date: date | None) list[TogglTracker]\n    current() TogglTracker | None\n    delete(tracker: TogglTracker | int) None\n    edit(tracker: TogglTracker | int, body: TrackerBody) TogglTracker\n    get(tracker_id: int | TogglTracker) TogglTracker | None\n    stop(tracker: TogglTracker | int) TogglTracker | None\n  }\n  class AsyncUserEndpoint {\n    get_details() dict[str, Any]\n  }\n  class AsyncWeeklyReportEndpoint {\n    endpoint\n    export_report(body: ReportBody, extension: ReportFormats) bytes\n    search_time_entries(body: ReportBody) list[dict[str, Any]]\n  }\n  class AsyncWorkspaceEndpoint {\n    MODEL\n    organization_id\n    add(body: WorkspaceBody) TogglWorkspace\n    collect(since: datetime | int | None) list[TogglWorkspace]\n    edit(workspace_id: TogglWorkspace | int, body: WorkspaceBody) TogglWorkspace\n    get(workspace: TogglWorkspace | int) TogglWorkspace | None\n    statistics(workspace_id: TogglWorkspace | int) WorkspaceStatistics\n    tracker_constraints(workspace_id: TogglWorkspace | int) dict[str, bool]\n  }\n  class AuthenticationError {\n  }\n  class BaseBody {\n    format(endpoint: str)* dict[str, Any]\n  }\n  class BulkEditParameter {\n    op : Literal['add', 'remove', 'replace']\n    path : str\n    value : Any\n  }\n  class CacheCallable {\n  }\n  class ClientBody {\n    name : str | None\n    notes : str | None\n    status : CLIENT_STATUS | None\n    format(endpoint: str) dict[str, Any]\n  }\n  class ClientEndpoint {\n    MODEL\n    endpoint\n    workspace_id\n    add(body: ClientBody) TogglClient\n    collect(body: ClientBody | None) list[TogglClient]\n    delete(client: TogglClient | int) None\n    edit(client: TogglClient | int, body: ClientBody) TogglClient\n    get(client_id: int | TogglClient) TogglClient | None\n  }\n  class Comparison {\n    name\n  }\n  class CustomDecoder {\n    MATCH_DICT : Final[dict[str, type[TogglClass]]]\n    decode(obj: Any) Any\n  }\n  class CustomEncoder {\n    default(obj: Any) Any\n  }\n  class DateTimeError {\n  }\n  class DetailedReportEndpoint {\n    endpoint\n    export_report(body: ReportBody, extension: ReportFormats, pagination: PaginationOptions | None) PaginatedResult[bytes]\n    search_time_entries(body: ReportBody, pagination: PaginationOptions | None) PaginatedResult[list[dict[str, Any]]]\n    totals_report(body: ReportBody) dict[str, int]\n  }\n  class Edits {\n    failures : list[int]\n    successes : list[int]\n  }\n  class InvalidExtensionError {\n  }\n  class JSONCache {\n    cache_path\n    parent\n    session : JSONSession[T]\n    add() None\n    commit() None\n    delete() None\n    find(entry: T | dict[str, int]) T | None\n    load() list[T]\n    query() list[T]\n    save(update: Iterable[T] | T, method: RequestMethod) None\n    update() None\n  }\n  class JSONSession {\n    data : list[T]\n    max_length : int\n    modified : int\n    version : str\n    commit(path: Path) None\n    load(path: Path) None\n    process_data(data: list[T]) list[T]\n    refresh(path: Path) bool\n  }\n  class MissingParentError {\n  }\n  class NamingError {\n  }\n  class NoCacheAssignedError {\n  }\n  class OrganizationEndpoint {\n    MODEL\n    endpoint\n    add(name: str, workspace_name: str) TogglOrganization\n    collect() list[TogglOrganization]\n    delete(organization: TogglOrganization | int) None\n    edit(organization: TogglOrganization | int, name: str) TogglOrganization\n    get(organization: TogglOrganization | int) TogglOrganization | None\n  }\n  class PaginatedResult {\n    next_id : int | None\n    next_row : int | None\n    result : T\n    next_options(page_size: int) PaginationOptions\n  }\n  class PaginationOptions {\n    next_id : int | None\n    next_row : int | None\n    page_size : int\n  }\n  class ProjectBody {\n    active : bool | Literal['both']\n    client_id : int | None\n    client_ids : list[int]\n    client_name : str | None\n    color : str | None\n    end_date : date | None\n    group_ids : list[int]\n    is_private : bool | None\n    name : str | None\n    since : date | int | None\n    start_date : date | None\n    statuses : list[TogglProject.Status]\n    user_ids : list[int]\n    format(endpoint: str) dict[str, Any]\n  }\n  class ProjectEndpoint {\n    BASIC_COLORS : Final[dict[str, str]]\n    MODEL\n    endpoint\n    workspace_id\n    add(body: ProjectBody) TogglProject\n    collect(body: ProjectBody | None) list[TogglProject]\n    delete(project: TogglProject | int) None\n    edit(project: TogglProject | int, body: ProjectBody) TogglProject\n    get(project_id: int | TogglProject) TogglProject | None\n    get_color(name: str) str\n    get_color_id(color: str) int\n    status_to_query(status: TogglProject.Status) list[TogglQuery[Any]]\n  }\n  class ReportBody {\n    client_ids : list[int | None]\n    date_format : Literal['MM/DD/YYYY', 'DD-MM-YYYY', 'MM-DD-YYYY', 'YYYY-MM-DD', 'DD/MM/YYYY', 'DD.MM.YYYY']\n    description : str | None\n    duration_format : Literal['classic', 'decimal', 'improved']\n    end_date : date | None\n    enrich_response : bool\n    group_ids : list[int]\n    grouped : bool\n    grouping : str | None\n    include_time_entry_ids : bool\n    max_duration_seconds : int | None\n    min_duration_seconds : int | None\n    order_by : Literal['title', 'duration'] | None\n    order_dir : Literal['ASC', 'DESC'] | None\n    project_ids : list[int | None]\n    resolution : str | None\n    rounding : int | None\n    rounding_minutes : Literal[0, 1, 5, 6, 10, 12, 15, 30, 60, 240] | None\n    start_date : date | None\n    sub_grouping : str | None\n    tag_ids : list[int | None]\n    time_entry_ids : list[int]\n    user_ids : list[int]\n    format(endpoint: str) dict[str, Any]\n  }\n  class ReportEndpoint {\n    BASE_ENDPOINT : ClassVar[str]\n    workspace_id\n    export_report(body: ReportBody)* Any\n    search_time_entries(body: ReportBody)* Any\n  }\n  class RequestMethod {\n    name\n  }\n  class SqliteCache {\n    cache_path\n    database\n    metadata\n    session\n    add() None\n    commit() None\n    delete() None\n    find(query: T | dict[str, Any]) T | None\n    load() Query[T]\n    query() Query[T]\n    update() None\n  }\n  class Status {\n    name\n  }\n  class SummaryReportEndpoint {\n    endpoint\n    export_report(body: ReportBody, extension: ReportFormats) bytes\n    project_summaries(start_date: date | str, end_date: date | str) list[dict[str, int]]\n    project_summary(project: TogglProject | int, start_date: date | str, end_date: date | str) dict[str, int]\n    search_time_entries(body: ReportBody) list[dict[str, int]]\n  }\n  class TagEndpoint {\n    MODEL\n    endpoint\n    workspace_id\n    add(name: str) TogglTag\n    collect() list[TogglTag]\n    delete(tag: TogglTag | int) None\n    edit(tag: TogglTag | int, name: str) TogglTag\n    get(tag: TogglTag | int) TogglTag | None\n  }\n  class TogglAsyncCache {\n    cache_path\n    expire_after\n    model\n    parent\n    add()* None\n    delete()* None\n    find(pk: int)* T | None\n    find_method(method: RequestMethod) Callable[[Any], Awaitable[Any]] | None\n    load()* Iterable[T]\n    save(entry: list[T] | T, method: RequestMethod) None\n    update()* None\n  }\n  class TogglAsyncCachedEndpoint {\n    cache\n    load_cache() Iterable[T]\n    request(parameters: str, headers: Headers | None, body: dict[str, Any] | list[Any] | None, method: RequestMethod) T | list[T] | Response | None\n    save_cache(response: list[T] | T, method: RequestMethod) None\n  }\n  class TogglAsyncEndpoint {\n    BASE_ENDPOINT : ClassVar[URL]\n    HEADERS : Final[Headers]\n    MODEL : type[T] | None\n    client\n    re_raise : bool\n    retries\n    api_status() bool\n    process_models(data: list[dict[str, Any]]) list[T]\n    request(parameters: str, headers: Headers | None, body: dict[str, Any] | list[dict[str, Any]] | None, method: RequestMethod) T | list[T] | Response | None\n  }\n  class TogglCache {\n    cache_path\n    expire_after\n    model\n    parent\n    add()* None\n    commit()* None\n    delete()* None\n    find(entry: TC | dict[str, Any])* TC | None\n    find_method(method: RequestMethod) CacheCallable[TC]\n    load()* Iterable[TC]\n    query()* Iterable[TC]\n    save(entry: Iterable[TC] | TC, method: RequestMethod) None\n    update()* None\n  }\n  class TogglCachedEndpoint {\n    cache\n    load_cache() Iterable[T]\n    query() list[T]\n    request(parameters: str, headers: Headers | None, body: dict[str, Any] | list[Any] | None, method: RequestMethod) T | list[T] | Response | None\n    save_cache(response: list[T] | T, method: RequestMethod) None\n  }\n  class TogglClass {\n    id : int\n    name : str\n    timestamp : datetime\n    from_kwargs()* Self\n  }\n  class TogglClient {\n    from_kwargs() TogglClient\n  }\n  class TogglEndpoint {\n    BASE_ENDPOINT : ClassVar[str]\n    HEADERS : Final[Headers]\n    MODEL : type[T] | None\n    client\n    re_raise : bool\n    retries\n    api_status() bool\n    process_models(data: list[dict[str, Any]]) list[T]\n    request(parameters: str, headers: Headers | None, body: dict[str, Any] | list[dict[str, Any]] | None, method: RequestMethod) T | list[T] | Response | None\n  }\n  class TogglOrganization {\n    from_kwargs() Self\n    validate_name(name: str) None\n  }\n  class TogglProject {\n    active : bool\n    client : int | None\n    color : str\n    end_date : date | None\n    start_date : date\n    stop_date : date\n    from_kwargs() TogglProject\n    get_status() TogglProject.Status\n  }\n  class TogglQuery {\n    comparison\n    key : str\n    value : T | Sequence[T]\n  }\n  class TogglTag {\n    from_kwargs() TogglTag\n  }\n  class TogglTracker {\n    duration : timedelta | None\n    project : int | None\n    start : datetime\n    stop : datetime | str | None\n    tags : list[TogglTag]\n    from_kwargs() Self\n    get_tags() list[TogglTag]\n    running() bool\n  }\n  class TogglWorkspace {\n    name : str\n    organization : int\n    from_kwargs() Self\n    validate_name(name: str) None\n  }\n  class TrackerBody {\n    created_with : str\n    description : str | None\n    duration : int | timedelta | None\n    project_id : int | None\n    shared_with_user_ids : list[int]\n    start : datetime | None\n    stop : datetime | None\n    tag_action : Literal['add', 'remove'] | None\n    tag_ids : list[int]\n    tags : list[str]\n    format(endpoint: str) dict[str, Any]\n  }\n  class TrackerEndpoint {\n    MODEL\n    TRACKER_ALREADY_STOPPED : Final[int]\n    TRACKER_NOT_RUNNING : Final[int]\n    endpoint\n    workspace_id\n    add(body: TrackerBody) TogglTracker\n    bulk_edit() Edits\n    collect(since: int | datetime | None, before: date | None, start_date: date | None, end_date: date | None) list[TogglTracker]\n    current() TogglTracker | None\n    delete(tracker: TogglTracker | int) None\n    edit(tracker: TogglTracker | int, body: TrackerBody) TogglTracker\n    get(tracker_id: int | TogglTracker) TogglTracker | None\n    stop(tracker: TogglTracker | int) TogglTracker | None\n  }\n  class UTCDateTime {\n    cache_ok : bool\n    impl\n    process_bind_param(value: datetime | None, _dialect: Dialect) datetime | None\n    process_result_value(value: datetime | None, _dialect: Dialect) datetime | None\n  }\n  class User {\n    name : str\n    user_id : int\n  }\n  class UserEndpoint {\n    get_details() dict[str, Any]\n    verify_authentication(auth: BasicAuth) bool\n  }\n  class WeeklyReportEndpoint {\n    endpoint\n    export_report(body: ReportBody, extension: ReportFormats) bytes\n    search_time_entries(body: ReportBody) list[dict[str, Any]]\n  }\n  class WorkspaceBody {\n    admins : list[int]\n    name : str | None\n    only_admins_may_create_projects : bool\n    only_admins_may_create_tags : bool\n    only_admins_see_billable_rates : bool\n    only_admins_see_team_dashboard : bool\n    projects_billable_by_default : bool\n    projects_enforce_billable : bool\n    projects_private_by_default : bool\n    rate_change_mode : Literal['start-today', 'override-current', 'override-all'] | None\n    reports_collapse : bool\n    rounding : int | None\n    rounding_minutes : int | None\n    format(endpoint: str) dict[str, Any]\n  }\n  class WorkspaceChild {\n    workspace : int\n    from_kwargs() Self\n  }\n  class WorkspaceEndpoint {\n    MODEL\n    organization_id\n    add(body: WorkspaceBody) TogglWorkspace\n    collect(since: datetime | int | None) list[TogglWorkspace]\n    edit(workspace_id: TogglWorkspace | int, body: WorkspaceBody) TogglWorkspace\n    get(workspace: TogglWorkspace | int) TogglWorkspace | None\n    statistics(workspace_id: TogglWorkspace | int) WorkspaceStatistics\n    tracker_constraints(workspace_id: TogglWorkspace | int) dict[str, bool]\n  }\n  class WorkspaceMissingError {\n  }\n  class WorkspaceStatistics {\n    admins : list[User]\n    groups_count : int\n    members_count : int\n  }\n  ClientBody --|&gt; BaseBody\n  ClientEndpoint --|&gt; TogglCachedEndpoint\n  OrganizationEndpoint --|&gt; TogglCachedEndpoint\n  ProjectBody --|&gt; BaseBody\n  ProjectEndpoint --|&gt; TogglCachedEndpoint\n  TagEndpoint --|&gt; TogglCachedEndpoint\n  TrackerBody --|&gt; BaseBody\n  TrackerEndpoint --|&gt; TogglCachedEndpoint\n  UserEndpoint --|&gt; TogglEndpoint\n  WorkspaceBody --|&gt; BaseBody\n  WorkspaceEndpoint --|&gt; TogglCachedEndpoint\n  AsyncClientEndpoint --|&gt; TogglAsyncCachedEndpoint\n  TogglAsyncCachedEndpoint --|&gt; TogglAsyncEndpoint\n  AsyncOrganizationEndpoint --|&gt; TogglAsyncCachedEndpoint\n  AsyncProjectEndpoint --|&gt; TogglAsyncCachedEndpoint\n  AsyncDetailedReportEndpoint --|&gt; AsyncReportEndpoint\n  AsyncReportEndpoint --|&gt; TogglAsyncEndpoint\n  AsyncSummaryReportEndpoint --|&gt; AsyncReportEndpoint\n  AsyncWeeklyReportEndpoint --|&gt; AsyncReportEndpoint\n  AsyncSqliteCache --|&gt; TogglAsyncCache\n  AsyncTagEndpoint --|&gt; TogglAsyncCachedEndpoint\n  AsyncTrackerEndpoint --|&gt; TogglAsyncCachedEndpoint\n  AsyncUserEndpoint --|&gt; TogglAsyncEndpoint\n  AsyncWorkspaceEndpoint --|&gt; TogglAsyncCachedEndpoint\n  TogglCachedEndpoint --|&gt; TogglEndpoint\n  JSONCache --|&gt; TogglCache\n  SqliteCache --|&gt; TogglCache\n  TogglClient --|&gt; WorkspaceChild\n  TogglOrganization --|&gt; TogglClass\n  TogglProject --|&gt; WorkspaceChild\n  TogglTag --|&gt; WorkspaceChild\n  TogglTracker --|&gt; WorkspaceChild\n  TogglWorkspace --|&gt; TogglClass\n  WorkspaceChild --|&gt; TogglClass\n  DetailedReportEndpoint --|&gt; ReportEndpoint\n  ReportBody --|&gt; BaseBody\n  ReportEndpoint --|&gt; TogglEndpoint\n  SummaryReportEndpoint --|&gt; ReportEndpoint\n  WeeklyReportEndpoint --|&gt; ReportEndpoint\n  Comparison --* TogglQuery : comparison\n  TogglClient --* ClientEndpoint : MODEL\n  TogglClient --* AsyncClientEndpoint : MODEL\n  TogglOrganization --* OrganizationEndpoint : MODEL\n  TogglOrganization --* AsyncOrganizationEndpoint : MODEL\n  TogglProject --* ProjectEndpoint : MODEL\n  TogglProject --* AsyncProjectEndpoint : MODEL\n  TogglTag --* TagEndpoint : MODEL\n  TogglTag --* AsyncTagEndpoint : MODEL\n  TogglTracker --* TrackerEndpoint : MODEL\n  TogglTracker --* AsyncTrackerEndpoint : MODEL\n  TogglWorkspace --* WorkspaceEndpoint : MODEL\n  TogglWorkspace --* AsyncWorkspaceEndpoint : MODEL\n</code></pre>"},{"location":"api-guide/index.html#package-diagram","title":"Package Diagram","text":"<pre><code>classDiagram\n  class toggl_api {\n  }\n  class _client {\n  }\n  class _exceptions {\n  }\n  class _organization {\n  }\n  class _project {\n  }\n  class _tag {\n  }\n  class _tracker {\n  }\n  class _user {\n  }\n  class _utility {\n  }\n  class _version {\n  }\n  class _workspace {\n  }\n  class asyncio {\n  }\n  class _async_cache {\n  }\n  class _async_client {\n  }\n  class _async_endpoint {\n  }\n  class _async_organization {\n  }\n  class _async_project {\n  }\n  class _async_reports {\n  }\n  class _async_sqlite_cache {\n  }\n  class _async_tag {\n  }\n  class _async_tracker {\n  }\n  class _async_user {\n  }\n  class _async_workspace {\n  }\n  class config {\n  }\n  class meta {\n  }\n  class _base_endpoint {\n  }\n  class _body {\n  }\n  class _cached_endpoint {\n  }\n  class _enums {\n  }\n  class cache {\n  }\n  class _base_cache {\n  }\n  class _json_cache {\n  }\n  class _sqlite_cache {\n  }\n  class models {\n  }\n  class _decorators {\n  }\n  class _models {\n  }\n  class _schema {\n  }\n  class reports {\n  }\n  toggl_api --&gt; _client\n  toggl_api --&gt; _exceptions\n  toggl_api --&gt; _organization\n  toggl_api --&gt; _project\n  toggl_api --&gt; _tag\n  toggl_api --&gt; _tracker\n  toggl_api --&gt; _user\n  toggl_api --&gt; _version\n  toggl_api --&gt; _workspace\n  toggl_api --&gt; models\n  _client --&gt; _exceptions\n  _client --&gt; meta\n  _client --&gt; cache\n  _client --&gt; models\n  _organization --&gt; meta\n  _organization --&gt; meta\n  _organization --&gt; models\n  _project --&gt; _exceptions\n  _project --&gt; _utility\n  _project --&gt; meta\n  _project --&gt; cache\n  _project --&gt; models\n  _tag --&gt; _exceptions\n  _tag --&gt; meta\n  _tag --&gt; cache\n  _tag --&gt; models\n  _tracker --&gt; _exceptions\n  _tracker --&gt; _utility\n  _tracker --&gt; meta\n  _tracker --&gt; cache\n  _tracker --&gt; models\n  _user --&gt; meta\n  _workspace --&gt; _exceptions\n  _workspace --&gt; _utility\n  _workspace --&gt; meta\n  _workspace --&gt; cache\n  _workspace --&gt; models\n  asyncio --&gt; _async_cache\n  asyncio --&gt; _async_client\n  asyncio --&gt; _async_endpoint\n  asyncio --&gt; _async_organization\n  asyncio --&gt; _async_project\n  asyncio --&gt; _async_reports\n  asyncio --&gt; _async_sqlite_cache\n  asyncio --&gt; _async_tag\n  asyncio --&gt; _async_tracker\n  asyncio --&gt; _async_user\n  asyncio --&gt; _async_workspace\n  _async_cache --&gt; _exceptions\n  _async_cache --&gt; _enums\n  _async_cache --&gt; models\n  _async_client --&gt; toggl_api\n  _async_client --&gt; _async_endpoint\n  _async_client --&gt; meta\n  _async_endpoint --&gt; _exceptions\n  _async_endpoint --&gt; meta\n  _async_endpoint --&gt; models\n  _async_organization --&gt; _async_endpoint\n  _async_organization --&gt; meta\n  _async_organization --&gt; models\n  _async_project --&gt; toggl_api\n  _async_project --&gt; _exceptions\n  _async_project --&gt; _async_endpoint\n  _async_project --&gt; meta\n  _async_reports --&gt; toggl_api\n  _async_reports --&gt; _utility\n  _async_reports --&gt; _async_endpoint\n  _async_reports --&gt; meta\n  _async_reports --&gt; reports\n  _async_sqlite_cache --&gt; _async_cache\n  _async_sqlite_cache --&gt; models\n  _async_sqlite_cache --&gt; _schema\n  _async_tag --&gt; toggl_api\n  _async_tag --&gt; _exceptions\n  _async_tag --&gt; _async_endpoint\n  _async_tag --&gt; meta\n  _async_tracker --&gt; toggl_api\n  _async_tracker --&gt; _exceptions\n  _async_tracker --&gt; _tracker\n  _async_tracker --&gt; _utility\n  _async_tracker --&gt; _async_endpoint\n  _async_tracker --&gt; meta\n  _async_user --&gt; _async_endpoint\n  _async_workspace --&gt; toggl_api\n  _async_workspace --&gt; _utility\n  _async_workspace --&gt; _async_endpoint\n  _async_workspace --&gt; meta\n  meta --&gt; _base_endpoint\n  meta --&gt; _body\n  meta --&gt; _cached_endpoint\n  meta --&gt; _enums\n  _base_endpoint --&gt; _enums\n  _base_endpoint --&gt; models\n  _cached_endpoint --&gt; _exceptions\n  _cached_endpoint --&gt; _base_endpoint\n  _cached_endpoint --&gt; _enums\n  _cached_endpoint --&gt; models\n  cache --&gt; _base_cache\n  cache --&gt; _json_cache\n  cache --&gt; _sqlite_cache\n  _base_cache --&gt; _exceptions\n  _base_cache --&gt; _enums\n  _base_cache --&gt; models\n  _json_cache --&gt; _utility\n  _json_cache --&gt; _version\n  _json_cache --&gt; _base_cache\n  _json_cache --&gt; models\n  _sqlite_cache --&gt; _utility\n  _sqlite_cache --&gt; _base_cache\n  _sqlite_cache --&gt; models\n  _sqlite_cache --&gt; _schema\n  models --&gt; _models\n  models --&gt; _schema\n  _models --&gt; _exceptions\n  _models --&gt; _utility\n  _schema --&gt; _utility\n  _schema --&gt; _decorators\n  _schema --&gt; _models\n  reports --&gt; _exceptions\n  reports --&gt; _utility\n  reports --&gt; meta\n  reports --&gt; models\n  _client ..&gt; cache\n  _organization ..&gt; cache\n  _tracker ..&gt; toggl_api\n  _tracker ..&gt; cache\n  _workspace ..&gt; toggl_api\n  _async_cache ..&gt; _async_endpoint\n  _async_client ..&gt; _async_sqlite_cache\n  _async_endpoint ..&gt; _async_sqlite_cache\n  _async_organization ..&gt; _async_sqlite_cache\n  _async_project ..&gt; _project\n  _async_project ..&gt; _async_sqlite_cache\n  _async_sqlite_cache ..&gt; _async_endpoint\n  _async_tag ..&gt; _async_sqlite_cache\n  _async_tracker ..&gt; _async_sqlite_cache\n  _async_workspace ..&gt; _async_sqlite_cache\n  _cached_endpoint ..&gt; _base_cache\n  _base_cache ..&gt; meta\n  _json_cache ..&gt; meta\n  _sqlite_cache ..&gt; meta\n</code></pre>"},{"location":"api-guide/cache.html","title":"Cache","text":""},{"location":"api-guide/cache.html#general-cache-flow","title":"General Cache Flow","text":"<pre><code>flowchart TD\n    request &lt;--&gt; load\n    request &lt;--&gt;|if delete request|delete &lt;--&gt; find\n    request &lt;--&gt; |if get or put request|add &lt;--&gt; find\n    request &lt;---&gt; |if patch or post request|update  &lt;--&gt; find\n    request &lt;---&gt; |if cache is valid and get request| find\n\n    request[request method] --&gt; valid[\\valid?/] --&gt; save\n    valid ----&gt; returnn\n    save -----&gt; returnl[return list of objects]\n    save -----&gt; returnn[return none]\n    save -----&gt; returno[return single object]\n\n</code></pre>"},{"location":"api-guide/cache.html#toggl_api.MissingParentError","title":"toggl_api.MissingParentError","text":"<p>               Bases: <code>AttributeError</code></p> <p>Cache object doesn't have a parent endpoint associated and is being called used.</p>"},{"location":"api-guide/cache.html#toggl_api.meta.cache.TogglCache","title":"toggl_api.meta.cache.TogglCache","text":"<p>               Bases: <code>ABC</code>, <code>Generic[TC]</code></p> <p>Abstract class for caching Toggl API data to disk.</p> <p>Integrates as the backend for the TogglCachedEndpoint in order to store requested models locally.</p> PARAMETER DESCRIPTION <code>path</code> <p>Location where the cache will be saved.</p> <p> TYPE: <code>Path | PathLike[str]</code> </p> <code>expire_after</code> <p>After how much time should the cache expire. Set to None if no expire_date or to 0 seconds for no caching at all. If using an integer it will be assumed as seconds. If set to None its ignored.</p> <p> TYPE: <code>timedelta | int | None</code> DEFAULT: <code>None</code> </p> <code>parent</code> <p>Endpoint which the cache belongs to. Doesn't need to be set through parameters as it will be auto assigned.</p> <p> TYPE: <code>TogglCachedEndpoint[TC] | None</code> DEFAULT: <code>None</code> </p> ATTRIBUTE DESCRIPTION <code>cache_path</code> <p>Path to the cache file. Will generate the folder if it does not exist.</p> <p> TYPE: <code>Path</code> </p> <code>expire_after</code> <p>Time after which the cache should be refreshed.</p> <p> TYPE: <code>timedelta | None</code> </p> <code>parent</code> <p>Parent TogglCachedEndpoint</p> <p> TYPE: <code>TogglCachedEndpoint[TC]</code> </p> METHOD DESCRIPTION <code>commit</code> <p>Commits the cache to disk, database or other form. Method for finalising the cache. Abstract.</p> <code>load_cache</code> <p>Loads the cache from disk, database or other form. Abstract.</p> <code>save_cache</code> <p>Saves and preforms action depending on request type. Abstract.</p> <code>find_entry</code> <p>Looks for a TogglClass in the cache. Abstract.</p> <code>add_entry</code> <p>Adds a TogglClass to the cache. Abstract.</p> <code>update_entry</code> <p>Updates a TogglClass in the cache. Abstract.</p> <code>delete_entry</code> <p>Deletes a TogglClass from the cache. Abstract.</p> <code>find_method</code> <p>Matches a RequestMethod to cache functionality.</p> <code>parent_exist</code> <p>Validates if the parent has been set. The parent will be generally set by the endpoint when assigned. Abstract.</p> <code>query</code> <p>Queries the cache for various varibles. Abstract.</p> RAISES DESCRIPTION <code>MissingParentError</code> <p>If the parent is None and any cache method is being accessed.</p>"},{"location":"api-guide/cache.html#toggl_api.asyncio.TogglAsyncCache","title":"toggl_api.asyncio.TogglAsyncCache","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract class for caching Toggl API data to disk.</p> <p>Integrates as the backend for the TogglCachedEndpoint in order to store requested models locally.</p> PARAMETER DESCRIPTION <code>path</code> <p>Location where the cache will be saved.</p> <p> TYPE: <code>Path | PathLike[str]</code> </p> <code>expire_after</code> <p>After how much time should the cache expire. Set to None if no expire_date or to 0 seconds for no caching at all. If using an integer it will be assumed as seconds. If set to None its ignored.</p> <p> TYPE: <code>timedelta | int | None</code> DEFAULT: <code>None</code> </p> <code>parent</code> <p>Endpoint which the cache belongs to. Doesn't need to be set through parameters as it will be auto assigned.</p> <p> TYPE: <code>TogglAsyncCachedEndpoint[T] | None</code> DEFAULT: <code>None</code> </p> ATTRIBUTE DESCRIPTION <code>cache_path</code> <p>Path to the cache file. Will generate the folder if it does not exist.</p> <p> TYPE: <code>Path</code> </p> <code>expire_after</code> <p>Time after which the cache should be refreshed.</p> <p> TYPE: <code>timedelta | None</code> </p> <code>parent</code> <p>Parent TogglCachedEndpoint</p> <p> TYPE: <code>TogglAsyncCachedEndpoint[T]</code> </p> METHOD DESCRIPTION <code>commit</code> <p>Commits the cache to disk, database or other form. Method for finalising the cache. Abstract.</p> <code>load_cache</code> <p>Loads the cache from disk, database or other form. Abstract.</p> <code>save_cache</code> <p>Saves and preforms action depending on request type. Abstract.</p> <code>find_entry</code> <p>Looks for a TogglClass in the cache. Abstract.</p> <code>add_entry</code> <p>Adds a TogglClass to the cache. Abstract.</p> <code>update_entry</code> <p>Updates a TogglClass in the cache. Abstract.</p> <code>delete_entry</code> <p>Deletes a TogglClass from the cache. Abstract.</p> <code>find_method</code> <p>Matches a RequestMethod to cache functionality.</p> <code>parent_exist</code> <p>Validates if the parent has been set. The parent will be generally set by the endpoint when assigned. Abstract.</p> RAISES DESCRIPTION <code>MissingParentError</code> <p>If the parent is None and any cache method is being accessed.</p>"},{"location":"api-guide/cache.html#querying","title":"Querying","text":""},{"location":"api-guide/cache.html#toggl_api.meta.cache.Comparison","title":"toggl_api.meta.cache.Comparison","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>src/toggl_api/meta/cache/_base_cache.py</code> <pre><code>class Comparison(enum.Enum):\n    EQUAL = enum.auto()\n    LESS_THEN = enum.auto()\n    LESS_THEN_OR_EQUAL = enum.auto()\n    GREATER_THEN = enum.auto()\n    GREATER_THEN_OR_EQUAL = enum.auto()\n</code></pre>"},{"location":"api-guide/cache.html#toggl_api.meta.cache.TogglQuery","title":"toggl_api.meta.cache.TogglQuery  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Dataclass for querying cached Toggl models.</p> ATTRIBUTE DESCRIPTION <code>key</code> <p>Name of the target column to compare against.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>Value to compare against.</p> <p> TYPE: <code>T | Sequence[T]</code> </p> <code>comparison</code> <p>The way the value should be compared. None 'EQUALS' comparisons for None numeric or time based values.</p> <p> TYPE: <code>Comparison</code> </p> Source code in <code>src/toggl_api/meta/cache/_base_cache.py</code> <pre><code>@dataclass\nclass TogglQuery(Generic[T]):\n    \"\"\"Dataclass for querying cached Toggl models.\"\"\"\n\n    key: str = field()\n    \"\"\"Name of the target column to compare against.\"\"\"\n    value: T | Sequence[T] = field()\n    \"\"\"Value to compare against.\"\"\"\n    comparison: Comparison = field(default=Comparison.EQUAL)\n    \"\"\"The way the value should be compared. None 'EQUALS' comparisons for None numeric or time based values.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        if not isinstance(self.value, date | int | timedelta) and self.comparison != Comparison.EQUAL:\n            msg = \"None 'EQUAL' comparisons only available for time or numeric based values.\"\n            raise TypeError(msg)\n\n        if isinstance(self.value, date) and not isinstance(\n            self.value,\n            datetime,\n        ):\n            if self.comparison in {\n                Comparison.LESS_THEN,\n                Comparison.GREATER_THEN_OR_EQUAL,\n            }:\n                self.value = datetime.combine(  # type: ignore[assignment]\n                    self.value,\n                    datetime.min.time(),\n                    tzinfo=timezone.utc,\n                )\n            else:\n                self.value = datetime.combine(  # type: ignore[assignment]\n                    self.value,\n                    datetime.max.time(),\n                    tzinfo=timezone.utc,\n                )\n</code></pre>"},{"location":"api-guide/cache.html#toggl_api.meta.cache.TogglQuery.key","title":"key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>key: str = field()\n</code></pre> <p>Name of the target column to compare against.</p>"},{"location":"api-guide/cache.html#toggl_api.meta.cache.TogglQuery.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: T | Sequence[T] = field()\n</code></pre> <p>Value to compare against.</p>"},{"location":"api-guide/cache.html#toggl_api.meta.cache.TogglQuery.comparison","title":"comparison  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comparison: Comparison = field(default=EQUAL)\n</code></pre> <p>The way the value should be compared. None 'EQUALS' comparisons for None numeric or time based values.</p>"},{"location":"api-guide/cache.html#sqlite","title":"SQLite","text":"<p>Info</p> <p>Make sure to install SQLAlchemy if using SqliteCache with <code>pip install toggl-api-wrapper[sqlite]</code></p>"},{"location":"api-guide/cache.html#toggl_api.meta.cache.SqliteCache","title":"toggl_api.meta.cache.SqliteCache","text":"<p>               Bases: <code>TogglCache[T]</code></p> <p>Class for caching data to a SQLite database.</p> <p>Disconnects database on deletion or exit.</p> PARAMETER DESCRIPTION <code>path</code> <p>Where the SQLite database will be stored. Ignored if <code>engine</code> parameter is not None.</p> <p> TYPE: <code>Path | PathLike[str]</code> </p> <code>expire_after</code> <p>Time after which the cache should be refreshed. If using an integer it will be assumed as seconds. If set to None the cache will never expire.</p> <p> TYPE: <code>timedelta | int | None</code> DEFAULT: <code>None</code> </p> <code>parent</code> <p>Parent endpoint that will use the cache. Assigned automatically when supplied to a cached endpoint.</p> <p> TYPE: <code>TogglCachedEndpoint[T] | None</code> DEFAULT: <code>None</code> </p> <code>engine</code> <p>Supply an existing database engine or otherwise one is created. This may be used to supply an entirely different DB, but SQLite is the one that is tested &amp; supported.</p> <p> TYPE: <code>Engine | None</code> DEFAULT: <code>None</code> </p> ATTRIBUTE DESCRIPTION <code>expire_after</code> <p>Time after which the cache should be refreshed.</p> <p> TYPE: <code>timedelta | None</code> </p> <code>database</code> <p>Sqlalchemy database engine.</p> <p> </p> <code>metadata</code> <p>Sqlalchemy metadata.</p> <p> </p> <code>session</code> <p>Sqlalchemy session.</p> <p> </p> METHOD DESCRIPTION <code>load_cache</code> <p>Loads the data from disk and stores it in the data attribute. Invalidates any entries older than expire argument.</p> <code>query</code> <p>Querying method that uses SQL to query cached objects.</p> Source code in <code>src/toggl_api/meta/cache/_sqlite_cache.py</code> <pre><code>@_requires(\"sqlalchemy\")\nclass SqliteCache(TogglCache[T]):\n    \"\"\"Class for caching data to a SQLite database.\n\n    Disconnects database on deletion or exit.\n\n    Params:\n        path: Where the SQLite database will be stored.\n            Ignored if `engine` parameter is not None.\n        expire_after: Time after which the cache should be refreshed.\n            If using an integer it will be assumed as seconds.\n            If set to None the cache will never expire.\n        parent: Parent endpoint that will use the cache. Assigned\n            automatically when supplied to a cached endpoint.\n        engine: Supply an existing database engine or otherwise one is created.\n            This may be used to supply an entirely different DB, but SQLite is\n            the one that is tested &amp; supported.\n\n    Attributes:\n        expire_after: Time after which the cache should be refreshed.\n        database: Sqlalchemy database engine.\n        metadata: Sqlalchemy metadata.\n        session: Sqlalchemy session.\n\n    Methods:\n        load_cache: Loads the data from disk and stores it in the data\n            attribute. Invalidates any entries older than expire argument.\n        query: Querying method that uses SQL to query cached objects.\n    \"\"\"\n\n    __slots__ = (\"database\", \"metadata\", \"session\")\n\n    def __init__(\n        self,\n        path: Path | PathLike[str],\n        expire_after: timedelta | int | None = None,\n        parent: TogglCachedEndpoint[T] | None = None,\n        *,\n        engine: Engine | None = None,\n    ) -&gt; None:\n        super().__init__(path, expire_after, parent)\n        self.database = engine or db.create_engine(\n            f\"sqlite:///{self.cache_path}\",\n        )\n        self.metadata = register_tables(self.database)\n\n        self.session = Session(self.database)\n        atexit.register(self.session.close)\n\n    def commit(self) -&gt; None:\n        self.session.commit()\n\n    def load(self) -&gt; Query[T]:\n        query = self.session.query(self.model)\n        if self.expire_after is not None:\n            min_ts = datetime.now(timezone.utc) - self.expire_after\n            query.filter(\n                cast(\"ColumnElement[bool]\", self.model.timestamp &gt; min_ts),\n            )\n        return query\n\n    def add(self, *entries: T) -&gt; None:\n        for item in entries:\n            if self.find(item):\n                self.update(item)\n                continue\n            self.session.add(item)\n        self.commit()\n\n    def update(self, *entries: T) -&gt; None:\n        for item in entries:\n            self.session.merge(item)\n        self.commit()\n\n    def delete(self, *entries: T) -&gt; None:\n        for entry in entries:\n            if self.find(entry):\n                self.session.query(\n                    self.model,\n                ).filter_by(id=entry.id).delete()\n        self.commit()\n\n    def find(self, query: T | dict[str, Any]) -&gt; T | None:\n        if isinstance(query, TogglClass):\n            query = {\"id\": query.id}\n\n        search = self.session.query(self.model)\n        if self._expire_after is not None:\n            min_ts = datetime.now(timezone.utc) - self._expire_after\n            search = search.filter(\n                cast(\"ColumnElement[bool]\", self.model.timestamp &gt; min_ts),\n            )\n        return search.filter_by(**query).first()\n\n    def query(\n        self,\n        *query: TogglQuery[Any],\n        distinct: bool = False,\n    ) -&gt; Query[T]:\n        \"\"\"Query method for filtering models from cache.\n\n        Filters cached model by set of supplied queries.\n\n        Supports queries with various comparisons with the [Comparison][toggl_api.meta.cache.Comparison]\n        enumeration.\n\n        Args:\n            query: Any positional argument that is used becomes query argument.\n            distinct: Whether to keep equivalent values around.\n\n        Returns:\n            A SQLAlchemy query object with parameters filtered.\n        \"\"\"\n        search = self.session.query(self.model)\n        if isinstance(self.expire_after, timedelta):\n            min_ts = datetime.now(timezone.utc) - self.expire_after\n            search = search.filter(\n                cast(\"ColumnElement[bool]\", self.model.timestamp &gt; min_ts),\n            )\n\n        search = self._query_helper(list(query), search)\n        if distinct:\n            data = [q.key for q in query]\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"ignore\", DeprecationWarning)\n                search = search.distinct(*data).group_by(*data)  # type: ignore[arg-type] # FIX: Remove and use selec tobject instead.\n        return search\n\n    def _query_helper(\n        self,\n        query: list[TogglQuery[Any]],\n        query_obj: Query[T],\n    ) -&gt; Query[T]:\n        if query:\n            query_obj = self._match_query(query.pop(0), query_obj)\n            return self._query_helper(query, query_obj)\n        return query_obj\n\n    def _match_query(\n        self,\n        query: TogglQuery[Any],\n        query_obj: Query[T],\n    ) -&gt; Query[T]:\n        value = getattr(self.model, query.key)\n        if query.comparison == Comparison.EQUAL:\n            if isinstance(query.value, Sequence) and not isinstance(\n                query.value,\n                str,\n            ):\n                return query_obj.filter(value.in_(query.value))\n            return query_obj.filter(value == query.value)\n        if query.comparison == Comparison.LESS_THEN:\n            return query_obj.filter(value &lt; query.value)\n        if query.comparison == Comparison.LESS_THEN_OR_EQUAL:\n            return query_obj.filter(value &lt;= query.value)\n        if query.comparison == Comparison.GREATER_THEN:\n            return query_obj.filter(value &gt; query.value)\n        if query.comparison == Comparison.GREATER_THEN_OR_EQUAL:\n            return query_obj.filter(value &gt;= query.value)\n        msg = f\"{query.comparison} is not implemented!\"\n        raise NotImplementedError(msg)\n\n    @property\n    def cache_path(self) -&gt; Path:\n        return super().cache_path / \"cache.sqlite\"\n\n    def __del__(self) -&gt; None:\n        with contextlib.suppress(AttributeError, TypeError):\n            self.session.close()\n</code></pre>"},{"location":"api-guide/cache.html#toggl_api.meta.cache.SqliteCache.query","title":"query","text":"<pre><code>query(*query: TogglQuery[Any], distinct: bool = False) -&gt; Query[T]\n</code></pre> <p>Query method for filtering models from cache.</p> <p>Filters cached model by set of supplied queries.</p> <p>Supports queries with various comparisons with the Comparison enumeration.</p> PARAMETER DESCRIPTION <code>query</code> <p>Any positional argument that is used becomes query argument.</p> <p> TYPE: <code>TogglQuery[Any]</code> DEFAULT: <code>()</code> </p> <code>distinct</code> <p>Whether to keep equivalent values around.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Query[T]</code> <p>A SQLAlchemy query object with parameters filtered.</p> Source code in <code>src/toggl_api/meta/cache/_sqlite_cache.py</code> <pre><code>def query(\n    self,\n    *query: TogglQuery[Any],\n    distinct: bool = False,\n) -&gt; Query[T]:\n    \"\"\"Query method for filtering models from cache.\n\n    Filters cached model by set of supplied queries.\n\n    Supports queries with various comparisons with the [Comparison][toggl_api.meta.cache.Comparison]\n    enumeration.\n\n    Args:\n        query: Any positional argument that is used becomes query argument.\n        distinct: Whether to keep equivalent values around.\n\n    Returns:\n        A SQLAlchemy query object with parameters filtered.\n    \"\"\"\n    search = self.session.query(self.model)\n    if isinstance(self.expire_after, timedelta):\n        min_ts = datetime.now(timezone.utc) - self.expire_after\n        search = search.filter(\n            cast(\"ColumnElement[bool]\", self.model.timestamp &gt; min_ts),\n        )\n\n    search = self._query_helper(list(query), search)\n    if distinct:\n        data = [q.key for q in query]\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", DeprecationWarning)\n            search = search.distinct(*data).group_by(*data)  # type: ignore[arg-type] # FIX: Remove and use selec tobject instead.\n    return search\n</code></pre>"},{"location":"api-guide/cache.html#toggl_api.models.register_tables","title":"toggl_api.models.register_tables","text":"<pre><code>register_tables(engine: Engine) -&gt; MetaData\n</code></pre> <p>Register all Toggl dataclasses to the database.</p> <p>Examples:</p> <pre><code>from sqlalchemy import create_engine\nfrom toggl_api.models import register_tables\n\nengine = create_engine(\"sqlite:///database.sqlite\")\nmetadata = register_tables(engine)\n</code></pre> PARAMETER DESCRIPTION <code>engine</code> <p>An SQLAlchemy <code>Engine</code> connected to a database.</p> <p> TYPE: <code>Engine</code> </p> RETURNS DESCRIPTION <code>MetaData</code> <p><code>MetaData</code> instance with all the info about the registered tables.</p> Source code in <code>src/toggl_api/models/_schema.py</code> <pre><code>@_requires(\"sqlalchemy\")\ndef register_tables(engine: Engine) -&gt; MetaData:\n    \"\"\"Register all Toggl dataclasses to the database.\n\n    Examples:\n        ```py\n        from sqlalchemy import create_engine\n        from toggl_api.models import register_tables\n\n        engine = create_engine(\"sqlite:///database.sqlite\")\n        metadata = register_tables(engine)\n        ```\n\n    Args:\n        engine: An SQLAlchemy `Engine` connected to a database.\n\n    Returns:\n        `MetaData` instance with all the info about the registered tables.\n    \"\"\"\n    metadata = MetaData()\n\n    _create_mappings(metadata)\n\n    metadata.create_all(engine)\n\n    return metadata\n</code></pre>"},{"location":"api-guide/cache.html#toggl_api.asyncio.AsyncSqliteCache","title":"toggl_api.asyncio.AsyncSqliteCache","text":"<p>               Bases: <code>TogglAsyncCache[T]</code></p> <p>Class for caching data to a SQLite database.</p> <p>Disconnects database on deletion or exit.</p> PARAMETER DESCRIPTION <code>path</code> <p>Where the SQLite database will be stored. Ignored if <code>engine</code> parameter is not None.</p> <p> TYPE: <code>Path | PathLike[str]</code> </p> <code>expire_after</code> <p>Time after which the cache should be refreshed. If using an integer it will be assumed as seconds. If set to None the cache will never expire.</p> <p> TYPE: <code>timedelta | int | None</code> DEFAULT: <code>None</code> </p> <code>parent</code> <p>Parent endpoint that will use the cache. Assigned automatically when supplied to a cached endpoint.</p> <p> TYPE: <code>TogglAsyncCachedEndpoint[T] | None</code> DEFAULT: <code>None</code> </p> <code>engine</code> <p>Supply an existing database engine or otherwise one is created. This may be used to supply an entirely different DB, but SQLite is the one that is tested &amp; supported.</p> <p> TYPE: <code>AsyncEngine | None</code> DEFAULT: <code>None</code> </p> <code>echo_db</code> <p>Turns on database logging for debugging.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> ATTRIBUTE DESCRIPTION <code>expire_after</code> <p>Time after which the cache should be refreshed.</p> <p> TYPE: <code>timedelta | None</code> </p> <code>database</code> <p>Async database engine that created or can also be supplied.</p> <p> </p> <code>metadata</code> <p>Metadata generated on object construction.</p> <p> TYPE: <code>MetaData</code> </p> METHOD DESCRIPTION <code>load</code> <p>Loads and expires entries from the database.</p> <code>add</code> <p>Adds new entries to the database.</p> <code>update</code> <p>Updates one or multiple existing entries.</p> <code>delete</code> <p>Deletes one or multiple existing entries.</p> <code>find</code> <p>Find an existing entry.</p> Source code in <code>src/toggl_api/asyncio/_async_sqlite_cache.py</code> <pre><code>class AsyncSqliteCache(TogglAsyncCache[T]):\n    \"\"\"Class for caching data to a SQLite database.\n\n    Disconnects database on deletion or exit.\n\n    Params:\n        path: Where the SQLite database will be stored.\n            Ignored if `engine` parameter is not None.\n        expire_after: Time after which the cache should be refreshed.\n            If using an integer it will be assumed as seconds.\n            If set to None the cache will never expire.\n        parent: Parent endpoint that will use the cache. Assigned\n            automatically when supplied to a cached endpoint.\n        engine: Supply an existing database engine or otherwise one is created.\n            This may be used to supply an entirely different DB, but SQLite is\n            the one that is tested &amp; supported.\n        echo_db: Turns on database logging for debugging.\n\n    Attributes:\n        expire_after: Time after which the cache should be refreshed.\n        database: Async database engine that created or can also be supplied.\n        metadata: Metadata generated on object construction.\n\n    Methods:\n        load: Loads and expires entries from the database.\n        add: Adds new entries to the database.\n        update: Updates one or multiple existing entries.\n        delete: Deletes one or multiple existing entries.\n        find: Find an existing entry.\n    \"\"\"\n\n    __slots__ = (\"database\", \"metadata\")\n\n    metadata: MetaData\n\n    def __init__(\n        self,\n        path: Path | PathLike[str],\n        expire_after: timedelta | int | None = None,\n        parent: TogglAsyncCachedEndpoint[T] | None = None,\n        *,\n        engine: AsyncEngine | None = None,\n        echo_db: bool = False,\n    ) -&gt; None:\n        super().__init__(path, expire_after, parent)\n        self.database = engine = engine or create_async_engine(\n            f\"sqlite+aiosqlite:///{self.cache_path}\",\n        )\n        self.database.echo = echo_db\n\n        # NOTE: Tests for an existing loop otherwise gets/creates a new one.\n        try:\n            asyncio.get_running_loop()\n            task = asyncio.create_task(async_register_tables(engine))\n            task.add_done_callback(\n                lambda x: setattr(self, \"metadata\", x.result()),\n            )\n        except RuntimeError:\n            self.metadata = asyncio.run(async_register_tables(engine))\n\n    async def load(self) -&gt; list[T]:\n        \"\"\"Load data from the database, discarding items if they are past expiration.\n\n        Rather crude load method as it will load all items into memory.\n\n        Returns:\n            A flattend list of models from the database.\n        \"\"\"\n        stmt = select(self.model)\n        if self.expire_after is not None:\n            # TODO: Routine that checks for expiration\n            # discards instead of ignoring on load.\n            min_ts = datetime.now(timezone.utc) - self.expire_after\n            stmt = stmt.filter(\n                cast(\"ColumnElement[bool]\", self.model.timestamp &gt; min_ts),\n            )\n\n        async with AsyncSession(\n            self.database,\n            expire_on_commit=False,\n        ) as session:\n            return list(\n                chain.from_iterable((await session.execute(stmt)).fetchall()),\n            )\n\n    async def add(self, *entries: T) -&gt; None:\n        \"\"\"Add multiple entries to the database.\"\"\"\n        await self.update(*entries)\n\n    async def update(self, *entries: T) -&gt; None:\n        \"\"\"Update entries in the database.\"\"\"\n        async with AsyncSession(\n            self.database,\n            expire_on_commit=False,\n        ) as session:\n            for entry in entries:\n                await session.merge(entry)\n            await session.commit()\n\n    async def delete(self, *entries: T) -&gt; None:\n        \"\"\"Delete multiple entries in the database.\"\"\"\n        async with AsyncSession(\n            self.database,\n            expire_on_commit=False,\n        ) as session:\n            for entry in entries:\n                if new := await session.get(self.model, entry.id):\n                    await session.delete(new)\n            await session.commit()\n\n    async def find(self, pk: int) -&gt; T | None:\n        \"\"\"Find a model based on a primary key.\n\n        Args:\n            pk: Primary integer key of the model.\n\n        Returns:\n            The found model or None if not found.\n        \"\"\"\n        async with AsyncSession(\n            self.database,\n            expire_on_commit=False,\n        ) as session:\n            return await session.get(self.model, pk)\n\n    @property\n    def cache_path(self) -&gt; Path:\n        \"\"\"Full path to the SQLLite database.\"\"\"\n        return super().cache_path / \"cache.sqlite\"\n</code></pre>"},{"location":"api-guide/cache.html#toggl_api.asyncio.AsyncSqliteCache.cache_path","title":"cache_path  <code>property</code>","text":"<pre><code>cache_path: Path\n</code></pre> <p>Full path to the SQLLite database.</p>"},{"location":"api-guide/cache.html#toggl_api.asyncio.AsyncSqliteCache.load","title":"load  <code>async</code>","text":"<pre><code>load() -&gt; list[T]\n</code></pre> <p>Load data from the database, discarding items if they are past expiration.</p> <p>Rather crude load method as it will load all items into memory.</p> RETURNS DESCRIPTION <code>list[T]</code> <p>A flattend list of models from the database.</p> Source code in <code>src/toggl_api/asyncio/_async_sqlite_cache.py</code> <pre><code>async def load(self) -&gt; list[T]:\n    \"\"\"Load data from the database, discarding items if they are past expiration.\n\n    Rather crude load method as it will load all items into memory.\n\n    Returns:\n        A flattend list of models from the database.\n    \"\"\"\n    stmt = select(self.model)\n    if self.expire_after is not None:\n        # TODO: Routine that checks for expiration\n        # discards instead of ignoring on load.\n        min_ts = datetime.now(timezone.utc) - self.expire_after\n        stmt = stmt.filter(\n            cast(\"ColumnElement[bool]\", self.model.timestamp &gt; min_ts),\n        )\n\n    async with AsyncSession(\n        self.database,\n        expire_on_commit=False,\n    ) as session:\n        return list(\n            chain.from_iterable((await session.execute(stmt)).fetchall()),\n        )\n</code></pre>"},{"location":"api-guide/cache.html#toggl_api.asyncio.AsyncSqliteCache.add","title":"add  <code>async</code>","text":"<pre><code>add(*entries: T) -&gt; None\n</code></pre> <p>Add multiple entries to the database.</p> Source code in <code>src/toggl_api/asyncio/_async_sqlite_cache.py</code> <pre><code>async def add(self, *entries: T) -&gt; None:\n    \"\"\"Add multiple entries to the database.\"\"\"\n    await self.update(*entries)\n</code></pre>"},{"location":"api-guide/cache.html#toggl_api.asyncio.AsyncSqliteCache.update","title":"update  <code>async</code>","text":"<pre><code>update(*entries: T) -&gt; None\n</code></pre> <p>Update entries in the database.</p> Source code in <code>src/toggl_api/asyncio/_async_sqlite_cache.py</code> <pre><code>async def update(self, *entries: T) -&gt; None:\n    \"\"\"Update entries in the database.\"\"\"\n    async with AsyncSession(\n        self.database,\n        expire_on_commit=False,\n    ) as session:\n        for entry in entries:\n            await session.merge(entry)\n        await session.commit()\n</code></pre>"},{"location":"api-guide/cache.html#toggl_api.asyncio.AsyncSqliteCache.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(*entries: T) -&gt; None\n</code></pre> <p>Delete multiple entries in the database.</p> Source code in <code>src/toggl_api/asyncio/_async_sqlite_cache.py</code> <pre><code>async def delete(self, *entries: T) -&gt; None:\n    \"\"\"Delete multiple entries in the database.\"\"\"\n    async with AsyncSession(\n        self.database,\n        expire_on_commit=False,\n    ) as session:\n        for entry in entries:\n            if new := await session.get(self.model, entry.id):\n                await session.delete(new)\n        await session.commit()\n</code></pre>"},{"location":"api-guide/cache.html#toggl_api.asyncio.AsyncSqliteCache.find","title":"find  <code>async</code>","text":"<pre><code>find(pk: int) -&gt; T | None\n</code></pre> <p>Find a model based on a primary key.</p> PARAMETER DESCRIPTION <code>pk</code> <p>Primary integer key of the model.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>T | None</code> <p>The found model or None if not found.</p> Source code in <code>src/toggl_api/asyncio/_async_sqlite_cache.py</code> <pre><code>async def find(self, pk: int) -&gt; T | None:\n    \"\"\"Find a model based on a primary key.\n\n    Args:\n        pk: Primary integer key of the model.\n\n    Returns:\n        The found model or None if not found.\n    \"\"\"\n    async with AsyncSession(\n        self.database,\n        expire_on_commit=False,\n    ) as session:\n        return await session.get(self.model, pk)\n</code></pre>"},{"location":"api-guide/cache.html#toggl_api.asyncio.async_register_tables","title":"toggl_api.asyncio.async_register_tables  <code>async</code>","text":"<pre><code>async_register_tables(engine: AsyncEngine) -&gt; MetaData\n</code></pre> <p>Set up the database with SQLAlchemy models.</p> PARAMETER DESCRIPTION <code>engine</code> <p>The engine to use when registering tables.</p> <p> TYPE: <code>AsyncEngine</code> </p> RETURNS DESCRIPTION <code>MetaData</code> <p>Engine metadata with the table implemented.</p> Source code in <code>src/toggl_api/asyncio/_async_sqlite_cache.py</code> <pre><code>async def async_register_tables(engine: AsyncEngine) -&gt; MetaData:\n    \"\"\"Set up the database with SQLAlchemy models.\n\n    Args:\n        engine: The engine to use when registering tables.\n\n    Returns:\n        Engine metadata with the table implemented.\n\n    \"\"\"\n    meta = MetaData()\n\n    _create_mappings(meta)\n\n    async with engine.begin() as conn:\n        await conn.run_sync(meta.create_all)\n\n    return meta\n</code></pre>"},{"location":"api-guide/cache.html#json","title":"JSON","text":""},{"location":"api-guide/cache.html#toggl_api.meta.cache.JSONSession","title":"toggl_api.meta.cache.JSONSession  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Data structure for storing JSON in memory.</p> <p>Similar to a SQL session as its meant to have the same/similar interface.</p> <p>This dataclass doesn't require interaction from the library user and will be created in the json cache object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cache = JSONSession(max_length=5000)\n</code></pre> PARAMETER DESCRIPTION <code>max_length</code> <p>Max length of the data to be stored.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10000</code> </p> ATTRIBUTE DESCRIPTION <code>max_length</code> <p>Max length of the data to be stored.</p> <p> TYPE: <code>int</code> </p> <code>version</code> <p>Version of the data structure.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>List of Toggl objects stored in memory.</p> <p> TYPE: <code>list[T]</code> </p> <code>modified</code> <p>Timestamp of when the cache was last modified in nanoseconds. Used for checking if another cache object has updated it recently.</p> <p> TYPE: <code>int</code> </p> METHOD DESCRIPTION <code>save</code> <p>Saves the data to a JSON file. Setting current timestamp and version.</p> <code>load</code> <p>Loads the data from disk and stores it in the data attribute. Invalidates any entries older than expire argument.</p> <code>refresh</code> <p>Utility method that checks if cache has been updated.</p> <code>process_data</code> <p>Processes models according to set attributes.</p> Source code in <code>src/toggl_api/meta/cache/_json_cache.py</code> <pre><code>@dataclass\nclass JSONSession(Generic[T]):\n    \"\"\"Data structure for storing JSON in memory.\n\n    Similar to a SQL session as its meant to have the same/similar interface.\n\n    This dataclass doesn't require interaction from the library user and will\n    be created in the json cache object.\n\n    Examples:\n        &gt;&gt;&gt; cache = JSONSession(max_length=5000)\n\n    Params:\n        max_length: Max length of the data to be stored.\n\n    Attributes:\n        max_length: Max length of the data to be stored.\n        version: Version of the data structure.\n        data: List of Toggl objects stored in memory.\n        modified: Timestamp of when the cache was last modified in nanoseconds.\n            Used for checking if another cache object has updated it recently.\n\n    Methods:\n        save: Saves the data to a JSON file. Setting current timestamp and\n            version.\n        load: Loads the data from disk and stores it in the data attribute.\n            Invalidates any entries older than expire argument.\n        refresh: Utility method that checks if cache has been updated.\n        process_data: Processes models according to set attributes.\n    \"\"\"\n\n    max_length: int = field(default=10_000)\n    version: str = field(init=False, default=__version__)\n    data: list[T] = field(default_factory=list)\n    modified: int = field(init=False, default=0)\n\n    def refresh(self, path: Path) -&gt; bool:\n        if path.exists() and path.stat().st_mtime_ns &gt; self.modified:\n            self.modified = path.stat().st_mtime_ns\n            self.data = self._diff(self._load(path)[\"data\"], self.modified)\n            return True\n        return False\n\n    def _save(self, path: Path, data: dict[str, Any]) -&gt; None:\n        with path.open(\"w\", encoding=\"utf-8\") as f:\n            json.dump(data, f, cls=CustomEncoder)\n\n    def commit(self, path: Path) -&gt; None:\n        self.refresh(path)\n        self.version = __version__\n        data = {\n            \"version\": self.version,\n            \"data\": self.process_data(self.data),\n        }\n        self._save(path, data)\n\n        self.modified = path.stat().st_mtime_ns\n\n    def _diff(self, comp: list[T], mtime: int) -&gt; list[T]:\n        old_models = {m.id: m for m in self.data}\n        new_models = {m.id: m for m in comp}\n\n        model_ids: set[int] = set(old_models)\n        model_ids.update(new_models)\n\n        new_data: list[T] = []\n        for mid in model_ids:\n            old = old_models.get(mid)\n            new = new_models.get(mid)\n            if (old is None and new is not None) or (new and old and new.timestamp &gt;= old.timestamp):\n                new_data.append(new)\n            elif old and old.timestamp.timestamp() * 10**9 &gt;= mtime:\n                new_data.append(old)\n\n        return new_data\n\n    def _load(self, path: Path) -&gt; dict[str, Any]:\n        with path.open(\"r\", encoding=\"utf-8\") as f:\n            return cast(\"dict[str, Any]\", json.load(f, cls=CustomDecoder))\n\n    def load(self, path: Path) -&gt; None:\n        if path.exists():\n            data = self._load(path)\n            self.modified = path.stat().st_mtime_ns\n            self.version = data[\"version\"]\n            self.data = self.process_data(data[\"data\"])\n        else:\n            self.version = __version__\n            self.modified = time.time_ns()\n\n    def process_data(self, data: list[T]) -&gt; list[T]:\n        data.sort(key=lambda x: x.timestamp or datetime.now(timezone.utc))\n        return data[: self.max_length]\n</code></pre>"},{"location":"api-guide/cache.html#toggl_api.meta.cache.JSONCache","title":"toggl_api.meta.cache.JSONCache","text":"<p>               Bases: <code>TogglCache[T]</code></p> <p>Class for caching Toggl data to disk in JSON format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JSONCache(Path(\"cache\"))\n</code></pre> <pre><code>&gt;&gt;&gt; cache = JSONCache(Path(\"cache\"), 3600)\n</code></pre> <pre><code>&gt;&gt;&gt; cache = JSONCache(Path(\"cache\"), timedelta(weeks=2))\n&gt;&gt;&gt; tracker_endpoint = TrackerEndpoint(231231, BasicAuth(...), cache)\n</code></pre> PARAMETER DESCRIPTION <code>path</code> <p>Path to the cache file.</p> <p> TYPE: <code>Path | PathLike[str]</code> </p> <code>expire_after</code> <p>Time after which the cache should be refreshed. If using an integer it will be assumed as seconds. If set to None the cache will never expire.</p> <p> TYPE: <code>timedelta | int | None</code> DEFAULT: <code>None</code> </p> <code>parent</code> <p>Parent endpoint that will use the cache. Assigned automatically when supplied to a cached endpoint.</p> <p> TYPE: <code>TogglCachedEndpoint[T] | None</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Max length list of the data to be stored permanently.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10000</code> </p> ATTRIBUTE DESCRIPTION <code>expire_after</code> <p>Time after which the cache should be refreshed.</p> <p> TYPE: <code>timedelta | None</code> </p> <code>session(JSONSession)</code> <p>Store the current json data in memory while handling the cache.</p> <p> TYPE: <code>timedelta | None</code> </p> METHOD DESCRIPTION <code>commit</code> <p>Wrapper for JSONSession.save() that saves the current json data to disk.</p> <code>save</code> <p>Saves the given data to the cache. Takes a list of Toggl objects or a single Toggl object as an argument and process the change before saving.</p> <code>load</code> <p>Loads the data from the cache and returns the data to the caller discarding expired entries.</p> Source code in <code>src/toggl_api/meta/cache/_json_cache.py</code> <pre><code>class JSONCache(TogglCache[T]):\n    \"\"\"Class for caching Toggl data to disk in JSON format.\n\n    Examples:\n        &gt;&gt;&gt; JSONCache(Path(\"cache\"))\n\n        &gt;&gt;&gt; cache = JSONCache(Path(\"cache\"), 3600)\n\n        &gt;&gt;&gt; cache = JSONCache(Path(\"cache\"), timedelta(weeks=2))\n        &gt;&gt;&gt; tracker_endpoint = TrackerEndpoint(231231, BasicAuth(...), cache)\n\n    Params:\n        path: Path to the cache file.\n        expire_after: Time after which the cache should be refreshed.\n            If using an integer it will be assumed as seconds.\n            If set to None the cache will never expire.\n        parent: Parent endpoint that will use the cache. Assigned automatically\n            when supplied to a cached endpoint.\n        max_length: Max length list of the data to be stored permanently.\n\n    Attributes:\n        expire_after: Time after which the cache should be refreshed.\n        session(JSONSession): Store the current json data in memory while\n            handling the cache.\n\n    Methods:\n        commit: Wrapper for JSONSession.save() that saves the current json data\n            to disk.\n        save: Saves the given data to the cache. Takes a list of Toggl\n            objects or a single Toggl object as an argument and process the\n            change before saving.\n        load: Loads the data from the cache and returns the data to the\n            caller discarding expired entries.\n    \"\"\"\n\n    __slots__ = (\"session\",)\n\n    def __init__(\n        self,\n        path: Path | PathLike[str],\n        expire_after: timedelta | int | None = None,\n        parent: TogglCachedEndpoint[T] | None = None,\n        *,\n        max_length: int = 10_000,\n    ) -&gt; None:\n        super().__init__(path, expire_after, parent)\n        self.session: JSONSession[T] = JSONSession(max_length=max_length)\n\n    def commit(self) -&gt; None:\n        log.debug(\"Saving cache to disk!\")\n        self.session.commit(self.cache_path)\n\n    def save(self, update: Iterable[T] | T, method: RequestMethod) -&gt; None:\n        self.session.refresh(self.cache_path)\n        super().save(update, method)\n\n    def load(self) -&gt; list[T]:\n        self.session.load(self.cache_path)\n        if self.expire_after is None:\n            return self.session.data\n        min_ts = datetime.now(timezone.utc) - self.expire_after\n        return [m for m in self.session.data if m.timestamp &gt;= min_ts]\n\n    def find(self, entry: T | dict[str, int], **_kwargs: Any) -&gt; T | None:\n        self.session.refresh(self.cache_path)\n        if not self.session.data:\n            return None\n        for item in self.session.data:\n            if item is not None and item[\"id\"] == entry[\"id\"] and isinstance(item, self.model):\n                return item\n        return None\n\n    def _add_entry(self, item: T) -&gt; None:\n        find_entry = self.find(item)\n        if find_entry is None:\n            return self.session.data.append(item)\n        index = self.session.data.index(find_entry)\n        item.timestamp = datetime.now(timezone.utc)\n        self.session.data[index] = item\n        return None\n\n    def add(self, *entries: T) -&gt; None:\n        for entry in entries:\n            self._add_entry(entry)\n\n    def update(self, *entries: T) -&gt; None:\n        self.add(*entries)\n\n    def _delete_entry(self, entry: T) -&gt; None:\n        find_entry = self.find(entry)\n        if not find_entry:\n            return\n        index = self.session.data.index(find_entry)\n        self.session.data.pop(index)\n\n    def delete(self, *entries: T) -&gt; None:\n        for entry in entries:\n            self._delete_entry(entry)\n\n    def query(\n        self,\n        *query: TogglQuery[Any],\n        distinct: bool = False,\n    ) -&gt; list[T]:\n        \"\"\"Query method for filtering Toggl objects from cache.\n\n        Filters cached Toggl objects by set of supplied queries.\n\n        Supports queries with various comparisons with the [Comparison][toggl_api.meta.cache.Comparison]\n        enumeration.\n\n        Args:\n            query: Any positional argument that is used becomes query argument.\n            distinct: Whether to keep the same values around. This doesn't work\n                with unhashable fields such as lists.\n\n        Returns:\n            A list of models with the query parameters that matched.\n        \"\"\"\n        log.debug(\n            \"Querying cache with %s parameters.\",\n            len(query),\n            extra={\"query\": query},\n        )\n\n        min_ts = datetime.now(timezone.utc) - self.expire_after if self.expire_after else None\n        self.session.load(self.cache_path)\n        search = self.session.data\n        existing: defaultdict[str, set[Any]] = defaultdict(set)\n\n        return [\n            model\n            for model in search\n            if self._query_helper(\n                model,\n                query,\n                existing,\n                min_ts,\n                distinct=distinct,\n            )\n        ]\n\n    def _query_helper(\n        self,\n        model: T,\n        queries: tuple[TogglQuery[Any], ...],\n        existing: dict[str, set[Any]],\n        min_ts: datetime | None,\n        *,\n        distinct: bool,\n    ) -&gt; bool:\n        if self.expire_after and min_ts and model.timestamp and min_ts &gt;= model.timestamp:\n            return False\n\n        for query in queries:\n            if (\n                distinct and not isinstance(query.value, list) and model[query.key] in existing[query.key]\n            ) or not self._match_query(model, query):\n                return False\n\n        if distinct:\n            for query in queries:\n                value = model[query.key]\n                if isinstance(value, Hashable):\n                    existing[query.key].add(value)\n\n        return True\n\n    @staticmethod\n    def _match_equal(model: T, query: TogglQuery[Any]) -&gt; bool:\n        if isinstance(query.value, Sequence) and not isinstance(\n            query.value,\n            str,\n        ):\n            value = model[query.key]\n\n            if isinstance(value, Sequence) and not isinstance(value, str):\n                return any(v == comp for comp in query.value for v in value)\n\n            return any(value == comp for comp in query.value)\n\n        return bool(model[query.key] == query.value)\n\n    @staticmethod\n    def _match_query(model: T, query: TogglQuery[Any]) -&gt; bool:\n        if query.comparison == Comparison.EQUAL:\n            return JSONCache._match_equal(model, query)\n        if query.comparison == Comparison.LESS_THEN:\n            return bool(model[query.key] &lt; query.value)\n        if query.comparison == Comparison.LESS_THEN_OR_EQUAL:\n            return bool(model[query.key] &lt;= query.value)\n        if query.comparison == Comparison.GREATER_THEN:\n            return bool(model[query.key] &gt; query.value)\n        if query.comparison == Comparison.GREATER_THEN_OR_EQUAL:\n            return bool(model[query.key] &gt;= query.value)\n        msg = f\"{query.comparison} is not implemented!\"\n        raise NotImplementedError(msg)\n\n    @property\n    def cache_path(self) -&gt; Path:\n        if self.parent is None:\n            return self._cache_path / \"cache.json\"\n        return self._cache_path / f\"cache_{self.model.__tablename__}.json\"\n\n    @property\n    def parent(self) -&gt; TogglCachedEndpoint[T]:\n        return super().parent\n\n    @parent.setter\n    def parent(self, parent: TogglCachedEndpoint[T] | None) -&gt; None:\n        self._parent = parent\n        if parent is not None:\n            self.session.load(self.cache_path)\n</code></pre>"},{"location":"api-guide/cache.html#toggl_api.meta.cache.JSONCache.query","title":"query","text":"<pre><code>query(*query: TogglQuery[Any], distinct: bool = False) -&gt; list[T]\n</code></pre> <p>Query method for filtering Toggl objects from cache.</p> <p>Filters cached Toggl objects by set of supplied queries.</p> <p>Supports queries with various comparisons with the Comparison enumeration.</p> PARAMETER DESCRIPTION <code>query</code> <p>Any positional argument that is used becomes query argument.</p> <p> TYPE: <code>TogglQuery[Any]</code> DEFAULT: <code>()</code> </p> <code>distinct</code> <p>Whether to keep the same values around. This doesn't work with unhashable fields such as lists.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>list[T]</code> <p>A list of models with the query parameters that matched.</p> Source code in <code>src/toggl_api/meta/cache/_json_cache.py</code> <pre><code>def query(\n    self,\n    *query: TogglQuery[Any],\n    distinct: bool = False,\n) -&gt; list[T]:\n    \"\"\"Query method for filtering Toggl objects from cache.\n\n    Filters cached Toggl objects by set of supplied queries.\n\n    Supports queries with various comparisons with the [Comparison][toggl_api.meta.cache.Comparison]\n    enumeration.\n\n    Args:\n        query: Any positional argument that is used becomes query argument.\n        distinct: Whether to keep the same values around. This doesn't work\n            with unhashable fields such as lists.\n\n    Returns:\n        A list of models with the query parameters that matched.\n    \"\"\"\n    log.debug(\n        \"Querying cache with %s parameters.\",\n        len(query),\n        extra={\"query\": query},\n    )\n\n    min_ts = datetime.now(timezone.utc) - self.expire_after if self.expire_after else None\n    self.session.load(self.cache_path)\n    search = self.session.data\n    existing: defaultdict[str, set[Any]] = defaultdict(set)\n\n    return [\n        model\n        for model in search\n        if self._query_helper(\n            model,\n            query,\n            existing,\n            min_ts,\n            distinct=distinct,\n        )\n    ]\n</code></pre>"},{"location":"api-guide/client.html","title":"Client","text":""},{"location":"api-guide/client.html#toggl_api.ClientBody","title":"toggl_api.ClientBody  <code>dataclass</code>","text":"<p>               Bases: <code>BaseBody</code></p> <p>JSON body dataclass for PUT, POST &amp; PATCH requests.</p> METHOD DESCRIPTION <code>format</code> <p>Format the body for JSON requests.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Name of the client. Defaults to None. Will be required if its a POST request.</p> <p> TYPE: <code>str | None</code> </p> <code>status</code> <p>Status of the client. API defaults to active. Premium Feature.</p> <p> TYPE: <code>CLIENT_STATUS | None</code> </p>"},{"location":"api-guide/client.html#toggl_api.ClientBody.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = field(default=None)\n</code></pre> <p>Name of the client. Defaults to None. Will be required if its a POST request.</p>"},{"location":"api-guide/client.html#toggl_api.ClientBody.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: CLIENT_STATUS | None = field(default=None)\n</code></pre> <p>Status of the client. API defaults to active. Premium Feature.</p>"},{"location":"api-guide/client.html#toggl_api.ClientBody.format","title":"format","text":"<pre><code>format(endpoint: str, **body: Any) -&gt; dict[str, Any]\n</code></pre> <p>Format the body for JSON requests.</p> <p>Gets called by the endpoint methods before requesting.</p> PARAMETER DESCRIPTION <code>endpoint</code> <p>API endpoint for filtering purposes.</p> <p> TYPE: <code>str</code> </p> <code>body</code> <p>Any additonal body content that the endpoint request requires. If passing workspace id to client endpoints use 'wid' instead.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>JSON compatible formatted body.</p>"},{"location":"api-guide/client.html#toggl_api.ClientEndpoint","title":"toggl_api.ClientEndpoint","text":"<p>               Bases: <code>TogglCachedEndpoint[TogglClient]</code></p> <p>Specific endpoints for retrieving and modifying clients.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; wid = 123213324\n&gt;&gt;&gt; client_endpoint = ClientEndpoint(wid, BasicAuth(...), SqliteCache(...))\n&gt;&gt;&gt; client_endpoint.get(214125562)\nTogglClient(214125562, \"Simplicidentata\", workspace=123213324)\n</code></pre> PARAMETER DESCRIPTION <code>workspace_id</code> <p>The workspace the clients belong to.</p> <p> TYPE: <code>int | TogglWorkspace</code> </p> <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>cache</code> <p>Cache object where the clients will stored and handled.</p> <p> TYPE: <code>TogglCache[TogglClient] | None</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>Optional client to be passed to be used for requests. Useful when a global client is used and needs to be recycled.</p> <p> TYPE: <code>Client | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>Timeout | int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>add</code> <p>Create a Client based on parameters set in the provided body.</p> <code>get</code> <p>Request a client based on its id.</p> <code>edit</code> <p>Edit a client with the supplied parameters from the body.</p> <code>delete</code> <p>Delete a client based on its ID.</p> <code>collect</code> <p>Request all Clients based on status and name if specified in the body.</p> Source code in <code>src/toggl_api/_client.py</code> <pre><code>class ClientEndpoint(TogglCachedEndpoint[TogglClient]):\n    \"\"\"Specific endpoints for retrieving and modifying clients.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/clients)\n\n    Examples:\n        &gt;&gt;&gt; wid = 123213324\n        &gt;&gt;&gt; client_endpoint = ClientEndpoint(wid, BasicAuth(...), SqliteCache(...))\n        &gt;&gt;&gt; client_endpoint.get(214125562)\n        TogglClient(214125562, \"Simplicidentata\", workspace=123213324)\n\n    Params:\n        workspace_id: The workspace the clients belong to.\n        auth: Authentication for the client.\n        cache: Cache object where the clients will stored and handled.\n        client: Optional client to be passed to be used for requests. Useful\n            when a global client is used and needs to be recycled.\n        timeout: How long it takes for the client to timeout. Keyword Only.\n            Defaults to 10 seconds.\n        re_raise: Whether to raise all HTTPStatusError errors and not handle them\n            internally. Keyword Only.\n        retries: Max retries to attempt if the server returns a *5xx* status_code.\n            Has no effect if re_raise is `True`. Keyword Only.\n    \"\"\"\n\n    MODEL = TogglClient\n\n    def __init__(\n        self,\n        workspace_id: int | TogglWorkspace,\n        auth: BasicAuth,\n        cache: TogglCache[TogglClient] | None = None,\n        *,\n        client: Client | None = None,\n        timeout: Timeout | int = 10,\n        re_raise: bool = False,\n        retries: int = 3,\n    ) -&gt; None:\n        super().__init__(\n            auth,\n            cache,\n            client=client,\n            timeout=timeout,\n            re_raise=re_raise,\n            retries=retries,\n        )\n        self.workspace_id = workspace_id if isinstance(workspace_id, int) else workspace_id.id\n\n    def add(self, body: ClientBody) -&gt; TogglClient:\n        \"\"\"Create a Client based on parameters set in the provided body.\n\n        This endpoint always hit the external API in order to keep clients consistent.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/clients#post-create-client)\n\n        Args:\n            body: New parameters for the client to be created.\n\n        Raises:\n            NamingError: If no name was set as its required.\n\n        Returns:\n            Newly created client with specified parameters.\n        \"\"\"\n        if body.name is None:\n            msg = \"Name must be set in order to create a client!\"\n            raise NamingError(msg)\n\n        return cast(\n            \"TogglClient\",\n            self.request(\n                self.endpoint,\n                body=body.format(\"add\", wid=self.workspace_id),\n                method=RequestMethod.POST,\n                refresh=True,\n            ),\n        )\n\n    def get(self, client_id: int | TogglClient, *, refresh: bool = False) -&gt; TogglClient | None:\n        \"\"\"Request a client based on its id.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/clients#get-load-client-from-id)\n\n        Args:\n            client_id: Which client to look for.\n            refresh: Whether to only check cache. It will default to True if id\n                is not found in cache. Defaults to False.\n\n        Raises:\n            HTTPStatusError: Any error that is not a 404 code or `re_raise` is True.\n\n        Returns:\n            A TogglClient if the client was found else None.\n        \"\"\"\n        if isinstance(client_id, TogglClient):\n            client_id = client_id.id\n\n        if self.cache and not refresh:\n            return self.cache.find({\"id\": client_id})\n\n        try:\n            response = self.request(\n                f\"{self.endpoint}/{client_id}\",\n                refresh=refresh,\n            )\n        except HTTPStatusError as err:\n            if not self.re_raise and err.response.status_code == codes.NOT_FOUND:\n                log.warning(\"Client with id %s does not exist!\", client_id)\n                return None\n            raise\n\n        return cast(\"TogglClient\", response) or None\n\n    def edit(self, client: TogglClient | int, body: ClientBody) -&gt; TogglClient:\n        \"\"\"Edit a client with the supplied parameters from the body.\n\n        This endpoint always hit the external API in order to keep clients consistent.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/clients#put-change-client)\n\n        Args:\n            client: Target client to edit.\n            body: New parameters to use. Ignore client status.\n\n        Returns:\n            Newly edited client or None if not found.\n        \"\"\"\n        if body.status:\n            log.warning(\"Client status not supported by edit endpoint\")\n            body.status = None\n\n        if isinstance(client, TogglClient):\n            client = client.id\n\n        return cast(\n            \"TogglClient\",\n            self.request(\n                f\"{self.endpoint}/{client}\",\n                body=body.format(\"edit\", wid=self.workspace_id),\n                method=RequestMethod.PUT,\n                refresh=True,\n            ),\n        )\n\n    def delete(self, client: TogglClient | int) -&gt; None:\n        \"\"\"Delete a client based on its ID.\n\n        This endpoint always hit the external API in order to keep clients consistent.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/clients#delete-delete-client)\n\n        Raises:\n            HTTPStatusError: If anything thats not an *ok* or *404* status code\n                is returned.\n        \"\"\"\n        client_id = client if isinstance(client, int) else client.id\n        try:\n            self.request(f\"{self.endpoint}/{client_id}\", method=RequestMethod.DELETE, refresh=True)\n        except HTTPStatusError as err:\n            if self.re_raise or err.response.status_code != codes.NOT_FOUND:\n                raise\n            log.warning(\n                \"Client with id %s was either already deleted or did not exist in the first place!\",\n                client_id,\n            )\n        if self.cache is None:\n            return\n        if isinstance(client, int):\n            clt = self.cache.find({\"id\": client})\n            if not isinstance(clt, TogglClient):\n                return\n            client = clt\n\n        self.cache.delete(client)\n        self.cache.commit()\n\n    def _collect_cache(self, body: ClientBody | None) -&gt; list[TogglClient]:\n        if body and body.status is not None:\n            log.warning(\"Client body 'status' parameter is not implemented with cache!\")\n\n        if body and body.name:\n            return list(self.query(TogglQuery(\"name\", body.name)))\n\n        return list(self.load_cache())\n\n    def collect(\n        self,\n        body: ClientBody | None = None,\n        *,\n        refresh: bool = False,\n    ) -&gt; list[TogglClient]:\n        \"\"\"Request all Clients based on status and name if specified in the body.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/clients#get-list-clients)\n\n        Args:\n            body: Status and name to target. Ignores notes. Ignores status if using cache.\n            refresh: Whether to refresh cache.\n\n        Returns:\n            A list of clients. Empty if not found.\n        \"\"\"\n        if self.cache and not refresh:\n            return self._collect_cache(body)\n\n        url = self.endpoint\n        if body and body.status:\n            url += f\"?{body.status}\"\n        if body and body.name:\n            if body.status:\n                url += \"&amp;\"\n            else:\n                url += \"?\"\n            url += f\"{body.name}\"\n\n        response = self.request(url, method=RequestMethod.GET, refresh=refresh)\n        return response if isinstance(response, list) else []\n\n    @property\n    def endpoint(self) -&gt; str:\n        return f\"workspaces/{self.workspace_id}/clients\"\n</code></pre>"},{"location":"api-guide/client.html#toggl_api.ClientEndpoint.add","title":"add","text":"<pre><code>add(body: ClientBody) -&gt; TogglClient\n</code></pre> <p>Create a Client based on parameters set in the provided body.</p> <p>This endpoint always hit the external API in order to keep clients consistent.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>New parameters for the client to be created.</p> <p> TYPE: <code>ClientBody</code> </p> RAISES DESCRIPTION <code>NamingError</code> <p>If no name was set as its required.</p> RETURNS DESCRIPTION <code>TogglClient</code> <p>Newly created client with specified parameters.</p> Source code in <code>src/toggl_api/_client.py</code> <pre><code>def add(self, body: ClientBody) -&gt; TogglClient:\n    \"\"\"Create a Client based on parameters set in the provided body.\n\n    This endpoint always hit the external API in order to keep clients consistent.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/clients#post-create-client)\n\n    Args:\n        body: New parameters for the client to be created.\n\n    Raises:\n        NamingError: If no name was set as its required.\n\n    Returns:\n        Newly created client with specified parameters.\n    \"\"\"\n    if body.name is None:\n        msg = \"Name must be set in order to create a client!\"\n        raise NamingError(msg)\n\n    return cast(\n        \"TogglClient\",\n        self.request(\n            self.endpoint,\n            body=body.format(\"add\", wid=self.workspace_id),\n            method=RequestMethod.POST,\n            refresh=True,\n        ),\n    )\n</code></pre>"},{"location":"api-guide/client.html#toggl_api.ClientEndpoint.get","title":"get","text":"<pre><code>get(\n    client_id: int | TogglClient, *, refresh: bool = False\n) -&gt; TogglClient | None\n</code></pre> <p>Request a client based on its id.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>client_id</code> <p>Which client to look for.</p> <p> TYPE: <code>int | TogglClient</code> </p> <code>refresh</code> <p>Whether to only check cache. It will default to True if id is not found in cache. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>Any error that is not a 404 code or <code>re_raise</code> is True.</p> RETURNS DESCRIPTION <code>TogglClient | None</code> <p>A TogglClient if the client was found else None.</p> Source code in <code>src/toggl_api/_client.py</code> <pre><code>def get(self, client_id: int | TogglClient, *, refresh: bool = False) -&gt; TogglClient | None:\n    \"\"\"Request a client based on its id.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/clients#get-load-client-from-id)\n\n    Args:\n        client_id: Which client to look for.\n        refresh: Whether to only check cache. It will default to True if id\n            is not found in cache. Defaults to False.\n\n    Raises:\n        HTTPStatusError: Any error that is not a 404 code or `re_raise` is True.\n\n    Returns:\n        A TogglClient if the client was found else None.\n    \"\"\"\n    if isinstance(client_id, TogglClient):\n        client_id = client_id.id\n\n    if self.cache and not refresh:\n        return self.cache.find({\"id\": client_id})\n\n    try:\n        response = self.request(\n            f\"{self.endpoint}/{client_id}\",\n            refresh=refresh,\n        )\n    except HTTPStatusError as err:\n        if not self.re_raise and err.response.status_code == codes.NOT_FOUND:\n            log.warning(\"Client with id %s does not exist!\", client_id)\n            return None\n        raise\n\n    return cast(\"TogglClient\", response) or None\n</code></pre>"},{"location":"api-guide/client.html#toggl_api.ClientEndpoint.edit","title":"edit","text":"<pre><code>edit(client: TogglClient | int, body: ClientBody) -&gt; TogglClient\n</code></pre> <p>Edit a client with the supplied parameters from the body.</p> <p>This endpoint always hit the external API in order to keep clients consistent.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>client</code> <p>Target client to edit.</p> <p> TYPE: <code>TogglClient | int</code> </p> <code>body</code> <p>New parameters to use. Ignore client status.</p> <p> TYPE: <code>ClientBody</code> </p> RETURNS DESCRIPTION <code>TogglClient</code> <p>Newly edited client or None if not found.</p> Source code in <code>src/toggl_api/_client.py</code> <pre><code>def edit(self, client: TogglClient | int, body: ClientBody) -&gt; TogglClient:\n    \"\"\"Edit a client with the supplied parameters from the body.\n\n    This endpoint always hit the external API in order to keep clients consistent.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/clients#put-change-client)\n\n    Args:\n        client: Target client to edit.\n        body: New parameters to use. Ignore client status.\n\n    Returns:\n        Newly edited client or None if not found.\n    \"\"\"\n    if body.status:\n        log.warning(\"Client status not supported by edit endpoint\")\n        body.status = None\n\n    if isinstance(client, TogglClient):\n        client = client.id\n\n    return cast(\n        \"TogglClient\",\n        self.request(\n            f\"{self.endpoint}/{client}\",\n            body=body.format(\"edit\", wid=self.workspace_id),\n            method=RequestMethod.PUT,\n            refresh=True,\n        ),\n    )\n</code></pre>"},{"location":"api-guide/client.html#toggl_api.ClientEndpoint.delete","title":"delete","text":"<pre><code>delete(client: TogglClient | int) -&gt; None\n</code></pre> <p>Delete a client based on its ID.</p> <p>This endpoint always hit the external API in order to keep clients consistent.</p> <p>Official Documentation</p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If anything thats not an ok or 404 status code is returned.</p> Source code in <code>src/toggl_api/_client.py</code> <pre><code>def delete(self, client: TogglClient | int) -&gt; None:\n    \"\"\"Delete a client based on its ID.\n\n    This endpoint always hit the external API in order to keep clients consistent.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/clients#delete-delete-client)\n\n    Raises:\n        HTTPStatusError: If anything thats not an *ok* or *404* status code\n            is returned.\n    \"\"\"\n    client_id = client if isinstance(client, int) else client.id\n    try:\n        self.request(f\"{self.endpoint}/{client_id}\", method=RequestMethod.DELETE, refresh=True)\n    except HTTPStatusError as err:\n        if self.re_raise or err.response.status_code != codes.NOT_FOUND:\n            raise\n        log.warning(\n            \"Client with id %s was either already deleted or did not exist in the first place!\",\n            client_id,\n        )\n    if self.cache is None:\n        return\n    if isinstance(client, int):\n        clt = self.cache.find({\"id\": client})\n        if not isinstance(clt, TogglClient):\n            return\n        client = clt\n\n    self.cache.delete(client)\n    self.cache.commit()\n</code></pre>"},{"location":"api-guide/client.html#toggl_api.ClientEndpoint.collect","title":"collect","text":"<pre><code>collect(\n    body: ClientBody | None = None, *, refresh: bool = False\n) -&gt; list[TogglClient]\n</code></pre> <p>Request all Clients based on status and name if specified in the body.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>Status and name to target. Ignores notes. Ignores status if using cache.</p> <p> TYPE: <code>ClientBody | None</code> DEFAULT: <code>None</code> </p> <code>refresh</code> <p>Whether to refresh cache.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>list[TogglClient]</code> <p>A list of clients. Empty if not found.</p> Source code in <code>src/toggl_api/_client.py</code> <pre><code>def collect(\n    self,\n    body: ClientBody | None = None,\n    *,\n    refresh: bool = False,\n) -&gt; list[TogglClient]:\n    \"\"\"Request all Clients based on status and name if specified in the body.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/clients#get-list-clients)\n\n    Args:\n        body: Status and name to target. Ignores notes. Ignores status if using cache.\n        refresh: Whether to refresh cache.\n\n    Returns:\n        A list of clients. Empty if not found.\n    \"\"\"\n    if self.cache and not refresh:\n        return self._collect_cache(body)\n\n    url = self.endpoint\n    if body and body.status:\n        url += f\"?{body.status}\"\n    if body and body.name:\n        if body.status:\n            url += \"&amp;\"\n        else:\n            url += \"?\"\n        url += f\"{body.name}\"\n\n    response = self.request(url, method=RequestMethod.GET, refresh=refresh)\n    return response if isinstance(response, list) else []\n</code></pre>"},{"location":"api-guide/client.html#toggl_api.asyncio.AsyncClientEndpoint","title":"toggl_api.asyncio.AsyncClientEndpoint","text":"<p>               Bases: <code>TogglAsyncCachedEndpoint[TogglClient]</code></p> <p>Specific endpoints for retrieving and modifying clients.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; wid = 123213324\n&gt;&gt;&gt; client_endpoint = AsyncClientEndpoint(wid, BasicAuth(...), AsyncSqliteCache(...))\n&gt;&gt;&gt; await client_endpoint.get(214125562)\nTogglClient(214125562, \"Simplicidentata\", workspace=123213324)\n</code></pre> PARAMETER DESCRIPTION <code>workspace_id</code> <p>The workspace the clients belong to.</p> <p> TYPE: <code>int | TogglWorkspace</code> </p> <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>cache</code> <p>Cache object where the clients will stored and handled.</p> <p> TYPE: <code>AsyncSqliteCache[TogglClient] | None</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>Optional async client to be passed to be used for requests.</p> <p> TYPE: <code>AsyncClient | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>add</code> <p>Create a Client based on parameters set in the provided body.</p> <code>get</code> <p>Request a client based on its id.</p> <code>edit</code> <p>Edit a client with the supplied parameters from the body.</p> <code>delete</code> <p>Delete a client based on its ID.</p> <code>collect</code> <p>Request all Clients based on status and name if specified in the body.</p>"},{"location":"api-guide/client.html#toggl_api.asyncio.AsyncClientEndpoint.add","title":"add  <code>async</code>","text":"<pre><code>add(body: ClientBody) -&gt; TogglClient\n</code></pre> <p>Create a Client based on parameters set in the provided body.</p> <p>This endpoint always hit the external API in order to keep clients consistent.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>New parameters for the client to be created.</p> <p> TYPE: <code>ClientBody</code> </p> RAISES DESCRIPTION <code>NamingError</code> <p>If no name was set as its required.</p> RETURNS DESCRIPTION <code>TogglClient</code> <p>Newly created client with specified parameters.</p>"},{"location":"api-guide/client.html#toggl_api.asyncio.AsyncClientEndpoint.get","title":"get  <code>async</code>","text":"<pre><code>get(\n    client_id: int | TogglClient, *, refresh: bool = False\n) -&gt; TogglClient | None\n</code></pre> <p>Request a client based on its id.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>client_id</code> <p>Which client to look for.</p> <p> TYPE: <code>int | TogglClient</code> </p> <code>refresh</code> <p>Whether to only check cache. It will default to True if id is not found in cache. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If anything thats not 'ok' or a 404 is returned.</p> RETURNS DESCRIPTION <code>TogglClient | None</code> <p>A TogglClient if the client was found else None.</p>"},{"location":"api-guide/client.html#toggl_api.asyncio.AsyncClientEndpoint.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(client: TogglClient | int, body: ClientBody) -&gt; TogglClient\n</code></pre> <p>Edit a client with the supplied parameters from the body.</p> <p>This endpoint always hit the external API in order to keep clients consistent.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>client</code> <p>Target client to edit.</p> <p> TYPE: <code>TogglClient | int</code> </p> <code>body</code> <p>New parameters to use. Ignore client status.</p> <p> TYPE: <code>ClientBody</code> </p> RETURNS DESCRIPTION <code>TogglClient</code> <p>Newly edited client or None if not found.</p>"},{"location":"api-guide/client.html#toggl_api.asyncio.AsyncClientEndpoint.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(client: TogglClient | int) -&gt; None\n</code></pre> <p>Delete a client based on its ID.</p> <p>This endpoint always hit the external API in order to keep clients consistent.</p> <p>Official Documentation</p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If anything thats not an ok or 404 status code is returned.</p>"},{"location":"api-guide/client.html#toggl_api.asyncio.AsyncClientEndpoint.collect","title":"collect  <code>async</code>","text":"<pre><code>collect(\n    body: ClientBody | None = None, *, refresh: bool = False\n) -&gt; list[TogglClient]\n</code></pre> <p>Request all Clients based on status and name if specified in the body.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>Status and name to target. Ignores notes. Ignores status if using cache.</p> <p> TYPE: <code>ClientBody | None</code> DEFAULT: <code>None</code> </p> <code>refresh</code> <p>Whether to refresh cache.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>list[TogglClient]</code> <p>A list of clients. Empty if not found.</p>"},{"location":"api-guide/config.html","title":"Configuration","text":""},{"location":"api-guide/config.html#authentication","title":"Authentication","text":"<p>Note</p> <p>The UserEndpoint has a verify_authentication method for verifying authentication with the Toggl API.</p>"},{"location":"api-guide/config.html#toggl_api.config.AuthenticationError","title":"toggl_api.config.AuthenticationError","text":"<p>               Bases: <code>ValueError</code></p> <p>Authentication failed or was not provided.</p>"},{"location":"api-guide/config.html#toggl_api.config.generate_authentication","title":"toggl_api.config.generate_authentication","text":"<pre><code>generate_authentication() -&gt; BasicAuth\n</code></pre> <p>Gather credentials from environment variables.</p> <p>If using an API token as authentication: TOGGL_API_TOKEN.</p> <p>If using email as authentication: TOGGL_API_TOKEN &amp; TOGGL_PASSWORD.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generate_authentication()\n&lt;httpx.BasicAuth object at 0x...&gt;\n</code></pre> RAISES DESCRIPTION <code>AuthenticationError</code> <p>If credentials are not set or invalid.</p> RETURNS DESCRIPTION <code>BasicAuth</code> <p>BasicAuth object that is used with HTTPx client.</p>"},{"location":"api-guide/config.html#toggl_api.config.use_togglrc","title":"toggl_api.config.use_togglrc","text":"<pre><code>use_togglrc(config_path: Path | None = None) -&gt; BasicAuth\n</code></pre> <p>Gather credentials from a .togglrc file.</p> <p>Mainly here for togglcli backwards compatibility.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; use_togglrc()\n&lt;httpx.BasicAuth object at 0x...&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; use_togglrc(Path(\"home/dk/.config/\"))\n&lt;httpx.BasicAuth object at 0x...&gt;\n</code></pre> PARAMETER DESCRIPTION <code>config_path</code> <p>Path to .togglrc folder not file. If None, will use $HOME/.togglrc for the default location.</p> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>AuthenticationError</code> <p>If credentials are not set or invalid.</p> RETURNS DESCRIPTION <code>BasicAuth</code> <p>BasicAuth object that is used with HTTPx client.</p>"},{"location":"api-guide/config.html#default-workspace","title":"Default Workspace","text":""},{"location":"api-guide/config.html#toggl_api.config.retrieve_workspace_id","title":"toggl_api.config.retrieve_workspace_id","text":"<pre><code>retrieve_workspace_id(default: int | None = None) -&gt; int\n</code></pre> <p>Collect the default workspace from the environment.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; retrieve_workspace_id()\n</code></pre> <pre><code>&gt;&gt;&gt; retrieve_workspace_id(214812815)\n</code></pre> PARAMETER DESCRIPTION <code>default</code> <p>Workspace id alternative if not set through environment.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>WorkspaceMissingError</code> <p>If no workspace was found at the TOGGL_WORKSPACE_ID variable or the workspace set is not an integer.</p> RETURNS DESCRIPTION <code>int</code> <p>The id of the workspace.</p>"},{"location":"api-guide/config.html#toggl_api.config.retrieve_togglrc_workspace_id","title":"toggl_api.config.retrieve_togglrc_workspace_id","text":"<pre><code>retrieve_togglrc_workspace_id(config_path: Path | None = None) -&gt; int\n</code></pre> <p>Collect the default workspace id from a togglrc file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; retrieve_togglrc_workspace_id()\n</code></pre> PARAMETER DESCRIPTION <code>config_path</code> <p>Alternative path to folder that contains the togglrc file.</p> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If a togglrc file has not been found.</p> <code>WorkspaceMissingError</code> <p>If no workspace is found or the workspace is invalid.</p> RETURNS DESCRIPTION <code>int</code> <p>The id of the workspace.</p>"},{"location":"api-guide/endpoint.html","title":"Endpoint","text":""},{"location":"api-guide/endpoint.html#toggl_api.meta.RequestMethod","title":"toggl_api.meta.RequestMethod","text":"<p>               Bases: <code>Enum</code></p> <p>Describing the different request types primarily for selecting request methods.</p> Source code in <code>src/toggl_api/meta/_enums.py</code> <pre><code>class RequestMethod(enum.Enum):\n    \"\"\"Describing the different request types primarily for selecting request methods.\"\"\"\n\n    GET = enum.auto()\n    POST = enum.auto()\n    PUT = enum.auto()\n    DELETE = enum.auto()\n    PATCH = enum.auto()\n</code></pre>"},{"location":"api-guide/endpoint.html#toggl_api.meta.TogglEndpoint","title":"toggl_api.meta.TogglEndpoint","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Base class with basic functionality for all API requests.</p> ATTRIBUTE DESCRIPTION <code>BASE_ENDPOINT</code> <p>Base URL of the Toggl API.</p> <p> TYPE: <code>str</code> </p> <code>HEADERS</code> <p>Default headers that the API requires for most endpoints.</p> <p> TYPE: <code>Final[Headers]</code> </p> <code>client</code> <p>Httpx client that is used for making requests to the API.</p> <p> </p> PARAMETER DESCRIPTION <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>client</code> <p>Optional client to be passed to be used for requests. Useful when a global client is used and needs to be recycled.</p> <p> TYPE: <code>Client | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>Timeout | int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>request</code> <p>Request &amp; handle data from the Toggl API.</p> <code>process_models</code> <code>api_status</code> <p>Verify that the Toggl API is up.</p> Source code in <code>src/toggl_api/meta/_base_endpoint.py</code> <pre><code>class TogglEndpoint(ABC, Generic[T]):\n    \"\"\"Base class with basic functionality for all API requests.\n\n    Attributes:\n        BASE_ENDPOINT: Base URL of the Toggl API.\n        HEADERS: Default headers that the API requires for most endpoints.\n        client: Httpx client that is used for making requests to the API.\n\n    Params:\n        auth: Authentication for the client.\n        client: Optional client to be passed to be used for requests. Useful\n            when a global client is used and needs to be recycled.\n        timeout: How long it takes for the client to timeout. Keyword Only.\n            Defaults to 10 seconds.\n        re_raise: Whether to raise all HTTPStatusError errors and not handle them\n            internally. Keyword Only.\n        retries: Max retries to attempt if the server returns a *5xx* status_code.\n            Has no effect if re_raise is `True`. Keyword Only.\n    \"\"\"\n\n    BASE_ENDPOINT: ClassVar[str] = \"https://api.track.toggl.com/api/v9/\"\n    HEADERS: Final[Headers] = Headers({\"content-type\": \"application/json\"})\n    MODEL: type[T] | None = None\n\n    __slots__ = (\"client\", \"re_raise\", \"retries\", \"workspace_id\")\n\n    def __init__(\n        self,\n        auth: BasicAuth,\n        *,\n        client: Client | None = None,\n        timeout: Timeout | int = 10,\n        re_raise: bool = False,\n        retries: int = 3,\n    ) -&gt; None:\n        self.re_raise = re_raise\n        self.retries = max(0, retries)\n\n        # NOTE: USES BASE_ENDPOINT instead of endpoint property for base_url\n        # as current httpx concatenation is causing appended slashes.\n        self.client = client = client or Client()\n        client.auth = auth\n        client.base_url = self.BASE_ENDPOINT  # type: ignore[assignment] # NOTE: Setter accepts strings.\n        client.timeout = timeout if isinstance(timeout, Timeout) else Timeout(timeout)\n\n        atexit.register(self.client.close)\n\n    def _request_handle_error(\n        self,\n        response: Response,\n        body: dict[str, Any] | list[dict[str, Any]] | None,\n        headers: Headers | None,\n        method: RequestMethod,\n        parameters: str,\n        *,\n        raw: bool,\n        retries: int,\n    ) -&gt; T | list[T] | Response | None:\n        msg = \"Request failed with status code %s: %s\"\n        log.error(msg, response.status_code, response.text)\n\n        if not self.re_raise and codes.is_server_error(response.status_code) and retries:\n            delay = random.randint(1, 5)\n            retries -= 1\n            log.error(\n                (\"Status code %s is a server error. Retrying request in %s seconds. There are %s retries left.\"),\n                response.status_code,\n                delay,\n                retries,\n            )\n            # NOTE: According to https://engineering.toggl.com/docs/#generic-responses\n            time.sleep(delay)\n            return TogglEndpoint.request(\n                self,\n                parameters,\n                headers,\n                body,\n                method,\n                raw=raw,\n                retries=retries,\n            )\n\n        return response.raise_for_status()\n\n    def _process_response(\n        self,\n        response: Response,\n        *,\n        raw: bool,\n    ) -&gt; T | list[T] | Response | None:\n        try:\n            data = response if raw else response.json()\n        except ValueError:\n            return None\n\n        if self.MODEL is None or raw:\n            return data\n\n        if isinstance(data, list):\n            data = self.process_models(data)\n        elif isinstance(data, dict):\n            data = self.MODEL.from_kwargs(**data)\n\n        return data\n\n    def _build_request(\n        self,\n        parameters: str,\n        headers: Headers | None,\n        body: dict[str, Any] | list[dict[str, Any]] | None,\n        method: RequestMethod,\n    ) -&gt; Request:\n        url = self.BASE_ENDPOINT + parameters\n        headers = headers or self.HEADERS\n\n        requires_body = method not in {RequestMethod.DELETE, RequestMethod.GET}\n        return self.client.build_request(\n            method.name.lower(),\n            url,\n            headers=headers,\n            json=body if requires_body else None,\n        )\n\n    def request(\n        self,\n        parameters: str,\n        headers: Headers | None = None,\n        body: dict[str, Any] | list[dict[str, Any]] | None = None,\n        method: RequestMethod = RequestMethod.GET,\n        *,\n        raw: bool = False,\n        retries: int | None = None,\n    ) -&gt; T | list[T] | Response | None:\n        \"\"\"Request &amp; handle data from the Toggl API.\n\n        Args:\n            parameters (str): Request parameters with the endpoint excluded.\n                Will concate with the endpoint property.\n            headers (dict, optional): Custom request headers. Defaults to\n                class property if set to None.\n            body (dict | list, optional): Request body JSON data for specifying info.\n                Defaults to None. Only used with none-GET or DELETE requests.\n            method (RequestMethod): Request method to select. Defaults to GET.\n            raw (bool): Whether to use the raw data. Defaults to False.\n            retries (int): For recursive calls if the server fails multiple times.\n\n        Raises:\n            HTTPStatusError: If the request is not a success.\n\n        Returns:\n            Response data or None if request does not return any data.\n        \"\"\"\n        if retries is None:\n            retries = self.retries\n\n        request = self._build_request(parameters, headers, body, method)\n        response = self.client.send(request)\n\n        if codes.is_error(response.status_code):\n            return self._request_handle_error(\n                response,\n                body,\n                headers,\n                method,\n                parameters,\n                raw=raw,\n                retries=retries,\n            )\n\n        return self._process_response(response, raw=raw)\n\n    @classmethod\n    def process_models(cls, data: list[dict[str, Any]]) -&gt; list[T]:\n        from_kwargs = cast(\"type[T]\", cls.MODEL).from_kwargs\n        return [from_kwargs(**mdl) for mdl in data]\n\n    @staticmethod\n    def api_status() -&gt; bool:\n        \"\"\"Verify that the Toggl API is up.\n\n        Returns:\n            True if the API is up.\n        \"\"\"\n        try:\n            result = httpx.get(\n                \"https://api.track.toggl.com/api/v9/status\",\n            ).json()\n        except (HTTPStatusError, JSONDecodeError):\n            log.critical(\"Failed to get a response from the Toggl API!\")\n            log.exception(\"%s\")\n            return False\n\n        return bool(result) and result.get(\"status\") == \"OK\"\n</code></pre>"},{"location":"api-guide/endpoint.html#toggl_api.meta.TogglEndpoint.request","title":"request","text":"<pre><code>request(\n    parameters: str,\n    headers: Headers | None = None,\n    body: dict[str, Any] | list[dict[str, Any]] | None = None,\n    method: RequestMethod = GET,\n    *,\n    raw: bool = False,\n    retries: int | None = None,\n) -&gt; T | list[T] | Response | None\n</code></pre> <p>Request &amp; handle data from the Toggl API.</p> PARAMETER DESCRIPTION <code>parameters</code> <p>Request parameters with the endpoint excluded. Will concate with the endpoint property.</p> <p> TYPE: <code>str</code> </p> <code>headers</code> <p>Custom request headers. Defaults to class property if set to None.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>body</code> <p>Request body JSON data for specifying info. Defaults to None. Only used with none-GET or DELETE requests.</p> <p> TYPE: <code>dict | list</code> DEFAULT: <code>None</code> </p> <code>method</code> <p>Request method to select. Defaults to GET.</p> <p> TYPE: <code>RequestMethod</code> DEFAULT: <code>GET</code> </p> <code>raw</code> <p>Whether to use the raw data. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>For recursive calls if the server fails multiple times.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If the request is not a success.</p> RETURNS DESCRIPTION <code>T | list[T] | Response | None</code> <p>Response data or None if request does not return any data.</p> Source code in <code>src/toggl_api/meta/_base_endpoint.py</code> <pre><code>def request(\n    self,\n    parameters: str,\n    headers: Headers | None = None,\n    body: dict[str, Any] | list[dict[str, Any]] | None = None,\n    method: RequestMethod = RequestMethod.GET,\n    *,\n    raw: bool = False,\n    retries: int | None = None,\n) -&gt; T | list[T] | Response | None:\n    \"\"\"Request &amp; handle data from the Toggl API.\n\n    Args:\n        parameters (str): Request parameters with the endpoint excluded.\n            Will concate with the endpoint property.\n        headers (dict, optional): Custom request headers. Defaults to\n            class property if set to None.\n        body (dict | list, optional): Request body JSON data for specifying info.\n            Defaults to None. Only used with none-GET or DELETE requests.\n        method (RequestMethod): Request method to select. Defaults to GET.\n        raw (bool): Whether to use the raw data. Defaults to False.\n        retries (int): For recursive calls if the server fails multiple times.\n\n    Raises:\n        HTTPStatusError: If the request is not a success.\n\n    Returns:\n        Response data or None if request does not return any data.\n    \"\"\"\n    if retries is None:\n        retries = self.retries\n\n    request = self._build_request(parameters, headers, body, method)\n    response = self.client.send(request)\n\n    if codes.is_error(response.status_code):\n        return self._request_handle_error(\n            response,\n            body,\n            headers,\n            method,\n            parameters,\n            raw=raw,\n            retries=retries,\n        )\n\n    return self._process_response(response, raw=raw)\n</code></pre>"},{"location":"api-guide/endpoint.html#toggl_api.meta.TogglEndpoint.process_models","title":"process_models  <code>classmethod</code>","text":"<pre><code>process_models(data: list[dict[str, Any]]) -&gt; list[T]\n</code></pre> Source code in <code>src/toggl_api/meta/_base_endpoint.py</code> <pre><code>@classmethod\ndef process_models(cls, data: list[dict[str, Any]]) -&gt; list[T]:\n    from_kwargs = cast(\"type[T]\", cls.MODEL).from_kwargs\n    return [from_kwargs(**mdl) for mdl in data]\n</code></pre>"},{"location":"api-guide/endpoint.html#toggl_api.meta.TogglEndpoint.api_status","title":"api_status  <code>staticmethod</code>","text":"<pre><code>api_status() -&gt; bool\n</code></pre> <p>Verify that the Toggl API is up.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if the API is up.</p> Source code in <code>src/toggl_api/meta/_base_endpoint.py</code> <pre><code>@staticmethod\ndef api_status() -&gt; bool:\n    \"\"\"Verify that the Toggl API is up.\n\n    Returns:\n        True if the API is up.\n    \"\"\"\n    try:\n        result = httpx.get(\n            \"https://api.track.toggl.com/api/v9/status\",\n        ).json()\n    except (HTTPStatusError, JSONDecodeError):\n        log.critical(\"Failed to get a response from the Toggl API!\")\n        log.exception(\"%s\")\n        return False\n\n    return bool(result) and result.get(\"status\") == \"OK\"\n</code></pre>"},{"location":"api-guide/endpoint.html#toggl_api.asyncio.TogglAsyncEndpoint","title":"toggl_api.asyncio.TogglAsyncEndpoint","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Base class with basic functionality for all async API requests.</p> ATTRIBUTE DESCRIPTION <code>BASE_ENDPOINT</code> <p>Base URL of the Toggl API.</p> <p> TYPE: <code>URL</code> </p> <code>HEADERS</code> <p>Default headers that the API requires for most endpoints.</p> <p> TYPE: <code>Final[Headers]</code> </p> <code>client</code> <p>Async httpx client that is used for making requests to the API.</p> <p> </p> PARAMETER DESCRIPTION <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>client</code> <p>Optional async client to be passed to be used for requests.</p> <p> TYPE: <code>AsyncClient | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>Timeout | int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>api_status</code> <p>Verify that the Toggl API is up.</p>"},{"location":"api-guide/endpoint.html#toggl_api.asyncio.TogglAsyncEndpoint.api_status","title":"api_status  <code>async</code> <code>staticmethod</code>","text":"<pre><code>api_status() -&gt; bool\n</code></pre> <p>Verify that the Toggl API is up.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the API is up.</p>"},{"location":"api-guide/endpoint.html#toggl_api.meta.TogglCachedEndpoint","title":"toggl_api.meta.TogglCachedEndpoint","text":"<p>               Bases: <code>TogglEndpoint[T]</code></p> <p>Abstract cached endpoint for requesting toggl API data to disk.</p> <p>See parent endpoint for more details.</p> PARAMETER DESCRIPTION <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>cache</code> <p>Cache object for caching toggl API data to disk. Builtin cache types are JSONCache and SqliteCache.</p> <p> TYPE: <code>TogglCache[T] | None</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>Optional client to be passed to be used for requests. Useful when a global client is used and needs to be recycled.</p> <p> TYPE: <code>Client | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>Timeout | int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> ATTRIBUTE DESCRIPTION <code>cache</code> <p>Cache object the endpoint will use for storing models. Assigns itself as the parent automatically.</p> <p> TYPE: <code>TogglCache[T] | None</code> </p> METHOD DESCRIPTION <code>request</code> <p>Overriden method that implements the cache into the request chain.</p> <code>load_cache</code> <p>Method for loading cache into memory.</p> <code>save_cache</code> <p>Method for saving cache to disk. Ignored if expiry is set to 0 seconds.</p> <code>query</code> <p>Wrapper method for accessing querying capabilities within the assigned cache.</p> Source code in <code>src/toggl_api/meta/_cached_endpoint.py</code> <pre><code>class TogglCachedEndpoint(TogglEndpoint[T]):\n    \"\"\"Abstract cached endpoint for requesting toggl API data to disk.\n\n    See parent endpoint for more details.\n\n    Params:\n        auth: Authentication for the client.\n        cache: Cache object for caching toggl API data to disk. Builtin cache\n            types are JSONCache and SqliteCache.\n        client: Optional client to be passed to be used for requests. Useful\n            when a global client is used and needs to be recycled.\n        timeout: How long it takes for the client to timeout. Keyword Only.\n            Defaults to 10 seconds.\n        re_raise: Whether to raise all HTTPStatusError errors and not handle them\n            internally. Keyword Only.\n        retries: Max retries to attempt if the server returns a *5xx* status_code.\n            Has no effect if re_raise is `True`. Keyword Only.\n\n    Attributes:\n        cache: Cache object the endpoint will use for storing models. Assigns\n            itself as the parent automatically.\n\n    Methods:\n        request: Overriden method that implements the cache into the request chain.\n        load_cache: Method for loading cache into memory.\n        save_cache: Method for saving cache to disk. Ignored if expiry is set\n            to 0 seconds.\n        query: Wrapper method for accessing querying capabilities within the\n            assigned cache.\n    \"\"\"\n\n    __slots__ = (\"_cache\",)\n\n    def __init__(\n        self,\n        auth: BasicAuth,\n        cache: TogglCache[T] | None = None,\n        *,\n        client: Client | None = None,\n        timeout: Timeout | int = 10,\n        re_raise: bool = False,\n        retries: int = 3,\n    ) -&gt; None:\n        super().__init__(\n            auth=auth,\n            client=client,\n            timeout=timeout,\n            re_raise=re_raise,\n            retries=retries,\n        )\n        self.cache = cache\n\n    def request(  # type: ignore[override]\n        self,\n        parameters: str,\n        headers: Headers | None = None,\n        body: dict[str, Any] | list[Any] | None = None,\n        method: RequestMethod = RequestMethod.GET,\n        *,\n        refresh: bool = False,\n        raw: bool = False,\n    ) -&gt; T | list[T] | Response | None:\n        \"\"\"Overridden request method with builtin cache.\n\n        Args:\n            parameters: Request parameters with the endpoint excluded.\n            headers: Request headers. Custom headers can be added here.\n            body: Request body for GET, POST, PUT, PATCH requests.\n                Defaults to None.\n            method: Request method. Defaults to GET.\n            refresh: Whether to refresh the cache or not. Defaults to False.\n            raw (bool): Whether to use the raw data. Defaults to False.\n\n        Raises:\n            HTTPStatusError: If the request is not a success.\n\n        Returns:\n            Toggl API response data processed into TogglClass objects or not\n                depending on arguments.\n        \"\"\"\n        data = self.load_cache() if self.cache and self.MODEL is not None else None\n        if data and not refresh:\n            log.info(\n                \"Loading request %s%s data from cache.\",\n                self.BASE_ENDPOINT,\n                parameters,\n                extra={\"body\": body, \"headers\": headers, \"method\": method},\n            )\n            return cast(\"list[T]\", data)\n\n        response = super().request(\n            parameters,\n            method=method,\n            headers=headers,\n            body=body,\n            raw=raw,\n        )\n        if raw:\n            return response\n\n        if response is None or method == RequestMethod.DELETE:\n            return None\n\n        if self.cache and self.MODEL is not None:\n            self.save_cache(response, method)  # type: ignore[arg-type]\n\n        return response\n\n    def load_cache(self) -&gt; Iterable[T]:\n        \"\"\"Direct loading method for retrieving all models from cache.\n\n        Raises:\n            NoCacheAssignedError: If no cache is assigned to the endpoint.\n\n        Returns:\n            An iterable of models that have been previously saved.\n        \"\"\"\n        if self.cache is None:\n            raise NoCacheAssignedError\n\n        return self.cache.load()\n\n    def save_cache(\n        self,\n        response: list[T] | T,\n        method: RequestMethod,\n    ) -&gt; None:\n        \"\"\"Direct saving method for retrieving all models from cache.\n\n        Args:\n            response: A list of values or single value to save.\n            method: To method to use when updating the cache.\n\n        Raises:\n            NoCacheAssignedError: If no cache is assigned to the endpoint.\n        \"\"\"\n        if self.cache is None:\n            raise NoCacheAssignedError\n        if isinstance(self.cache.expire_after, timedelta) and not self.cache.expire_after.total_seconds():\n            log.debug(\n                \"Cache is set to immediately expire!\",\n                extra={\"expiry\": self.cache.expire_after},\n            )\n            return None\n        return self.cache.save(response, method)\n\n    def query(\n        self,\n        *query: TogglQuery[Any],\n        distinct: bool = False,\n    ) -&gt; list[T]:\n        \"\"\"Query wrapper for the cache method.\n\n        If the original data structure is required use the query on the\n        *.cache* attribute instead.\n\n        Args:\n            *query: An arbitary amount of queries to match the models to.\n            distinct: A boolean that remove duplicate values if present.\n\n        Raises:\n            NoCacheAssignedError: If the current cache is set to None.\n\n        Returns:\n            A list objects depending on the endpoint.\n        \"\"\"\n        if self.cache is None:\n            raise NoCacheAssignedError\n        return list(self.cache.query(*query, distinct=distinct))\n\n    @property\n    def cache(self) -&gt; TogglCache[T] | None:\n        return self._cache\n\n    @cache.setter\n    def cache(self, value: TogglCache[T] | None) -&gt; None:\n        self._cache = value\n        if self.cache and self.cache._parent is not self:  # noqa: SLF001\n            self.cache.parent = self\n</code></pre>"},{"location":"api-guide/endpoint.html#toggl_api.meta.TogglCachedEndpoint.cache","title":"cache  <code>property</code> <code>writable</code>","text":"<pre><code>cache: TogglCache[T] | None\n</code></pre>"},{"location":"api-guide/endpoint.html#toggl_api.meta.TogglCachedEndpoint.request","title":"request","text":"<pre><code>request(\n    parameters: str,\n    headers: Headers | None = None,\n    body: dict[str, Any] | list[Any] | None = None,\n    method: RequestMethod = GET,\n    *,\n    refresh: bool = False,\n    raw: bool = False,\n) -&gt; T | list[T] | Response | None\n</code></pre> <p>Overridden request method with builtin cache.</p> PARAMETER DESCRIPTION <code>parameters</code> <p>Request parameters with the endpoint excluded.</p> <p> TYPE: <code>str</code> </p> <code>headers</code> <p>Request headers. Custom headers can be added here.</p> <p> TYPE: <code>Headers | None</code> DEFAULT: <code>None</code> </p> <code>body</code> <p>Request body for GET, POST, PUT, PATCH requests. Defaults to None.</p> <p> TYPE: <code>dict[str, Any] | list[Any] | None</code> DEFAULT: <code>None</code> </p> <code>method</code> <p>Request method. Defaults to GET.</p> <p> TYPE: <code>RequestMethod</code> DEFAULT: <code>GET</code> </p> <code>refresh</code> <p>Whether to refresh the cache or not. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>raw</code> <p>Whether to use the raw data. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If the request is not a success.</p> RETURNS DESCRIPTION <code>T | list[T] | Response | None</code> <p>Toggl API response data processed into TogglClass objects or not depending on arguments.</p> Source code in <code>src/toggl_api/meta/_cached_endpoint.py</code> <pre><code>def request(  # type: ignore[override]\n    self,\n    parameters: str,\n    headers: Headers | None = None,\n    body: dict[str, Any] | list[Any] | None = None,\n    method: RequestMethod = RequestMethod.GET,\n    *,\n    refresh: bool = False,\n    raw: bool = False,\n) -&gt; T | list[T] | Response | None:\n    \"\"\"Overridden request method with builtin cache.\n\n    Args:\n        parameters: Request parameters with the endpoint excluded.\n        headers: Request headers. Custom headers can be added here.\n        body: Request body for GET, POST, PUT, PATCH requests.\n            Defaults to None.\n        method: Request method. Defaults to GET.\n        refresh: Whether to refresh the cache or not. Defaults to False.\n        raw (bool): Whether to use the raw data. Defaults to False.\n\n    Raises:\n        HTTPStatusError: If the request is not a success.\n\n    Returns:\n        Toggl API response data processed into TogglClass objects or not\n            depending on arguments.\n    \"\"\"\n    data = self.load_cache() if self.cache and self.MODEL is not None else None\n    if data and not refresh:\n        log.info(\n            \"Loading request %s%s data from cache.\",\n            self.BASE_ENDPOINT,\n            parameters,\n            extra={\"body\": body, \"headers\": headers, \"method\": method},\n        )\n        return cast(\"list[T]\", data)\n\n    response = super().request(\n        parameters,\n        method=method,\n        headers=headers,\n        body=body,\n        raw=raw,\n    )\n    if raw:\n        return response\n\n    if response is None or method == RequestMethod.DELETE:\n        return None\n\n    if self.cache and self.MODEL is not None:\n        self.save_cache(response, method)  # type: ignore[arg-type]\n\n    return response\n</code></pre>"},{"location":"api-guide/endpoint.html#toggl_api.meta.TogglCachedEndpoint.load_cache","title":"load_cache","text":"<pre><code>load_cache() -&gt; Iterable[T]\n</code></pre> <p>Direct loading method for retrieving all models from cache.</p> RAISES DESCRIPTION <code>NoCacheAssignedError</code> <p>If no cache is assigned to the endpoint.</p> RETURNS DESCRIPTION <code>Iterable[T]</code> <p>An iterable of models that have been previously saved.</p> Source code in <code>src/toggl_api/meta/_cached_endpoint.py</code> <pre><code>def load_cache(self) -&gt; Iterable[T]:\n    \"\"\"Direct loading method for retrieving all models from cache.\n\n    Raises:\n        NoCacheAssignedError: If no cache is assigned to the endpoint.\n\n    Returns:\n        An iterable of models that have been previously saved.\n    \"\"\"\n    if self.cache is None:\n        raise NoCacheAssignedError\n\n    return self.cache.load()\n</code></pre>"},{"location":"api-guide/endpoint.html#toggl_api.meta.TogglCachedEndpoint.save_cache","title":"save_cache","text":"<pre><code>save_cache(response: list[T] | T, method: RequestMethod) -&gt; None\n</code></pre> <p>Direct saving method for retrieving all models from cache.</p> PARAMETER DESCRIPTION <code>response</code> <p>A list of values or single value to save.</p> <p> TYPE: <code>list[T] | T</code> </p> <code>method</code> <p>To method to use when updating the cache.</p> <p> TYPE: <code>RequestMethod</code> </p> RAISES DESCRIPTION <code>NoCacheAssignedError</code> <p>If no cache is assigned to the endpoint.</p> Source code in <code>src/toggl_api/meta/_cached_endpoint.py</code> <pre><code>def save_cache(\n    self,\n    response: list[T] | T,\n    method: RequestMethod,\n) -&gt; None:\n    \"\"\"Direct saving method for retrieving all models from cache.\n\n    Args:\n        response: A list of values or single value to save.\n        method: To method to use when updating the cache.\n\n    Raises:\n        NoCacheAssignedError: If no cache is assigned to the endpoint.\n    \"\"\"\n    if self.cache is None:\n        raise NoCacheAssignedError\n    if isinstance(self.cache.expire_after, timedelta) and not self.cache.expire_after.total_seconds():\n        log.debug(\n            \"Cache is set to immediately expire!\",\n            extra={\"expiry\": self.cache.expire_after},\n        )\n        return None\n    return self.cache.save(response, method)\n</code></pre>"},{"location":"api-guide/endpoint.html#toggl_api.meta.TogglCachedEndpoint.query","title":"query","text":"<pre><code>query(*query: TogglQuery[Any], distinct: bool = False) -&gt; list[T]\n</code></pre> <p>Query wrapper for the cache method.</p> <p>If the original data structure is required use the query on the .cache attribute instead.</p> PARAMETER DESCRIPTION <code>*query</code> <p>An arbitary amount of queries to match the models to.</p> <p> TYPE: <code>TogglQuery[Any]</code> DEFAULT: <code>()</code> </p> <code>distinct</code> <p>A boolean that remove duplicate values if present.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>NoCacheAssignedError</code> <p>If the current cache is set to None.</p> RETURNS DESCRIPTION <code>list[T]</code> <p>A list objects depending on the endpoint.</p> Source code in <code>src/toggl_api/meta/_cached_endpoint.py</code> <pre><code>def query(\n    self,\n    *query: TogglQuery[Any],\n    distinct: bool = False,\n) -&gt; list[T]:\n    \"\"\"Query wrapper for the cache method.\n\n    If the original data structure is required use the query on the\n    *.cache* attribute instead.\n\n    Args:\n        *query: An arbitary amount of queries to match the models to.\n        distinct: A boolean that remove duplicate values if present.\n\n    Raises:\n        NoCacheAssignedError: If the current cache is set to None.\n\n    Returns:\n        A list objects depending on the endpoint.\n    \"\"\"\n    if self.cache is None:\n        raise NoCacheAssignedError\n    return list(self.cache.query(*query, distinct=distinct))\n</code></pre>"},{"location":"api-guide/endpoint.html#toggl_api.asyncio.TogglAsyncCachedEndpoint","title":"toggl_api.asyncio.TogglAsyncCachedEndpoint","text":"<p>               Bases: <code>TogglAsyncEndpoint[T]</code></p> <p>Abstract cached endpoint for requesting toggl API data to disk.</p> <p>See parent endpoint for more details.</p> PARAMETER DESCRIPTION <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>cache</code> <p>Cache object for caching toggl API data to disk. AsyncSqlitecache only available for now.</p> <p> TYPE: <code>AsyncSqliteCache[T] | None</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>Optional async client to be passed to be used for requests.</p> <p> TYPE: <code>AsyncClient | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> ATTRIBUTE DESCRIPTION <code>cache</code> <p>Cache object the endpoint will use for storing models. Assigns itself as the parent automatically.</p> <p> TYPE: <code>AsyncSqliteCache[T] | None</code> </p> <code>client</code> <p>Async httpx client that is used for making requests to the API.</p> <p> </p> METHOD DESCRIPTION <code>request</code> <p>Overriden method that implements the cache into the request chain.</p> <code>load_cache</code> <p>Method for loading cache into memory.</p> <code>save_cache</code> <p>Method for saving cache to disk. Ignored if expiry is set to 0 seconds.</p>"},{"location":"api-guide/endpoint.html#toggl_api.asyncio.TogglAsyncCachedEndpoint.request","title":"request  <code>async</code>","text":"<pre><code>request(\n    parameters: str,\n    headers: Headers | None = None,\n    body: dict[str, Any] | list[Any] | None = None,\n    method: RequestMethod = GET,\n    *,\n    refresh: bool = False,\n    raw: bool = False,\n) -&gt; T | list[T] | Response | None\n</code></pre> <p>Overridden request method with builtin cache.</p> PARAMETER DESCRIPTION <code>parameters</code> <p>Request parameters with the endpoint excluded.</p> <p> TYPE: <code>str</code> </p> <code>headers</code> <p>Request headers. Custom headers can be added here.</p> <p> TYPE: <code>Headers | None</code> DEFAULT: <code>None</code> </p> <code>body</code> <p>Request body for GET, POST, PUT, PATCH requests. Defaults to None.</p> <p> TYPE: <code>dict[str, Any] | list[Any] | None</code> DEFAULT: <code>None</code> </p> <code>method</code> <p>Request method. Defaults to GET.</p> <p> TYPE: <code>RequestMethod</code> DEFAULT: <code>GET</code> </p> <code>refresh</code> <p>Whether to refresh the cache or not. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>raw</code> <p>Whether to use the raw data. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If the request is not a success.</p> RETURNS DESCRIPTION <code>T | list[T] | Response | None</code> <p>Toggl API response data processed into TogglClass objects or not depending on arguments.</p>"},{"location":"api-guide/endpoint.html#toggl_api.asyncio.TogglAsyncCachedEndpoint.load_cache","title":"load_cache  <code>async</code>","text":"<pre><code>load_cache() -&gt; Iterable[T]\n</code></pre> <p>Direct loading method for retrieving all models from cache.</p> RAISES DESCRIPTION <code>NoCacheAssignedError</code> <p>If no cache is assigned to the endpoint.</p> RETURNS DESCRIPTION <code>Iterable[T]</code> <p>Previously cached objects.</p>"},{"location":"api-guide/endpoint.html#toggl_api.asyncio.TogglAsyncCachedEndpoint.save_cache","title":"save_cache  <code>async</code>","text":"<pre><code>save_cache(response: list[T] | T, method: RequestMethod) -&gt; None\n</code></pre> <p>Save all provided models to cache.</p> PARAMETER DESCRIPTION <code>response</code> <p>A list of values or single value to save.</p> <p> TYPE: <code>list[T] | T</code> </p> <code>method</code> <p>To method to use when updating the cache.</p> <p> TYPE: <code>RequestMethod</code> </p> RAISES DESCRIPTION <code>NoCacheAssignedError</code> <p>If no cache is assigned to the endpoint.</p>"},{"location":"api-guide/exceptions.html","title":"Exceptions","text":""},{"location":"api-guide/exceptions.html#toggl_api.NamingError","title":"toggl_api.NamingError","text":"<p>               Bases: <code>ValueError</code></p> <p>Description or name is invalid.</p>"},{"location":"api-guide/exceptions.html#toggl_api.DateTimeError","title":"toggl_api.DateTimeError","text":"<p>               Bases: <code>ValueError</code></p> <p>Datetime is invalid or out of range.</p>"},{"location":"api-guide/exceptions.html#toggl_api.NoCacheAssignedError","title":"toggl_api.NoCacheAssignedError","text":"<p>               Bases: <code>AttributeError</code></p> <p>Endpoint doesn't have cache object associated with it and try's to manipulate cache.</p>"},{"location":"api-guide/exceptions.html#toggl_api.MissingParentError","title":"toggl_api.MissingParentError","text":"<p>               Bases: <code>AttributeError</code></p> <p>Cache object doesn't have a parent endpoint associated and is being called used.</p>"},{"location":"api-guide/model.html","title":"Models","text":""},{"location":"api-guide/model.html#abstract-classes","title":"Abstract Classes","text":""},{"location":"api-guide/model.html#toggl_api.models.TogglClass","title":"toggl_api.models.TogglClass  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all Toggl dataclasses.</p> PARAMETER DESCRIPTION <code>id</code> <p>Toggl API / Database ID (Primary Key) of the Toggl model.</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>Name or description of the Toggl project.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Local timestamp of when the Toggl project was last modified.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>partial(now, tz=utc)()</code> </p> METHOD DESCRIPTION <code>from_kwargs</code> <p>Convert an arbitrary amount of kwargs to a model.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@dataclass\nclass TogglClass(ABC):\n    \"\"\"Base class for all Toggl dataclasses.\n\n    Params:\n        id: Toggl API / Database ID (Primary Key) of the Toggl model.\n        name: Name or description of the Toggl project.\n        timestamp: Local timestamp of when the Toggl project was last modified.\n    \"\"\"\n\n    __tablename__ = \"base\"\n    id: int\n    name: str\n    timestamp: datetime = field(\n        compare=False,\n        repr=False,\n        default_factory=partial(\n            datetime.now,\n            tz=timezone.utc,\n        ),\n    )\n\n    def __post_init__(self) -&gt; None:\n        if isinstance(self.timestamp, str):\n            self.timestamp = parse_iso(self.timestamp)\n        elif self.timestamp is None:\n            self.timestamp = datetime.now(tz=timezone.utc)\n\n        self.timestamp = self.timestamp.replace(tzinfo=timezone.utc)\n\n    @classmethod\n    @abstractmethod\n    def from_kwargs(cls, **kwargs: Any) -&gt; Self:\n        \"\"\"Convert an arbitrary amount of kwargs to a model.\n\n        Returns:\n            A newly created `TogglClass`.\n        \"\"\"\n        return cls(\n            id=kwargs[\"id\"],\n            name=kwargs[\"name\"],\n            timestamp=kwargs.get(\"timestamp\") or datetime.now(tz=timezone.utc),\n        )\n\n    def __getitem__(self, item: str) -&gt; Any:\n        return getattr(self, item)\n\n    def __setitem__(self, item: str, value: Any) -&gt; None:\n        setattr(self, item, value)\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.models.TogglClass.from_kwargs","title":"from_kwargs  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_kwargs(**kwargs: Any) -&gt; Self\n</code></pre> <p>Convert an arbitrary amount of kwargs to a model.</p> RETURNS DESCRIPTION <code>Self</code> <p>A newly created <code>TogglClass</code>.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_kwargs(cls, **kwargs: Any) -&gt; Self:\n    \"\"\"Convert an arbitrary amount of kwargs to a model.\n\n    Returns:\n        A newly created `TogglClass`.\n    \"\"\"\n    return cls(\n        id=kwargs[\"id\"],\n        name=kwargs[\"name\"],\n        timestamp=kwargs.get(\"timestamp\") or datetime.now(tz=timezone.utc),\n    )\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.models.WorkspaceChild","title":"toggl_api.models.WorkspaceChild  <code>dataclass</code>","text":"<p>               Bases: <code>TogglClass</code></p> <p>Base class for all Toggl workspace objects.</p> PARAMETER DESCRIPTION <code>id</code> <p>Toggl API / Database ID (Primary Key) of the Toggl object.</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>Name of the object.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Local timestamp of when the Toggl object was last modified.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>partial(now, tz=utc)()</code> </p> <code>workspace</code> <p>The workspace id the Toggl object belongs to.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> METHOD DESCRIPTION <code>from_kwargs</code> <p>Convert an arbitrary amount of kwargs to workspace object.</p> ATTRIBUTE DESCRIPTION <code>workspace</code> <p>The id of the workspace that the model belongs to.</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@dataclass\nclass WorkspaceChild(TogglClass):\n    \"\"\"Base class for all Toggl workspace objects.\n\n    Params:\n        id: Toggl API / Database ID (Primary Key) of the Toggl object.\n        name: Name of the object.\n        timestamp: Local timestamp of when the Toggl object was last modified.\n        workspace: The workspace id the Toggl object belongs to.\n    \"\"\"\n\n    __tablename__ = \"workspace_child\"\n\n    workspace: int = field(default=0)\n    \"\"\"The id of the workspace that the model belongs to.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        super().__post_init__()\n\n    @classmethod\n    def from_kwargs(cls, **kwargs: Any) -&gt; Self:\n        \"\"\"Convert an arbitrary amount of kwargs to workspace object.\n\n        Args:\n            **kwargs: Arbitary values values to convert.\n\n        Returns:\n            An initialized `WorkspaceChild` object.\n        \"\"\"\n        return cls(\n            id=kwargs[\"id\"],\n            name=kwargs[\"name\"],\n            workspace=get_workspace(kwargs),\n            timestamp=kwargs.get(\"timestamp\") or datetime.now(tz=timezone.utc),\n        )\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.models.WorkspaceChild.workspace","title":"workspace  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workspace: int = field(default=0)\n</code></pre> <p>The id of the workspace that the model belongs to.</p>"},{"location":"api-guide/model.html#toggl_api.models.WorkspaceChild.from_kwargs","title":"from_kwargs  <code>classmethod</code>","text":"<pre><code>from_kwargs(**kwargs: Any) -&gt; Self\n</code></pre> <p>Convert an arbitrary amount of kwargs to workspace object.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>Arbitary values values to convert.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>An initialized <code>WorkspaceChild</code> object.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@classmethod\ndef from_kwargs(cls, **kwargs: Any) -&gt; Self:\n    \"\"\"Convert an arbitrary amount of kwargs to workspace object.\n\n    Args:\n        **kwargs: Arbitary values values to convert.\n\n    Returns:\n        An initialized `WorkspaceChild` object.\n    \"\"\"\n    return cls(\n        id=kwargs[\"id\"],\n        name=kwargs[\"name\"],\n        workspace=get_workspace(kwargs),\n        timestamp=kwargs.get(\"timestamp\") or datetime.now(tz=timezone.utc),\n    )\n</code></pre>"},{"location":"api-guide/model.html#main-models","title":"Main Models","text":""},{"location":"api-guide/model.html#toggl_api.TogglOrganization","title":"toggl_api.TogglOrganization  <code>dataclass</code>","text":"<p>               Bases: <code>TogglClass</code></p> <p>Data structure for Toggl organizations.</p> PARAMETER DESCRIPTION <code>id</code> <p>Toggl API / Database ID (Primary Key) of the Toggl organization.</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>Name of the Toggl organization. Max 140 characters and min 1 character.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Local timestamp of when the Toggl organization was last modified.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>partial(now, tz=utc)()</code> </p> METHOD DESCRIPTION <code>validate_name</code> <p>Check if a organization name is valid for the API.</p> <code>from_kwargs</code> <p>Convert an arbitrary amount of kwargs to an organization.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@dataclass\nclass TogglOrganization(TogglClass):\n    \"\"\"Data structure for Toggl organizations.\n\n    Params:\n        id: Toggl API / Database ID (Primary Key) of the Toggl organization.\n        name: Name of the Toggl organization. Max 140 characters and min 1 character.\n        timestamp: Local timestamp of when the Toggl organization was last modified.\n    \"\"\"\n\n    ___tablename__ = \"organization\"\n\n    def __post_init__(self) -&gt; None:\n        self.validate_name(self.name)\n        super().__post_init__()\n\n    @classmethod\n    def from_kwargs(cls, **kwargs: Any) -&gt; Self:\n        \"\"\"Convert an arbitrary amount of kwargs to an organization.\n\n        Returns:\n            A new created `TogglOrganization` object.\n        \"\"\"\n        return super().from_kwargs(**kwargs)\n\n    @staticmethod\n    def validate_name(name: str, *, max_len: int = 140) -&gt; None:\n        \"\"\"Check if a organization name is valid for the API.\n\n        Args:\n            name: The name to check as a string.\n            max_len: Maximum length to allow.\n\n        Raises:\n            NamingError: If the name provided is not valid.\n        \"\"\"\n        if not name:\n            msg = \"The organization name need at least have one letter!\"\n            raise NamingError(msg)\n        if max_len and len(name) &gt; max_len:\n            msg = f\"Max organization name length is {max_len}!\"\n            raise NamingError(msg)\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglOrganization.validate_name","title":"validate_name  <code>staticmethod</code>","text":"<pre><code>validate_name(name: str, *, max_len: int = 140) -&gt; None\n</code></pre> <p>Check if a organization name is valid for the API.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name to check as a string.</p> <p> TYPE: <code>str</code> </p> <code>max_len</code> <p>Maximum length to allow.</p> <p> TYPE: <code>int</code> DEFAULT: <code>140</code> </p> RAISES DESCRIPTION <code>NamingError</code> <p>If the name provided is not valid.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@staticmethod\ndef validate_name(name: str, *, max_len: int = 140) -&gt; None:\n    \"\"\"Check if a organization name is valid for the API.\n\n    Args:\n        name: The name to check as a string.\n        max_len: Maximum length to allow.\n\n    Raises:\n        NamingError: If the name provided is not valid.\n    \"\"\"\n    if not name:\n        msg = \"The organization name need at least have one letter!\"\n        raise NamingError(msg)\n    if max_len and len(name) &gt; max_len:\n        msg = f\"Max organization name length is {max_len}!\"\n        raise NamingError(msg)\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglOrganization.from_kwargs","title":"from_kwargs  <code>classmethod</code>","text":"<pre><code>from_kwargs(**kwargs: Any) -&gt; Self\n</code></pre> <p>Convert an arbitrary amount of kwargs to an organization.</p> RETURNS DESCRIPTION <code>Self</code> <p>A new created <code>TogglOrganization</code> object.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@classmethod\ndef from_kwargs(cls, **kwargs: Any) -&gt; Self:\n    \"\"\"Convert an arbitrary amount of kwargs to an organization.\n\n    Returns:\n        A new created `TogglOrganization` object.\n    \"\"\"\n    return super().from_kwargs(**kwargs)\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglWorkspace","title":"toggl_api.TogglWorkspace  <code>dataclass</code>","text":"<p>               Bases: <code>TogglClass</code></p> <p>Data structure for Toggl workspaces.</p> PARAMETER DESCRIPTION <code>id</code> <p>Toggl API / Database ID (Primary Key) of the Toggl workspace.</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>Name of the workspace.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Local timestamp of when the Toggl workspace was last modified.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>partial(now, tz=utc)()</code> </p> <code>organization</code> <p>Organization id the workspace belongs to.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> METHOD DESCRIPTION <code>validate_name</code> <p>Check if a workspace name is valid for the API.</p> <code>from_kwargs</code> <p>Convert an arbitrary amount of kwargs to a workspace.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@dataclass\nclass TogglWorkspace(TogglClass):\n    \"\"\"Data structure for Toggl workspaces.\n\n    Params:\n        id: Toggl API / Database ID (Primary Key) of the Toggl workspace.\n        name: Name of the workspace.\n        timestamp: Local timestamp of when the Toggl workspace was last modified.\n        organization: Organization id the workspace belongs to.\n    \"\"\"\n\n    ___tablename__ = \"workspace\"\n\n    organization: int = field(default=0)\n\n    def __post_init__(self) -&gt; None:\n        super().__post_init__()\n        try:\n            TogglWorkspace.validate_name(self.name)\n        except NamingError as err:\n            if str(err) != \"No spaces allowed in the workspace name!\":\n                raise\n            log.warning(err)\n            self.name = self.name.replace(\" \", \"-\")\n            log.warning(\"Updated to new name: %s!\", self.name)\n\n    @classmethod\n    def from_kwargs(cls, **kwargs: Any) -&gt; Self:\n        \"\"\"Convert an arbitrary amount of kwargs to a workspace.\n\n        Args:\n            **kwargs: Arbitary values values to convert.\n\n        Returns:\n            An initialized `TogglWorkspace` object.\n        \"\"\"\n        return cls(\n            id=kwargs[\"id\"],\n            name=kwargs[\"name\"],\n            timestamp=kwargs.get(\"timestamp\") or datetime.now(tz=timezone.utc),\n            organization=kwargs.get(\"organization\", 0),\n        )\n\n    @staticmethod\n    def validate_name(name: str, *, max_len: int = 140) -&gt; None:\n        \"\"\"Check if a workspace name is valid for the API.\n\n        Args:\n            name: The name to check as a string.\n            max_len: Maximum length to allow.\n\n        Raises:\n            NamingError: If the name provided is not valid.\n        \"\"\"\n        if not name:\n            msg = \"The workspace name need at least have one character!\"\n            raise NamingError(msg)\n        if max_len and len(name) &gt; max_len:\n            msg = f\"The max workspace name length is {max_len}!\"\n            raise NamingError(msg)\n        if \" \" in name:\n            msg = \"No spaces allowed in the workspace name!\"\n            raise NamingError(msg)\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglWorkspace.validate_name","title":"validate_name  <code>staticmethod</code>","text":"<pre><code>validate_name(name: str, *, max_len: int = 140) -&gt; None\n</code></pre> <p>Check if a workspace name is valid for the API.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name to check as a string.</p> <p> TYPE: <code>str</code> </p> <code>max_len</code> <p>Maximum length to allow.</p> <p> TYPE: <code>int</code> DEFAULT: <code>140</code> </p> RAISES DESCRIPTION <code>NamingError</code> <p>If the name provided is not valid.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@staticmethod\ndef validate_name(name: str, *, max_len: int = 140) -&gt; None:\n    \"\"\"Check if a workspace name is valid for the API.\n\n    Args:\n        name: The name to check as a string.\n        max_len: Maximum length to allow.\n\n    Raises:\n        NamingError: If the name provided is not valid.\n    \"\"\"\n    if not name:\n        msg = \"The workspace name need at least have one character!\"\n        raise NamingError(msg)\n    if max_len and len(name) &gt; max_len:\n        msg = f\"The max workspace name length is {max_len}!\"\n        raise NamingError(msg)\n    if \" \" in name:\n        msg = \"No spaces allowed in the workspace name!\"\n        raise NamingError(msg)\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglWorkspace.from_kwargs","title":"from_kwargs  <code>classmethod</code>","text":"<pre><code>from_kwargs(**kwargs: Any) -&gt; Self\n</code></pre> <p>Convert an arbitrary amount of kwargs to a workspace.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>Arbitary values values to convert.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>An initialized <code>TogglWorkspace</code> object.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@classmethod\ndef from_kwargs(cls, **kwargs: Any) -&gt; Self:\n    \"\"\"Convert an arbitrary amount of kwargs to a workspace.\n\n    Args:\n        **kwargs: Arbitary values values to convert.\n\n    Returns:\n        An initialized `TogglWorkspace` object.\n    \"\"\"\n    return cls(\n        id=kwargs[\"id\"],\n        name=kwargs[\"name\"],\n        timestamp=kwargs.get(\"timestamp\") or datetime.now(tz=timezone.utc),\n        organization=kwargs.get(\"organization\", 0),\n    )\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglClient","title":"toggl_api.TogglClient  <code>dataclass</code>","text":"<p>               Bases: <code>WorkspaceChild</code></p> <p>Data structure for Toggl clients.</p> PARAMETER DESCRIPTION <code>id</code> <p>Toggl API / Database ID (Primary Key) of the Toggl client.</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>Name of the client.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Local timestamp of when the Toggl client was last modified.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>partial(now, tz=utc)()</code> </p> <code>workspace</code> <p>The workspace id the Toggl client belongs to.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> METHOD DESCRIPTION <code>from_kwargs</code> <p>Convert an arbitrary amount of kwargs to a client.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@dataclass\nclass TogglClient(WorkspaceChild):\n    \"\"\"Data structure for Toggl clients.\n\n    Params:\n        id: Toggl API / Database ID (Primary Key) of the Toggl client.\n        name: Name of the client.\n        timestamp: Local timestamp of when the Toggl client was last modified.\n        workspace: The workspace id the Toggl client belongs to.\n    \"\"\"\n\n    __tablename__ = \"client\"\n\n    def __post_init__(self) -&gt; None:\n        super().__post_init__()\n\n    @classmethod\n    def from_kwargs(cls, **kwargs: Any) -&gt; TogglClient:\n        \"\"\"Convert an arbitrary amount of kwargs to a client.\n\n        Args:\n            **kwargs: Arbitary values values to convert.\n\n        Returns:\n            An initialized `TogglClient` object.\n        \"\"\"\n        return super().from_kwargs(**kwargs)\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglClient.from_kwargs","title":"from_kwargs  <code>classmethod</code>","text":"<pre><code>from_kwargs(**kwargs: Any) -&gt; TogglClient\n</code></pre> <p>Convert an arbitrary amount of kwargs to a client.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>Arbitary values values to convert.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>TogglClient</code> <p>An initialized <code>TogglClient</code> object.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@classmethod\ndef from_kwargs(cls, **kwargs: Any) -&gt; TogglClient:\n    \"\"\"Convert an arbitrary amount of kwargs to a client.\n\n    Args:\n        **kwargs: Arbitary values values to convert.\n\n    Returns:\n        An initialized `TogglClient` object.\n    \"\"\"\n    return super().from_kwargs(**kwargs)\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglProject","title":"toggl_api.TogglProject  <code>dataclass</code>","text":"<p>               Bases: <code>WorkspaceChild</code></p> <p>Data structure for Toggl projects.</p> ATTRIBUTE DESCRIPTION <code>Status</code> <p>An enumeration with all project statuses supported by the API.</p> <p> </p> PARAMETER DESCRIPTION <code>id</code> <p>Toggl API / Database ID (Primary Key) of the Toggl project.</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>Name of the project.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Local timestamp of when the Toggl project was last modified.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>partial(now, tz=utc)()</code> </p> <code>workspace</code> <p>The workspace id the project belongs to.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>color</code> <p>Color of the project. Defaults to blue. Refer to this endpoint attribute for basic colors.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'#0b83d9'</code> </p> <code>client</code> <p>ID of the client the project belongs to. Defaults to None.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>active</code> <p>Whether the project is archived or not. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>start_date</code> <p>When the project is supposed to start. Will default to the original date.</p> <p> TYPE: <code>date</code> DEFAULT: <code>lambda: date()()</code> </p> <code>end_date</code> <p>When the projects is supposed to end. None if there is no deadline. Optional.</p> <p> TYPE: <code>date | None</code> DEFAULT: <code>None</code> </p> CLASS DESCRIPTION <code>Status</code> METHOD DESCRIPTION <code>get_status</code> <p>Derive the project status from instance attributes.</p> <code>from_kwargs</code> <p>Convert an arbitrary amount of kwargs to a project.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@dataclass\nclass TogglProject(WorkspaceChild):\n    \"\"\"Data structure for Toggl projects.\n\n    Attributes:\n        Status: An enumeration with all project statuses supported by the API.\n\n    Params:\n        id: Toggl API / Database ID (Primary Key) of the Toggl project.\n        name: Name of the project.\n        timestamp: Local timestamp of when the Toggl project was last modified.\n        workspace: The workspace id the project belongs to.\n        color: Color of the project. Defaults to blue. Refer to this endpoint\n            [attribute][toggl_api.ProjectEndpoint.BASIC_COLORS] for basic colors.\n        client: ID of the client the project belongs to. Defaults to None.\n        active: Whether the project is archived or not. Defaults to True.\n        start_date: When the project is supposed to start. Will default to\n            the original date.\n        end_date: When the projects is supposed to end. None if there is no\n            deadline. Optional.\n    \"\"\"\n\n    class Status(enum.Enum):\n        UPCOMING = enum.auto()\n        ACTIVE = enum.auto()\n        ENDED = enum.auto()\n        ARCHIVED = enum.auto()\n        DELETED = enum.auto()\n\n    __tablename__ = \"project\"\n\n    color: str = field(default=\"#0b83d9\")\n    client: int | None = field(default=None)\n    active: bool = field(default=True)\n\n    start_date: date = field(\n        default_factory=lambda: datetime.now(tz=timezone.utc).date(),\n    )\n    end_date: date | None = field(default=None)\n\n    def __post_init__(self) -&gt; None:\n        super().__post_init__()\n        if isinstance(self.client, TogglClient):\n            self.client = self.client.id\n\n        if isinstance(self.start_date, str):\n            self.start_date = parse_iso(self.start_date).date()\n\n        if isinstance(self.end_date, str):\n            self.stop_date = parse_iso(self.end_date).date()\n\n    @classmethod\n    def from_kwargs(cls, **kwargs: Any) -&gt; TogglProject:\n        \"\"\"Convert an arbitrary amount of kwargs to a project.\n\n        Args:\n            **kwargs: Arbitary values values to convert.\n\n        Returns:\n            An initialized `TogglProject` object.\n        \"\"\"\n        return cls(\n            id=kwargs[\"id\"],\n            name=kwargs[\"name\"],\n            workspace=get_workspace(kwargs),\n            color=kwargs[\"color\"],\n            client=kwargs.get(\"client_id\") or kwargs.get(\"client\"),\n            active=kwargs[\"active\"],\n            timestamp=kwargs.get(\"timestamp\") or datetime.now(tz=timezone.utc),\n            start_date=kwargs.get(\"start_date\") or datetime.now(tz=timezone.utc).date(),\n            end_date=kwargs.get(\"end_date\"),\n        )\n\n    def get_status(self) -&gt; TogglProject.Status:\n        \"\"\"Derive the project status from instance attributes.\n\n        Returns:\n            A status enumeration based on the project attributes.\n        \"\"\"\n        if not self.active:\n            return TogglProject.Status.ARCHIVED\n        now = datetime.now(timezone.utc)\n        if now &lt; self.start_date:\n            return TogglProject.Status.UPCOMING\n        if self.end_date and now &gt;= self.end_date:\n            return TogglProject.Status.ENDED\n        return TogglProject.Status.ACTIVE\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglProject.Status","title":"Status","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>class Status(enum.Enum):\n    UPCOMING = enum.auto()\n    ACTIVE = enum.auto()\n    ENDED = enum.auto()\n    ARCHIVED = enum.auto()\n    DELETED = enum.auto()\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglProject.get_status","title":"get_status","text":"<pre><code>get_status() -&gt; Status\n</code></pre> <p>Derive the project status from instance attributes.</p> RETURNS DESCRIPTION <code>Status</code> <p>A status enumeration based on the project attributes.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>def get_status(self) -&gt; TogglProject.Status:\n    \"\"\"Derive the project status from instance attributes.\n\n    Returns:\n        A status enumeration based on the project attributes.\n    \"\"\"\n    if not self.active:\n        return TogglProject.Status.ARCHIVED\n    now = datetime.now(timezone.utc)\n    if now &lt; self.start_date:\n        return TogglProject.Status.UPCOMING\n    if self.end_date and now &gt;= self.end_date:\n        return TogglProject.Status.ENDED\n    return TogglProject.Status.ACTIVE\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglProject.from_kwargs","title":"from_kwargs  <code>classmethod</code>","text":"<pre><code>from_kwargs(**kwargs: Any) -&gt; TogglProject\n</code></pre> <p>Convert an arbitrary amount of kwargs to a project.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>Arbitary values values to convert.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>TogglProject</code> <p>An initialized <code>TogglProject</code> object.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@classmethod\ndef from_kwargs(cls, **kwargs: Any) -&gt; TogglProject:\n    \"\"\"Convert an arbitrary amount of kwargs to a project.\n\n    Args:\n        **kwargs: Arbitary values values to convert.\n\n    Returns:\n        An initialized `TogglProject` object.\n    \"\"\"\n    return cls(\n        id=kwargs[\"id\"],\n        name=kwargs[\"name\"],\n        workspace=get_workspace(kwargs),\n        color=kwargs[\"color\"],\n        client=kwargs.get(\"client_id\") or kwargs.get(\"client\"),\n        active=kwargs[\"active\"],\n        timestamp=kwargs.get(\"timestamp\") or datetime.now(tz=timezone.utc),\n        start_date=kwargs.get(\"start_date\") or datetime.now(tz=timezone.utc).date(),\n        end_date=kwargs.get(\"end_date\"),\n    )\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglTracker","title":"toggl_api.TogglTracker  <code>dataclass</code>","text":"<p>               Bases: <code>WorkspaceChild</code></p> <p>Data structure for trackers.</p> PARAMETER DESCRIPTION <code>id</code> <p>Toggl API / Database ID (Primary Key) of the Toggl tracker.</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>Description of the tracker. Refers to tracker description inside the Toggl API.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Local timestamp of when the Toggl tracker was last modified.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>partial(now, tz=utc)()</code> </p> <code>workspace</code> <p>The workspace id the tracker belongs to.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>start</code> <p>Start time of the tracker. Defaults to time created if nothing is passed.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>partial(now, tz=utc)()</code> </p> <code>duration</code> <p>Duration of the tracker</p> <p> TYPE: <code>timedelta | None</code> DEFAULT: <code>None</code> </p> <code>stop</code> <p>Stop time of the tracker.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>project</code> <p>Id of the project the tracker is assigned to.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>tags</code> <p>List of tags.</p> <p> TYPE: <code>list[TogglTag]</code> DEFAULT: <code>list()</code> </p> METHOD DESCRIPTION <code>running</code> <p>Whether the tracker is running.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@dataclass\nclass TogglTracker(WorkspaceChild):\n    \"\"\"Data structure for trackers.\n\n    Params:\n        id: Toggl API / Database ID (Primary Key) of the Toggl tracker.\n        name: Description of the tracker. Refers to tracker **description**\n            inside the Toggl API.\n        timestamp: Local timestamp of when the Toggl tracker was last modified.\n        workspace: The workspace id the tracker belongs to.\n        start: Start time of the tracker. Defaults to time created if nothing\n            is passed.\n        duration: Duration of the tracker\n        stop: Stop time of the tracker.\n        project: Id of the project the tracker is assigned to.\n        tags: List of tags.\n\n    Methods:\n        running: Whether the tracker is running.\n    \"\"\"\n\n    __tablename__ = \"tracker\"\n\n    start: datetime = field(\n        default_factory=partial(\n            datetime.now,\n            tz=timezone.utc,\n        ),\n    )\n    duration: timedelta | None = field(default=None)\n    stop: datetime | None = field(default=None)\n    project: int | None = field(default=None)\n    tags: list[TogglTag] = field(default_factory=list)\n\n    def __post_init__(self) -&gt; None:\n        super().__post_init__()\n        if isinstance(self.project, TogglProject):\n            self.project = self.project.id\n        if isinstance(self.start, str | datetime):\n            self.start = parse_iso(self.start)  # type: ignore[assignment]\n        if isinstance(self.duration, float | int):\n            self.duration = timedelta(seconds=self.duration)\n\n        if isinstance(self.stop, str | datetime):\n            self.stop = parse_iso(self.stop)  # type: ignore[assignment]\n\n    def running(self) -&gt; bool:\n        \"\"\"Is the tracker running.\n\n        Returns:\n            True if the tracker is running.\n        \"\"\"\n        return self.stop is None\n\n    @classmethod\n    def from_kwargs(cls, **kwargs: Any) -&gt; Self:\n        \"\"\"Convert an arbitrary amount of kwargs to a tracker.\n\n        Args:\n            **kwargs: Arbitary values values to convert.\n\n        Returns:\n            An initialized `TogglTracker` object.\n        \"\"\"\n        start = kwargs.get(\"start\")\n        if start is None:\n            start = datetime.now(tz=timezone.utc)\n            log.info(\n                \"No start time provided. Using current time as start time: %s\",\n                start,\n            )\n\n        return cls(\n            id=kwargs[\"id\"],\n            name=kwargs.get(\"description\", kwargs.get(\"name\", \"\")),\n            workspace=get_workspace(kwargs),\n            start=start,\n            duration=kwargs.get(\"duration\"),\n            stop=kwargs.get(\"stop\"),\n            project=kwargs.get(\"project_id\", kwargs.get(\"project\")),\n            tags=TogglTracker.get_tags(**kwargs),\n            timestamp=kwargs.get(\"timestamp\", datetime.now(tz=timezone.utc)),\n        )\n\n    @staticmethod\n    def get_tags(**kwargs: Any) -&gt; list[TogglTag]:\n        tag_id = kwargs.get(\"tag_ids\")\n        tag = kwargs.get(\"tags\")\n        tags = []\n        if tag and isinstance(tag[0], dict):\n            for t in tag:\n                tags.append(TogglTag.from_kwargs(**t))  # noqa: PERF401\n        elif tag_id and tag:\n            workspace = get_workspace(kwargs)\n            for i, t in zip(tag_id, tag, strict=True):\n                tags.append(TogglTag(id=i, name=t, workspace=workspace))\n        else:\n            tags = tag or tags\n\n        return tags\n\n    @property\n    def description(self) -&gt; str:\n        \"\"\"Alias for the name of the tracker.\n\n        Returns:\n            Description of the tracker.\n        \"\"\"\n        return self.name\n\n    @property\n    def running_duration(self) -&gt; timedelta:\n        \"\"\"Duration that gets calculated even if the tracker is running.\"\"\"\n        return self.duration or (datetime.now(tz=timezone.utc) - self.start)\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglTracker.running","title":"running","text":"<pre><code>running() -&gt; bool\n</code></pre> <p>Is the tracker running.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if the tracker is running.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>def running(self) -&gt; bool:\n    \"\"\"Is the tracker running.\n\n    Returns:\n        True if the tracker is running.\n    \"\"\"\n    return self.stop is None\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglTracker.from_kwargs","title":"from_kwargs  <code>classmethod</code>","text":"<pre><code>from_kwargs(**kwargs: Any) -&gt; Self\n</code></pre> <p>Convert an arbitrary amount of kwargs to a tracker.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>Arbitary values values to convert.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>An initialized <code>TogglTracker</code> object.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@classmethod\ndef from_kwargs(cls, **kwargs: Any) -&gt; Self:\n    \"\"\"Convert an arbitrary amount of kwargs to a tracker.\n\n    Args:\n        **kwargs: Arbitary values values to convert.\n\n    Returns:\n        An initialized `TogglTracker` object.\n    \"\"\"\n    start = kwargs.get(\"start\")\n    if start is None:\n        start = datetime.now(tz=timezone.utc)\n        log.info(\n            \"No start time provided. Using current time as start time: %s\",\n            start,\n        )\n\n    return cls(\n        id=kwargs[\"id\"],\n        name=kwargs.get(\"description\", kwargs.get(\"name\", \"\")),\n        workspace=get_workspace(kwargs),\n        start=start,\n        duration=kwargs.get(\"duration\"),\n        stop=kwargs.get(\"stop\"),\n        project=kwargs.get(\"project_id\", kwargs.get(\"project\")),\n        tags=TogglTracker.get_tags(**kwargs),\n        timestamp=kwargs.get(\"timestamp\", datetime.now(tz=timezone.utc)),\n    )\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglTag","title":"toggl_api.TogglTag  <code>dataclass</code>","text":"<p>               Bases: <code>WorkspaceChild</code></p> <p>Data structure for Toggl tags.</p> PARAMETER DESCRIPTION <code>id</code> <p>Toggl API / Database ID (Primary Key) of the Toggl tag.</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>Name of the tag.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Local timestamp of when the Toggl tag was last modified.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>partial(now, tz=utc)()</code> </p> <code>workspace</code> <p>The workspace id the tag belongs to.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> METHOD DESCRIPTION <code>from_kwargs</code> <p>Convert an arbitrary amount of kwargs to a tag.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@dataclass\nclass TogglTag(WorkspaceChild):\n    \"\"\"Data structure for Toggl tags.\n\n    Params:\n        id: Toggl API / Database ID (Primary Key) of the Toggl tag.\n        name: Name of the tag.\n        timestamp: Local timestamp of when the Toggl tag was last modified.\n        workspace: The workspace id the tag belongs to.\n    \"\"\"\n\n    __tablename__ = \"tag\"\n\n    def __post_init__(self) -&gt; None:\n        super().__post_init__()\n\n    @classmethod\n    def from_kwargs(cls, **kwargs: Any) -&gt; TogglTag:\n        \"\"\"Convert an arbitrary amount of kwargs to a tag.\n\n        Args:\n            **kwargs: Arbitary values values to convert.\n\n        Returns:\n            An initialized `TogglTag` object.\n        \"\"\"\n        return super().from_kwargs(**kwargs)\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.TogglTag.from_kwargs","title":"from_kwargs  <code>classmethod</code>","text":"<pre><code>from_kwargs(**kwargs: Any) -&gt; TogglTag\n</code></pre> <p>Convert an arbitrary amount of kwargs to a tag.</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p>Arbitary values values to convert.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>TogglTag</code> <p>An initialized <code>TogglTag</code> object.</p> Source code in <code>src/toggl_api/models/_models.py</code> <pre><code>@classmethod\ndef from_kwargs(cls, **kwargs: Any) -&gt; TogglTag:\n    \"\"\"Convert an arbitrary amount of kwargs to a tag.\n\n    Args:\n        **kwargs: Arbitary values values to convert.\n\n    Returns:\n        An initialized `TogglTag` object.\n    \"\"\"\n    return super().from_kwargs(**kwargs)\n</code></pre>"},{"location":"api-guide/model.html#toggl_api.models.as_dict_custom","title":"toggl_api.models.as_dict_custom","text":"<pre><code>as_dict_custom(obj: TogglClass) -&gt; dict[str, Any]\n</code></pre> <p>Convert a TogglClass` to a dictionary.</p> PARAMETER DESCRIPTION <code>obj</code> <p>A <code>ToggClass</code> instance.</p> <p> TYPE: <code>TogglClass</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p><code>TogglClass</code> converted to a dictionary.</p> Source code in <code>src/toggl_api/models/__init__.py</code> <pre><code>def as_dict_custom(obj: TogglClass) -&gt; dict[str, Any]:\n    \"\"\"Convert a TogglClass` to a dictionary.\n\n    Args:\n        obj: A `ToggClass` instance.\n\n    Returns:\n        `TogglClass` converted to a dictionary.\n    \"\"\"\n    data: dict[str, Any] = {\"class\": obj.__tablename__}\n\n    for field in fields(obj):\n        field_data = getattr(obj, field.name)\n\n        if isinstance(field_data, TogglClass):\n            data[field.name] = as_dict_custom(field_data)\n        elif isinstance(field_data, list):\n            data[field.name] = [as_dict_custom(item) for item in field_data]\n        else:\n            data[field.name] = field_data\n\n    return data\n</code></pre>"},{"location":"api-guide/organization.html","title":"Organization","text":""},{"location":"api-guide/organization.html#toggl_api.OrganizationEndpoint","title":"toggl_api.OrganizationEndpoint","text":"<p>               Bases: <code>TogglCachedEndpoint[TogglOrganization]</code></p> <p>Endpoint to do with handling organization specific details.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; org_endpoint = OrganizationEndpoint(BasicAuth(...), SqliteCache(...))\n</code></pre> PARAMETER DESCRIPTION <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>cache</code> <p>Cache object where the organization models are stored.</p> <p> TYPE: <code>TogglCache[TogglOrganization] | None</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>Optional client to be passed to be used for requests. Useful when a global client is used and needs to be recycled.</p> <p> TYPE: <code>Client | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>Timeout | int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>get</code> <p>Create a new organization with a single workspace and assigns</p> <code>add</code> <p>Create a new organization with a single workspace.</p> <code>edit</code> <p>Update an existing organization.</p> <code>collect</code> <p>Get all organizations a given user is part of.</p> <code>delete</code> <p>Leave organization effectively deleting user account in org.</p> Source code in <code>src/toggl_api/_organization.py</code> <pre><code>class OrganizationEndpoint(TogglCachedEndpoint[TogglOrganization]):\n    \"\"\"Endpoint to do with handling organization specific details.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/organizations)\n\n    Examples:\n        &gt;&gt;&gt; org_endpoint = OrganizationEndpoint(BasicAuth(...), SqliteCache(...))\n\n    Params:\n        auth: Authentication for the client.\n        cache: Cache object where the organization models are stored.\n        client: Optional client to be passed to be used for requests. Useful\n            when a global client is used and needs to be recycled.\n        timeout: How long it takes for the client to timeout. Keyword Only.\n            Defaults to 10 seconds.\n        re_raise: Whether to raise HTTPStatusError errors and not handle them\n            internally. Keyword Only.\n        retries: Max retries to attempt if the server returns a *5xx* status_code.\n            Has no effect if re_raise is `True`. Keyword Only.\n    \"\"\"\n\n    MODEL = TogglOrganization\n\n    def __init__(\n        self,\n        auth: BasicAuth,\n        cache: TogglCache[TogglOrganization] | None = None,\n        *,\n        client: Client | None = None,\n        timeout: Timeout | int = 10,\n        re_raise: bool = False,\n        retries: int = 3,\n    ) -&gt; None:\n        super().__init__(\n            auth,\n            cache,\n            client=client,\n            timeout=timeout,\n            re_raise=re_raise,\n            retries=retries,\n        )\n\n    def get(\n        self,\n        organization: TogglOrganization | int,\n        *,\n        refresh: bool = False,\n    ) -&gt; TogglOrganization | None:\n        \"\"\"Create a new organization with a single workspace and assigns\n        current user as the organization owner.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/organizations#get-organization-data)\n\n        Args:\n            organization: Organization to retrieve.\n            refresh: Whether to ignore cache completely.\n\n        Raises:\n            HTTPStatusError: If any error except a '404' was received.\n\n        Returns:\n            Organization object that was retrieve or None if not found.\n        \"\"\"  # noqa: D205\n        if isinstance(organization, TogglOrganization):\n            organization = organization.id\n\n        if self.cache and not refresh:\n            return self.cache.find({\"id\": organization})\n\n        try:\n            response = self.request(\n                f\"organizations/{organization}\",\n                refresh=refresh,\n            )\n        except HTTPStatusError as err:\n            if not self.re_raise and err.response.status_code in {\n                codes.NOT_FOUND,\n                codes.FORBIDDEN,\n            }:\n                log.warning(err)\n                return None\n            raise\n\n        return cast(\"TogglOrganization\", response)\n\n    def add(\n        self,\n        name: str,\n        workspace_name: str = \"Default-Workspace\",\n    ) -&gt; TogglOrganization:\n        \"\"\"Create a new organization with a single workspace.\n\n        Assigns current user as the organization owner.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/organizations#post-creates-a-new-organization)\n\n        Examples:\n            &gt;&gt;&gt; org = organization_endpoint.add(\"New-Workspace\")\n            &gt;&gt;&gt; org.name\n            \"New-Workspace\"\n\n        Args:\n            name: Name of the new orgnization.\n            workspace_name: Name of the default workspace in the organization.\n                No space characters allowed.\n\n        Raises:\n            NamingError: If any of the names are invalid or the wrong length.\n            HTTPStatusError: If the request is not a success.\n\n        Returns:\n            The newly created organization.\n        \"\"\"\n        TogglOrganization.validate_name(name)\n        TogglWorkspace.validate_name(workspace_name)\n\n        return cast(\n            \"TogglOrganization\",\n            self.request(\n                \"organizations\",\n                body={\"name\": name, \"workspace_name\": workspace_name},\n                method=RequestMethod.POST,\n                refresh=True,\n            ),\n        )\n\n    def edit(\n        self,\n        organization: TogglOrganization | int,\n        name: str,\n    ) -&gt; TogglOrganization:\n        \"\"\"Update an existing organization.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/organizations#put-updates-an-existing-organization)\n\n        Args:\n            organization: The id of the organization to edit.\n            name: What name to change the org to.\n\n        Raises:\n            NamingError: If the new name is invalid.\n            HTTPStatusError: If the request is not a success.\n\n        Returns:\n            The newly edited organization.\n        \"\"\"\n        TogglOrganization.validate_name(name)\n\n        if isinstance(organization, TogglOrganization):\n            organization = organization.id\n\n        self.request(\n            f\"organizations/{organization}\",\n            body={\"name\": name},\n            refresh=True,\n            method=RequestMethod.PUT,\n        )\n\n        edit = TogglOrganization(organization, name)\n        if self.cache:\n            self.cache.update(edit)\n            self.cache.commit()\n\n        return edit\n\n    def collect(self, *, refresh: bool = False) -&gt; list[TogglOrganization]:\n        \"\"\"Get all organizations a given user is part of.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/me#get-organizations-that-a-user-is-part-of)\n\n        Args:\n            refresh: Whether to use cache or not.\n\n        Raises:\n            HTTPStatusError: If the request is not a success.\n\n        Returns:\n            A list of organization objects or empty if none found.\n        \"\"\"\n        return cast(\n            \"list[TogglOrganization]\",\n            self.request(\"me/organizations\", refresh=refresh),\n        )\n\n    def delete(self, organization: TogglOrganization | int) -&gt; None:\n        \"\"\"Leave organization effectively deleting user account in org.\n\n        Deletes organization if it is last user.\n\n        Deletion might not be instant on the API end and might take a few\n        seconds to propogate, so the object might appear in the 'get' or\n        'collect' method.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/organizations#delete-leaves-organization)\n\n        Args:\n            organization: Organization to delete.\n\n        Raises:\n            HTTPStatusError: If the response status_code is not '200' or '404'.\n        \"\"\"\n        org_id = organization if isinstance(organization, int) else organization.id\n        try:\n            self.request(\n                f\"organizations/{org_id}/users/leave\",\n                method=RequestMethod.DELETE,\n                refresh=True,\n            )\n        except HTTPStatusError as err:\n            if self.re_raise or err.response.status_code != codes.NOT_FOUND:\n                raise\n            log.exception(\"%s\")\n            log.warning(\n                \"Organization with id %s was either already deleted or did not exist in the first place!\",\n                org_id,\n            )\n        if self.cache is None:\n            return\n\n        if isinstance(organization, int):\n            org = self.cache.find({\"id\": organization})\n            if not isinstance(org, TogglOrganization):\n                return\n            organization = org\n\n        self.cache.delete(organization)\n        self.cache.commit()\n\n    @property\n    def endpoint(self) -&gt; str:\n        return \"\"\n</code></pre>"},{"location":"api-guide/organization.html#toggl_api.OrganizationEndpoint.get","title":"get","text":"<pre><code>get(\n    organization: TogglOrganization | int, *, refresh: bool = False\n) -&gt; TogglOrganization | None\n</code></pre> <p>Create a new organization with a single workspace and assigns current user as the organization owner.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>organization</code> <p>Organization to retrieve.</p> <p> TYPE: <code>TogglOrganization | int</code> </p> <code>refresh</code> <p>Whether to ignore cache completely.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If any error except a '404' was received.</p> RETURNS DESCRIPTION <code>TogglOrganization | None</code> <p>Organization object that was retrieve or None if not found.</p> Source code in <code>src/toggl_api/_organization.py</code> <pre><code>def get(\n    self,\n    organization: TogglOrganization | int,\n    *,\n    refresh: bool = False,\n) -&gt; TogglOrganization | None:\n    \"\"\"Create a new organization with a single workspace and assigns\n    current user as the organization owner.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/organizations#get-organization-data)\n\n    Args:\n        organization: Organization to retrieve.\n        refresh: Whether to ignore cache completely.\n\n    Raises:\n        HTTPStatusError: If any error except a '404' was received.\n\n    Returns:\n        Organization object that was retrieve or None if not found.\n    \"\"\"  # noqa: D205\n    if isinstance(organization, TogglOrganization):\n        organization = organization.id\n\n    if self.cache and not refresh:\n        return self.cache.find({\"id\": organization})\n\n    try:\n        response = self.request(\n            f\"organizations/{organization}\",\n            refresh=refresh,\n        )\n    except HTTPStatusError as err:\n        if not self.re_raise and err.response.status_code in {\n            codes.NOT_FOUND,\n            codes.FORBIDDEN,\n        }:\n            log.warning(err)\n            return None\n        raise\n\n    return cast(\"TogglOrganization\", response)\n</code></pre>"},{"location":"api-guide/organization.html#toggl_api.OrganizationEndpoint.add","title":"add","text":"<pre><code>add(name: str, workspace_name: str = 'Default-Workspace') -&gt; TogglOrganization\n</code></pre> <p>Create a new organization with a single workspace.</p> <p>Assigns current user as the organization owner.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; org = organization_endpoint.add(\"New-Workspace\")\n&gt;&gt;&gt; org.name\n\"New-Workspace\"\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>Name of the new orgnization.</p> <p> TYPE: <code>str</code> </p> <code>workspace_name</code> <p>Name of the default workspace in the organization. No space characters allowed.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Default-Workspace'</code> </p> RAISES DESCRIPTION <code>NamingError</code> <p>If any of the names are invalid or the wrong length.</p> <code>HTTPStatusError</code> <p>If the request is not a success.</p> RETURNS DESCRIPTION <code>TogglOrganization</code> <p>The newly created organization.</p> Source code in <code>src/toggl_api/_organization.py</code> <pre><code>def add(\n    self,\n    name: str,\n    workspace_name: str = \"Default-Workspace\",\n) -&gt; TogglOrganization:\n    \"\"\"Create a new organization with a single workspace.\n\n    Assigns current user as the organization owner.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/organizations#post-creates-a-new-organization)\n\n    Examples:\n        &gt;&gt;&gt; org = organization_endpoint.add(\"New-Workspace\")\n        &gt;&gt;&gt; org.name\n        \"New-Workspace\"\n\n    Args:\n        name: Name of the new orgnization.\n        workspace_name: Name of the default workspace in the organization.\n            No space characters allowed.\n\n    Raises:\n        NamingError: If any of the names are invalid or the wrong length.\n        HTTPStatusError: If the request is not a success.\n\n    Returns:\n        The newly created organization.\n    \"\"\"\n    TogglOrganization.validate_name(name)\n    TogglWorkspace.validate_name(workspace_name)\n\n    return cast(\n        \"TogglOrganization\",\n        self.request(\n            \"organizations\",\n            body={\"name\": name, \"workspace_name\": workspace_name},\n            method=RequestMethod.POST,\n            refresh=True,\n        ),\n    )\n</code></pre>"},{"location":"api-guide/organization.html#toggl_api.OrganizationEndpoint.edit","title":"edit","text":"<pre><code>edit(organization: TogglOrganization | int, name: str) -&gt; TogglOrganization\n</code></pre> <p>Update an existing organization.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>organization</code> <p>The id of the organization to edit.</p> <p> TYPE: <code>TogglOrganization | int</code> </p> <code>name</code> <p>What name to change the org to.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>NamingError</code> <p>If the new name is invalid.</p> <code>HTTPStatusError</code> <p>If the request is not a success.</p> RETURNS DESCRIPTION <code>TogglOrganization</code> <p>The newly edited organization.</p> Source code in <code>src/toggl_api/_organization.py</code> <pre><code>def edit(\n    self,\n    organization: TogglOrganization | int,\n    name: str,\n) -&gt; TogglOrganization:\n    \"\"\"Update an existing organization.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/organizations#put-updates-an-existing-organization)\n\n    Args:\n        organization: The id of the organization to edit.\n        name: What name to change the org to.\n\n    Raises:\n        NamingError: If the new name is invalid.\n        HTTPStatusError: If the request is not a success.\n\n    Returns:\n        The newly edited organization.\n    \"\"\"\n    TogglOrganization.validate_name(name)\n\n    if isinstance(organization, TogglOrganization):\n        organization = organization.id\n\n    self.request(\n        f\"organizations/{organization}\",\n        body={\"name\": name},\n        refresh=True,\n        method=RequestMethod.PUT,\n    )\n\n    edit = TogglOrganization(organization, name)\n    if self.cache:\n        self.cache.update(edit)\n        self.cache.commit()\n\n    return edit\n</code></pre>"},{"location":"api-guide/organization.html#toggl_api.OrganizationEndpoint.collect","title":"collect","text":"<pre><code>collect(*, refresh: bool = False) -&gt; list[TogglOrganization]\n</code></pre> <p>Get all organizations a given user is part of.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>refresh</code> <p>Whether to use cache or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If the request is not a success.</p> RETURNS DESCRIPTION <code>list[TogglOrganization]</code> <p>A list of organization objects or empty if none found.</p> Source code in <code>src/toggl_api/_organization.py</code> <pre><code>def collect(self, *, refresh: bool = False) -&gt; list[TogglOrganization]:\n    \"\"\"Get all organizations a given user is part of.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/me#get-organizations-that-a-user-is-part-of)\n\n    Args:\n        refresh: Whether to use cache or not.\n\n    Raises:\n        HTTPStatusError: If the request is not a success.\n\n    Returns:\n        A list of organization objects or empty if none found.\n    \"\"\"\n    return cast(\n        \"list[TogglOrganization]\",\n        self.request(\"me/organizations\", refresh=refresh),\n    )\n</code></pre>"},{"location":"api-guide/organization.html#toggl_api.OrganizationEndpoint.delete","title":"delete","text":"<pre><code>delete(organization: TogglOrganization | int) -&gt; None\n</code></pre> <p>Leave organization effectively deleting user account in org.</p> <p>Deletes organization if it is last user.</p> <p>Deletion might not be instant on the API end and might take a few seconds to propogate, so the object might appear in the 'get' or 'collect' method.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>organization</code> <p>Organization to delete.</p> <p> TYPE: <code>TogglOrganization | int</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If the response status_code is not '200' or '404'.</p> Source code in <code>src/toggl_api/_organization.py</code> <pre><code>def delete(self, organization: TogglOrganization | int) -&gt; None:\n    \"\"\"Leave organization effectively deleting user account in org.\n\n    Deletes organization if it is last user.\n\n    Deletion might not be instant on the API end and might take a few\n    seconds to propogate, so the object might appear in the 'get' or\n    'collect' method.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/organizations#delete-leaves-organization)\n\n    Args:\n        organization: Organization to delete.\n\n    Raises:\n        HTTPStatusError: If the response status_code is not '200' or '404'.\n    \"\"\"\n    org_id = organization if isinstance(organization, int) else organization.id\n    try:\n        self.request(\n            f\"organizations/{org_id}/users/leave\",\n            method=RequestMethod.DELETE,\n            refresh=True,\n        )\n    except HTTPStatusError as err:\n        if self.re_raise or err.response.status_code != codes.NOT_FOUND:\n            raise\n        log.exception(\"%s\")\n        log.warning(\n            \"Organization with id %s was either already deleted or did not exist in the first place!\",\n            org_id,\n        )\n    if self.cache is None:\n        return\n\n    if isinstance(organization, int):\n        org = self.cache.find({\"id\": organization})\n        if not isinstance(org, TogglOrganization):\n            return\n        organization = org\n\n    self.cache.delete(organization)\n    self.cache.commit()\n</code></pre>"},{"location":"api-guide/organization.html#toggl_api.asyncio.AsyncOrganizationEndpoint","title":"toggl_api.asyncio.AsyncOrganizationEndpoint","text":"<p>               Bases: <code>TogglAsyncCachedEndpoint[TogglOrganization]</code></p> <p>Endpoint to do with handling organization specific details.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; org_endpoint = OrganizationEndpoint(BasicAuth(...), AsyncSqliteCache(...))\n</code></pre> PARAMETER DESCRIPTION <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>cache</code> <p>Cache object where the organization models are stored.</p> <p> TYPE: <code>AsyncSqliteCache[TogglOrganization] | None</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>Optional async client to be passed to be used for requests.</p> <p> TYPE: <code>AsyncClient | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>get</code> <p>Create a new organization with a single workspace.</p> <code>add</code> <p>Create a new organization with a single workspace.</p> <code>edit</code> <p>Update an existing organization.</p> <code>collect</code> <p>Get all organizations a given user is part of.</p> <code>delete</code> <p>Leave organization, effectively delete user account in org.</p>"},{"location":"api-guide/organization.html#toggl_api.asyncio.AsyncOrganizationEndpoint.get","title":"get  <code>async</code>","text":"<pre><code>get(\n    organization: TogglOrganization | int, *, refresh: bool = False\n) -&gt; TogglOrganization | None\n</code></pre> <p>Create a new organization with a single workspace.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>organization</code> <p>Organization to retrieve.</p> <p> TYPE: <code>TogglOrganization | int</code> </p> <code>refresh</code> <p>Whether to ignore cache completely.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If any error except a '404' was received.</p> RETURNS DESCRIPTION <code>TogglOrganization | None</code> <p>Organization object that was retrieve or None if not found.</p>"},{"location":"api-guide/organization.html#toggl_api.asyncio.AsyncOrganizationEndpoint.add","title":"add  <code>async</code>","text":"<pre><code>add(name: str, workspace_name: str = 'Default-Workspace') -&gt; TogglOrganization\n</code></pre> <p>Create a new organization with a single workspace.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; org = await organization_endpoint.add(\"New-Workspace\")\n&gt;&gt;&gt; org.name\n\"New-Workspace\"\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>Name of the new orgnization.</p> <p> TYPE: <code>str</code> </p> <code>workspace_name</code> <p>Name of the default workspace in the organization. No space characters allowed.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Default-Workspace'</code> </p> RAISES DESCRIPTION <code>NamingError</code> <p>If any of the names are invalid or the wrong length.</p> <code>HTTPStatusError</code> <p>If the request is not a success.</p> RETURNS DESCRIPTION <code>TogglOrganization</code> <p>The newly created organization.</p>"},{"location":"api-guide/organization.html#toggl_api.asyncio.AsyncOrganizationEndpoint.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(organization: TogglOrganization | int, name: str) -&gt; TogglOrganization\n</code></pre> <p>Update an existing organization.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>organization</code> <p>The id of the organization to edit.</p> <p> TYPE: <code>TogglOrganization | int</code> </p> <code>name</code> <p>What name to change the org to.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>NamingError</code> <p>If the new name is invalid.</p> <code>HTTPStatusError</code> <p>If the request is not a success.</p> RETURNS DESCRIPTION <code>TogglOrganization</code> <p>The newly edited organization.</p>"},{"location":"api-guide/organization.html#toggl_api.asyncio.AsyncOrganizationEndpoint.collect","title":"collect  <code>async</code>","text":"<pre><code>collect(*, refresh: bool = False) -&gt; list[TogglOrganization]\n</code></pre> <p>Get all organizations a given user is part of.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>refresh</code> <p>Whether to use cache or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If the request is not a success.</p> RETURNS DESCRIPTION <code>list[TogglOrganization]</code> <p>A list of organization objects or empty if none found.</p>"},{"location":"api-guide/organization.html#toggl_api.asyncio.AsyncOrganizationEndpoint.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(organization: TogglOrganization | int) -&gt; None\n</code></pre> <p>Leave organization, effectively delete user account in org.</p> <p>If another user is in the organization it will remain active.</p> <p>Deletion might not be instant on the API end and might take a few seconds to propogate, so the object might appear in the 'get' or 'collect' method.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>organization</code> <p>Organization to delete.</p> <p> TYPE: <code>TogglOrganization | int</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If the response status_code is not '200' or '404'.</p>"},{"location":"api-guide/project.html","title":"Projects","text":""},{"location":"api-guide/project.html#toggl_api.ProjectBody","title":"toggl_api.ProjectBody  <code>dataclass</code>","text":"<p>               Bases: <code>BaseBody</code></p> <p>JSON body dataclass for PUT, POST &amp; PATCH requests.</p> METHOD DESCRIPTION <code>format</code> <p>Format the body for JSON requests.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Name of the project. Defaults to None. Will be required if its a POST request.</p> <p> TYPE: <code>str | None</code> </p> <code>active</code> <p>Whether the project is archived or active.</p> <p> TYPE: <code>bool | Literal['both']</code> </p> <code>is_private</code> <p>Whether the project is private or not. Defaults to True.</p> <p> TYPE: <code>bool | None</code> </p> <code>client_name</code> <p>Client name if client_id is not set. Defaults to None. If client_id is</p> <p> TYPE: <code>str | None</code> </p> <code>color</code> <p>Color of the project. Refer to BASIC_COLORS</p> <p> TYPE: <code>str | None</code> </p> <code>start_date</code> <p>Date to set the start of a project. If not set or start date is after</p> <p> TYPE: <code>date | None</code> </p> <code>end_date</code> <p>Date to set the end of the project. If not set or start date is after</p> <p> TYPE: <code>date | None</code> </p> <code>since</code> <p>Timestamp for querying for projects with the 'collect' endpoint.</p> <p> TYPE: <code>date | int | None</code> </p> <code>user_ids</code> <p>Query for specific projects with assocciated users. API only.</p> <p> TYPE: <code>list[int]</code> </p> <code>client_ids</code> <p>Query for specific projects with assocciated clients.</p> <p> TYPE: <code>list[int]</code> </p> <code>group_ids</code> <p>Query for specific projects with assocciated groups. API only</p> <p> TYPE: <code>list[int]</code> </p> <code>statuses</code> <p>Query for specific statuses when using the collect endpoint.</p> <p> TYPE: <code>list[Status]</code> </p> Source code in <code>src/toggl_api/_project.py</code> <pre><code>@dataclass\nclass ProjectBody(BaseBody):\n    \"\"\"JSON body dataclass for PUT, POST &amp; PATCH requests.\"\"\"\n\n    name: str | None = field(default=None)\n    \"\"\"Name of the project. Defaults to None. Will be required if its a POST request.\"\"\"\n\n    active: bool | Literal[\"both\"] = field(default=True)\n    \"\"\"Whether the project is archived or active.\n    The literal 'both' is used for querying.\"\"\"\n    is_private: bool | None = field(\n        default=True,\n        metadata={\"endpoints\": frozenset((\"edit\", \"add\"))},\n    )\n    \"\"\"Whether the project is private or not. Defaults to True.\"\"\"\n\n    client_id: int | None = field(\n        default=None,\n        metadata={\"endpoints\": frozenset((\"edit\", \"add\"))},\n    )\n    client_name: str | None = field(\n        default=None,\n        metadata={\"endpoints\": frozenset((\"edit\", \"add\"))},\n    )\n    \"\"\"Client name if client_id is not set. Defaults to None. If client_id is\n    set the client_name will be ignored.\"\"\"\n\n    color: str | None = field(\n        default=None,\n        metadata={\"endpoints\": frozenset((\"edit\", \"add\"))},\n    )\n    \"\"\"Color of the project. Refer to [BASIC_COLORS][toggl_api.ProjectEndpoint.BASIC_COLORS]\n    for accepted colors for non-premium users.\"\"\"\n\n    start_date: date | None = field(\n        default=None,\n        metadata={\"endpoints\": frozenset((\"edit\", \"add\"))},\n    )\n    \"\"\"Date to set the start of a project. If not set or start date is after\n    the end date the end date will be ignored.\"\"\"\n\n    end_date: date | None = field(\n        default=None,\n        metadata={\"endpoints\": frozenset((\"edit\", \"add\"))},\n    )\n    \"\"\"Date to set the end of the project. If not set or start date is after\n    the end date the end date will be ignored.\"\"\"\n\n    since: date | int | None = field(\n        default=None,\n        metadata={\"endpoints\": frozenset((\"collect\",))},\n    )\n    \"\"\"Timestamp for querying for projects with the 'collect' endpoint.\n    Retrieve projects created/modified/deleted since this date using UNIX timestamp.\n    *If using local cache deleted projects are not present.*\n    \"\"\"\n\n    user_ids: list[int] = field(\n        default_factory=list,\n        metadata={\"endpoints\": frozenset((\"collect\",))},\n    )\n    \"\"\"Query for specific projects with assocciated users. API only.\"\"\"\n\n    client_ids: list[int] = field(\n        default_factory=list,\n        metadata={\"endpoints\": frozenset((\"collect\",))},\n    )\n    \"\"\"Query for specific projects with assocciated clients.\"\"\"\n\n    group_ids: list[int] = field(\n        default_factory=list,\n        metadata={\"endpoints\": frozenset((\"collect\",))},\n    )\n    \"\"\"Query for specific projects with assocciated groups. API only\"\"\"\n\n    statuses: list[TogglProject.Status] = field(\n        default_factory=list,\n        metadata={\"endpoints\": frozenset((\"collect\",))},\n    )\n    \"\"\"Query for specific statuses when using the collect endpoint.\n    Deleted status only works with the remote API.\n    \"\"\"\n\n    def _format_collect(self, body: dict[str, Any]) -&gt; None:\n        if self.since:\n            body[\"since\"] = get_timestamp(self.since)\n        if self.user_ids:\n            body[\"user_ids\"] = self.user_ids\n        if self.client_ids:\n            body[\"client_ids\"] = self.client_ids\n        if self.group_ids:\n            body[\"group_ids\"] = self.group_ids\n        if self.statuses:\n            body[\"statuses\"] = [s.name.lower() for s in self.statuses]\n\n    def format(self, endpoint: str, **body: Any) -&gt; dict[str, Any]:\n        \"\"\"Format the body for JSON requests.\n\n        Gets called by the endpoint methods before requesting.\n\n        Args:\n            endpoint: Name of the endpoint for filtering purposes.\n            body: Additional arguments for the body.\n\n        Returns:\n            dict[str, Any]: JSON compatible formatted body.\n        \"\"\"\n        body.update(\n            {\n                \"active\": self.active,\n                \"is_private\": self.is_private,\n            },\n        )\n        if self.name:\n            body[\"name\"] = self.name\n        if self.client_id:\n            body[\"client_id\"] = self.client_id\n        elif self.client_name:\n            body[\"client_name\"] = self.client_name\n\n        if self.color:\n            color = ProjectEndpoint.get_color(self.color) if self.color in ProjectEndpoint.BASIC_COLORS else self.color\n            body[\"color\"] = color\n\n        if self.start_date and self._verify_endpoint_parameter(\n            \"start_date\",\n            endpoint,\n        ):\n            body[\"start_date\"] = format_iso(self.start_date)\n        if self.end_date and self._verify_endpoint_parameter(\n            \"end_date\",\n            endpoint,\n        ):\n            if self.start_date and self.end_date &lt; self.start_date:\n                log.warning(\n                    \"End date is before the start date. Ignoring end date...\",\n                )\n            else:\n                body[\"end_date\"] = format_iso(self.end_date)\n\n        if endpoint == \"collect\":\n            self._format_collect(body)\n\n        return body\n</code></pre>"},{"location":"api-guide/project.html#toggl_api.ProjectBody.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = field(default=None)\n</code></pre> <p>Name of the project. Defaults to None. Will be required if its a POST request.</p>"},{"location":"api-guide/project.html#toggl_api.ProjectBody.active","title":"active  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>active: bool | Literal['both'] = field(default=True)\n</code></pre> <p>Whether the project is archived or active. The literal 'both' is used for querying.</p>"},{"location":"api-guide/project.html#toggl_api.ProjectBody.is_private","title":"is_private  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_private: bool | None = field(\n    default=True, metadata={\"endpoints\": frozenset((\"edit\", \"add\"))}\n)\n</code></pre> <p>Whether the project is private or not. Defaults to True.</p>"},{"location":"api-guide/project.html#toggl_api.ProjectBody.client_name","title":"client_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client_name: str | None = field(\n    default=None, metadata={\"endpoints\": frozenset((\"edit\", \"add\"))}\n)\n</code></pre> <p>Client name if client_id is not set. Defaults to None. If client_id is set the client_name will be ignored.</p>"},{"location":"api-guide/project.html#toggl_api.ProjectBody.color","title":"color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>color: str | None = field(\n    default=None, metadata={\"endpoints\": frozenset((\"edit\", \"add\"))}\n)\n</code></pre> <p>Color of the project. Refer to BASIC_COLORS for accepted colors for non-premium users.</p>"},{"location":"api-guide/project.html#toggl_api.ProjectBody.start_date","title":"start_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start_date: date | None = field(\n    default=None, metadata={\"endpoints\": frozenset((\"edit\", \"add\"))}\n)\n</code></pre> <p>Date to set the start of a project. If not set or start date is after the end date the end date will be ignored.</p>"},{"location":"api-guide/project.html#toggl_api.ProjectBody.end_date","title":"end_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_date: date | None = field(\n    default=None, metadata={\"endpoints\": frozenset((\"edit\", \"add\"))}\n)\n</code></pre> <p>Date to set the end of the project. If not set or start date is after the end date the end date will be ignored.</p>"},{"location":"api-guide/project.html#toggl_api.ProjectBody.since","title":"since  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>since: date | int | None = field(\n    default=None, metadata={\"endpoints\": frozenset((\"collect\",))}\n)\n</code></pre> <p>Timestamp for querying for projects with the 'collect' endpoint. Retrieve projects created/modified/deleted since this date using UNIX timestamp. If using local cache deleted projects are not present.</p>"},{"location":"api-guide/project.html#toggl_api.ProjectBody.user_ids","title":"user_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_ids: list[int] = field(\n    default_factory=list, metadata={\"endpoints\": frozenset((\"collect\",))}\n)\n</code></pre> <p>Query for specific projects with assocciated users. API only.</p>"},{"location":"api-guide/project.html#toggl_api.ProjectBody.client_ids","title":"client_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client_ids: list[int] = field(\n    default_factory=list, metadata={\"endpoints\": frozenset((\"collect\",))}\n)\n</code></pre> <p>Query for specific projects with assocciated clients.</p>"},{"location":"api-guide/project.html#toggl_api.ProjectBody.group_ids","title":"group_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group_ids: list[int] = field(\n    default_factory=list, metadata={\"endpoints\": frozenset((\"collect\",))}\n)\n</code></pre> <p>Query for specific projects with assocciated groups. API only</p>"},{"location":"api-guide/project.html#toggl_api.ProjectBody.statuses","title":"statuses  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>statuses: list[Status] = field(\n    default_factory=list, metadata={\"endpoints\": frozenset((\"collect\",))}\n)\n</code></pre> <p>Query for specific statuses when using the collect endpoint. Deleted status only works with the remote API.</p>"},{"location":"api-guide/project.html#toggl_api.ProjectBody.format","title":"format","text":"<pre><code>format(endpoint: str, **body: Any) -&gt; dict[str, Any]\n</code></pre> <p>Format the body for JSON requests.</p> <p>Gets called by the endpoint methods before requesting.</p> PARAMETER DESCRIPTION <code>endpoint</code> <p>Name of the endpoint for filtering purposes.</p> <p> TYPE: <code>str</code> </p> <code>body</code> <p>Additional arguments for the body.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>dict[str, Any]: JSON compatible formatted body.</p> Source code in <code>src/toggl_api/_project.py</code> <pre><code>def format(self, endpoint: str, **body: Any) -&gt; dict[str, Any]:\n    \"\"\"Format the body for JSON requests.\n\n    Gets called by the endpoint methods before requesting.\n\n    Args:\n        endpoint: Name of the endpoint for filtering purposes.\n        body: Additional arguments for the body.\n\n    Returns:\n        dict[str, Any]: JSON compatible formatted body.\n    \"\"\"\n    body.update(\n        {\n            \"active\": self.active,\n            \"is_private\": self.is_private,\n        },\n    )\n    if self.name:\n        body[\"name\"] = self.name\n    if self.client_id:\n        body[\"client_id\"] = self.client_id\n    elif self.client_name:\n        body[\"client_name\"] = self.client_name\n\n    if self.color:\n        color = ProjectEndpoint.get_color(self.color) if self.color in ProjectEndpoint.BASIC_COLORS else self.color\n        body[\"color\"] = color\n\n    if self.start_date and self._verify_endpoint_parameter(\n        \"start_date\",\n        endpoint,\n    ):\n        body[\"start_date\"] = format_iso(self.start_date)\n    if self.end_date and self._verify_endpoint_parameter(\n        \"end_date\",\n        endpoint,\n    ):\n        if self.start_date and self.end_date &lt; self.start_date:\n            log.warning(\n                \"End date is before the start date. Ignoring end date...\",\n            )\n        else:\n            body[\"end_date\"] = format_iso(self.end_date)\n\n    if endpoint == \"collect\":\n        self._format_collect(body)\n\n    return body\n</code></pre>"},{"location":"api-guide/project.html#toggl_api.ProjectEndpoint","title":"toggl_api.ProjectEndpoint","text":"<p>               Bases: <code>TogglCachedEndpoint[TogglProject]</code></p> <p>Specific endpoints for retrieving and modifying projects.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from toggl_api.utility import get_authentication, retrieve_workspace_id\n&gt;&gt;&gt; from toggl_api import JSONCache\n&gt;&gt;&gt; project_endpoint = ProjectEndpoint(retrieve_workspace_id(), get_authentication(), JSONCache(...))\n&gt;&gt;&gt; project_endpoint.get(213141424)\nTogglProject(213141424, \"Amaryllis\", ...)\n</code></pre> <pre><code>&gt;&gt;&gt; project_endpoint.delete(213141424)\nNone\n</code></pre> PARAMETER DESCRIPTION <code>workspace_id</code> <p>The workspace the projects belong to.</p> <p> TYPE: <code>int | TogglWorkspace</code> </p> <code>auth</code> <p>Basic authentication with an api token or username/password combo.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>cache</code> <p>Cache to push the projects to.</p> <p> TYPE: <code>TogglCache[TogglProject] | None</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>Optional client to be passed to be used for requests. Useful when a global client is used and needs to be recycled.</p> <p> TYPE: <code>Client | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>Timeout | int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> ATTRIBUTE DESCRIPTION <code>BASIC_COLORS</code> <p>Default colors that are available for non-premium users.</p> <p> TYPE: <code>Final[dict[str, str]]</code> </p> METHOD DESCRIPTION <code>collect</code> <p>Return all cached or remote projects.</p> <code>get</code> <p>Request a project based on its id.</p> <code>delete</code> <p>Delete a project based on its id.</p> <code>edit</code> <p>Edit a project based on its id with the parameters provided in the body.</p> <code>add</code> <p>Create a new project based on the parameters provided in the body.</p> <code>get_color</code> <p>Get a color by name. Defaults to gray.</p> <code>get_color_id</code> <p>Get a color id by name.</p> <code>status_to_query</code> <p>Create a list of queries depending on the desired project status.</p> Source code in <code>src/toggl_api/_project.py</code> <pre><code>class ProjectEndpoint(TogglCachedEndpoint[TogglProject]):\n    \"\"\"Specific endpoints for retrieving and modifying projects.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/projects)\n\n    Examples:\n        &gt;&gt;&gt; from toggl_api.utility import get_authentication, retrieve_workspace_id\n        &gt;&gt;&gt; from toggl_api import JSONCache\n        &gt;&gt;&gt; project_endpoint = ProjectEndpoint(retrieve_workspace_id(), get_authentication(), JSONCache(...))\n        &gt;&gt;&gt; project_endpoint.get(213141424)\n        TogglProject(213141424, \"Amaryllis\", ...)\n\n        &gt;&gt;&gt; project_endpoint.delete(213141424)\n        None\n\n    Params:\n        workspace_id: The workspace the projects belong to.\n        auth: Basic authentication with an api token or username/password combo.\n        cache: Cache to push the projects to.\n        client: Optional client to be passed to be used for requests. Useful\n            when a global client is used and needs to be recycled.\n        timeout: How long it takes for the client to timeout. Keyword Only.\n            Defaults to 10 seconds.\n        re_raise: Whether to raise all HTTPStatusError errors and not handle them\n            internally. Keyword Only.\n        retries: Max retries to attempt if the server returns a *5xx* status_code.\n            Has no effect if re_raise is `True`. Keyword Only.\n\n    Attributes:\n        BASIC_COLORS: Default colors that are available for non-premium users.\n    \"\"\"\n\n    MODEL = TogglProject\n\n    BASIC_COLORS: Final[dict[str, str]] = {\n        \"blue\": \"#0b83d9\",\n        \"violet\": \"#9e5bd9\",\n        \"pink\": \"#d94182\",\n        \"orange\": \"#e36a00\",\n        \"gold\": \"#bf7000\",\n        \"green\": \"#2da608\",\n        \"teal\": \"#06a893\",\n        \"beige\": \"#c9806b\",\n        \"dark-blue\": \"#465bb3\",\n        \"purple\": \"#990099\",\n        \"yellow\": \"#c7af14\",\n        \"dark-green\": \"#566614\",\n        \"red\": \"#d92b2b\",\n        \"gray\": \"#525266\",\n    }\n    \"\"\"Basic colors available for projects in order of the API index.\"\"\"\n\n    def __init__(\n        self,\n        workspace_id: int | TogglWorkspace,\n        auth: BasicAuth,\n        cache: TogglCache[TogglProject] | None = None,\n        *,\n        client: Client | None = None,\n        timeout: Timeout | int = 10,\n        re_raise: bool = False,\n        retries: int = 3,\n    ) -&gt; None:\n        super().__init__(\n            auth,\n            cache,\n            client=client,\n            timeout=timeout,\n            re_raise=re_raise,\n            retries=retries,\n        )\n        self.workspace_id = workspace_id if isinstance(workspace_id, int) else workspace_id.id\n\n    @staticmethod\n    def status_to_query(status: TogglProject.Status) -&gt; list[TogglQuery[Any]]:\n        \"\"\"Create a list of queries depending on the desired project status.\n\n        Args:\n            status: What is the status you are querying for?\n\n        Raises:\n            NotImplementedError: Active &amp; Deleted Statuses are currently not\n                supported for local querying.\n\n        Returns:\n            A list of query parameters for the desired status.\n        \"\"\"\n        if status == TogglProject.Status.ARCHIVED:\n            return [TogglQuery(\"active\", value=False)]\n\n        now = datetime.now(timezone.utc)\n        if status == TogglProject.Status.UPCOMING:\n            return [TogglQuery(\"start_date\", now, Comparison.LESS_THEN)]\n\n        if status == TogglProject.Status.ENDED:\n            return [TogglQuery(\"end_date\", now, Comparison.GREATER_THEN)]\n\n        msg = f\"{status} status is not supported by local cache queries!\"\n        raise NotImplementedError(msg)\n\n    def _collect_cache(self, body: ProjectBody | None) -&gt; list[TogglProject]:\n        if body:\n            queries: list[TogglQuery[Any]] = []\n            if isinstance(body.active, bool):\n                queries.append(\n                    TogglQuery(\"active\", body.active, Comparison.EQUAL),\n                )\n            if body.since:\n                queries.append(\n                    TogglQuery(\n                        \"timestamp\",\n                        body.since,\n                        Comparison.GREATER_THEN_OR_EQUAL,\n                    ),\n                )\n            if body.client_ids:\n                queries.append(TogglQuery(\"client\", body.client_ids))\n            if body.statuses:\n                for status in body.statuses:\n                    queries += self.status_to_query(status)\n\n            return list(self.query(*queries))\n\n        return list(self.load_cache())\n\n    def collect(\n        self,\n        body: ProjectBody | None = None,\n        *,\n        refresh: bool = False,\n        sort_pinned: bool = False,\n        only_me: bool = False,\n        only_templates: bool = False,\n    ) -&gt; list[TogglProject]:\n        \"\"\"Return all cached or remote projects.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/projects#get-workspaceprojects)\n\n        Args:\n            body: Optional body for adding query parameters for filtering projects.\n            refresh: Whether to fetch from the remote API if true else using\n                the local cache.\n            sort_pinned: Whether to put pinned projects ontop of the results.\n                Only works with the remote API at the moment.\n            only_me: Only retrieve projects that are assigned to the current\n                user assocciated with the authentication. API specific.\n            only_templates: Retrieve template projects. API specific.\n\n        Raises:\n            HTTPStatusError: If any response that is not '200' code is returned.\n            NotImplementedError: Deleted or Active status are used with a 'False'\n                refresh argument.\n\n        Returns:\n            A list of projects or an empty list if None are found.\n        \"\"\"\n        if not refresh:\n            return self._collect_cache(body)\n\n        return cast(\n            \"list[TogglProject]\",\n            self.request(\n                self.endpoint,\n                body=body.format(\n                    \"collect\",\n                    workspace_id=self.workspace_id,\n                    sort_pinned=sort_pinned,\n                    only_me=only_me,\n                    only_templates=only_templates,\n                )\n                if body\n                else {\n                    \"sort_pinned\": sort_pinned,\n                    \"only_me\": only_me,\n                    \"only_templates\": only_templates,\n                },\n                refresh=refresh,\n            ),\n        )\n\n    def get(\n        self,\n        project_id: int | TogglProject,\n        *,\n        refresh: bool = False,\n    ) -&gt; TogglProject | None:\n        \"\"\"Request a project based on its id.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/projects#get-workspaceproject)\n\n        Examples:\n            &gt;&gt;&gt; project_endpoint.get(213141424)\n            TogglProject(213141424, \"Amaryllis\", ...)\n\n        Args:\n            project_id: TogglProject to retrieve. Either a model with the correct id or integer.\n            refresh: Whether to check cache or not.\n\n        Raises:\n            HTTPStatusError: If any status code that is not '200' or a '404' is returned.\n\n        Returns:\n            A project model or None if nothing was found.\n        \"\"\"\n        if isinstance(project_id, TogglProject):\n            project_id = project_id.id\n\n        if self.cache and not refresh:\n            return self.cache.find({\"id\": project_id})\n\n        try:\n            response = self.request(\n                f\"{self.endpoint}/{project_id}\",\n                refresh=refresh,\n            )\n        except HTTPStatusError as err:\n            if not self.re_raise and err.response.status_code == codes.NOT_FOUND:\n                log.warning(\"Project with id %s was not found!\", project_id)\n                return None\n            raise\n\n        return cast(\"TogglProject\", response) or None\n\n    def delete(self, project: TogglProject | int) -&gt; None:\n        \"\"\"Delete a project based on its id.\n\n        This endpoint always hits the external API in order to keep projects consistent.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/projects#delete-workspaceproject)\n\n        Examples:\n            &gt;&gt;&gt; project_endpoint.delete(213141424)\n            None\n\n        Args:\n            project: TogglProject to delete. Either an existing model or the integer id.\n\n        Raises:\n            HTTPStatusError: For anything that's not a '200' or '404' status code.\n        \"\"\"\n        project_id = project if isinstance(project, int) else project.id\n        try:\n            self.request(\n                f\"{self.endpoint}/{project_id}\",\n                method=RequestMethod.DELETE,\n                refresh=True,\n            )\n        except HTTPStatusError as err:\n            if self.re_raise or err.response.status_code != codes.NOT_FOUND:\n                raise\n            log.warning(\n                \"Project with id %s was either already deleted or did not exist in the first place!\",\n                project_id,\n            )\n        if self.cache is None:\n            return\n        if isinstance(project, int):\n            proj = self.cache.find({\"id\": project})\n            if not isinstance(proj, TogglProject):\n                return\n            project = proj\n\n        self.cache.delete(project)\n        self.cache.commit()\n\n    def edit(\n        self,\n        project: TogglProject | int,\n        body: ProjectBody,\n    ) -&gt; TogglProject:\n        \"\"\"Edit a project based on its id with the parameters provided in the body.\n\n        This endpoint always hit the external API in order to keep projects consistent.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/projects#put-workspaceproject)\n\n        Examples:\n            &gt;&gt;&gt; body = ProjectBody(name=\"Amaryllis\")\n            &gt;&gt;&gt; project_endpoint.add(213141424, body)\n            TogglProject(213141424, \"Amaryllis\", client=87695895, ...)\n\n        Args:\n            project: The existing project to edit. Either the model or the integer id.\n            body: The body with the edited attributes.\n\n        Raises:\n            HTTPStatusError: For anything that's not a 'ok' status code.\n\n        Returns:\n            The project model with the provided modifications.\n        \"\"\"\n        if isinstance(project, TogglProject):\n            project = project.id\n\n        return cast(\n            \"TogglProject\",\n            self.request(\n                f\"{self.endpoint}/{project}\",\n                method=RequestMethod.PUT,\n                body=body.format(\"edit\", workspace_id=self.workspace_id),\n                refresh=True,\n            ),\n        )\n\n    def add(self, body: ProjectBody) -&gt; TogglProject:\n        \"\"\"Create a new project based on the parameters provided in the body.\n\n        This endpoint always hit the external API in order to keep projects consistent.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/projects#post-workspaceprojects)\n\n        Examples:\n            &gt;&gt;&gt; body = ProjectBody(name=\"Zinnia\", client_id=87695895)\n            &gt;&gt;&gt; project_endpoint.add(body)\n            TogglProject(213141424, \"Zinnia\", client=87695895, ...)\n\n        Args:\n            body: The body with the new attributes of the project.\n\n        Raises:\n            HTTPStatusError: For anything that's not a 'ok' status code.\n            NamingError: If the new project name is invalid.\n\n        Returns:\n            The newly created project.\n        \"\"\"\n        if body.name is None:\n            msg = \"Name must be set in order to create a project!\"\n            raise NamingError(msg)\n\n        return cast(\n            \"TogglProject\",\n            self.request(\n                self.endpoint,\n                method=RequestMethod.POST,\n                body=body.format(\"add\", workspace_id=self.workspace_id),\n                refresh=True,\n            ),\n        )\n\n    @classmethod\n    def get_color(cls, name: str) -&gt; str:\n        \"\"\"Get a color by name. Defaults to gray.\n\n        Args:\n            name: The name of the color.\n\n        Returns:\n            Color in a hexcode.\n        \"\"\"\n        return cls.BASIC_COLORS.get(name, \"#525266\")\n\n    @classmethod\n    def get_color_id(cls, color: str) -&gt; int:\n        \"\"\"Get a color id by name.\n\n        Args:\n            color: Name of the desired color.\n\n        Raises:\n            IndexError: If the color name is not a standard color.\n\n        Returns:\n            Index of the provided color name.\n        \"\"\"\n        colors = list(cls.BASIC_COLORS.values())\n        return colors.index(color)\n\n    @property\n    def endpoint(self) -&gt; str:\n        return f\"workspaces/{self.workspace_id}/projects\"\n</code></pre>"},{"location":"api-guide/project.html#toggl_api.ProjectEndpoint.BASIC_COLORS","title":"BASIC_COLORS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BASIC_COLORS: Final[dict[str, str]] = {\n    \"blue\": \"#0b83d9\",\n    \"violet\": \"#9e5bd9\",\n    \"pink\": \"#d94182\",\n    \"orange\": \"#e36a00\",\n    \"gold\": \"#bf7000\",\n    \"green\": \"#2da608\",\n    \"teal\": \"#06a893\",\n    \"beige\": \"#c9806b\",\n    \"dark-blue\": \"#465bb3\",\n    \"purple\": \"#990099\",\n    \"yellow\": \"#c7af14\",\n    \"dark-green\": \"#566614\",\n    \"red\": \"#d92b2b\",\n    \"gray\": \"#525266\",\n}\n</code></pre> <p>Basic colors available for projects in order of the API index.</p>"},{"location":"api-guide/project.html#toggl_api.ProjectEndpoint.collect","title":"collect","text":"<pre><code>collect(\n    body: ProjectBody | None = None,\n    *,\n    refresh: bool = False,\n    sort_pinned: bool = False,\n    only_me: bool = False,\n    only_templates: bool = False,\n) -&gt; list[TogglProject]\n</code></pre> <p>Return all cached or remote projects.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>Optional body for adding query parameters for filtering projects.</p> <p> TYPE: <code>ProjectBody | None</code> DEFAULT: <code>None</code> </p> <code>refresh</code> <p>Whether to fetch from the remote API if true else using the local cache.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sort_pinned</code> <p>Whether to put pinned projects ontop of the results. Only works with the remote API at the moment.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>only_me</code> <p>Only retrieve projects that are assigned to the current user assocciated with the authentication. API specific.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>only_templates</code> <p>Retrieve template projects. API specific.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If any response that is not '200' code is returned.</p> <code>NotImplementedError</code> <p>Deleted or Active status are used with a 'False' refresh argument.</p> RETURNS DESCRIPTION <code>list[TogglProject]</code> <p>A list of projects or an empty list if None are found.</p> Source code in <code>src/toggl_api/_project.py</code> <pre><code>def collect(\n    self,\n    body: ProjectBody | None = None,\n    *,\n    refresh: bool = False,\n    sort_pinned: bool = False,\n    only_me: bool = False,\n    only_templates: bool = False,\n) -&gt; list[TogglProject]:\n    \"\"\"Return all cached or remote projects.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/projects#get-workspaceprojects)\n\n    Args:\n        body: Optional body for adding query parameters for filtering projects.\n        refresh: Whether to fetch from the remote API if true else using\n            the local cache.\n        sort_pinned: Whether to put pinned projects ontop of the results.\n            Only works with the remote API at the moment.\n        only_me: Only retrieve projects that are assigned to the current\n            user assocciated with the authentication. API specific.\n        only_templates: Retrieve template projects. API specific.\n\n    Raises:\n        HTTPStatusError: If any response that is not '200' code is returned.\n        NotImplementedError: Deleted or Active status are used with a 'False'\n            refresh argument.\n\n    Returns:\n        A list of projects or an empty list if None are found.\n    \"\"\"\n    if not refresh:\n        return self._collect_cache(body)\n\n    return cast(\n        \"list[TogglProject]\",\n        self.request(\n            self.endpoint,\n            body=body.format(\n                \"collect\",\n                workspace_id=self.workspace_id,\n                sort_pinned=sort_pinned,\n                only_me=only_me,\n                only_templates=only_templates,\n            )\n            if body\n            else {\n                \"sort_pinned\": sort_pinned,\n                \"only_me\": only_me,\n                \"only_templates\": only_templates,\n            },\n            refresh=refresh,\n        ),\n    )\n</code></pre>"},{"location":"api-guide/project.html#toggl_api.ProjectEndpoint.get","title":"get","text":"<pre><code>get(\n    project_id: int | TogglProject, *, refresh: bool = False\n) -&gt; TogglProject | None\n</code></pre> <p>Request a project based on its id.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; project_endpoint.get(213141424)\nTogglProject(213141424, \"Amaryllis\", ...)\n</code></pre> PARAMETER DESCRIPTION <code>project_id</code> <p>TogglProject to retrieve. Either a model with the correct id or integer.</p> <p> TYPE: <code>int | TogglProject</code> </p> <code>refresh</code> <p>Whether to check cache or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If any status code that is not '200' or a '404' is returned.</p> RETURNS DESCRIPTION <code>TogglProject | None</code> <p>A project model or None if nothing was found.</p> Source code in <code>src/toggl_api/_project.py</code> <pre><code>def get(\n    self,\n    project_id: int | TogglProject,\n    *,\n    refresh: bool = False,\n) -&gt; TogglProject | None:\n    \"\"\"Request a project based on its id.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/projects#get-workspaceproject)\n\n    Examples:\n        &gt;&gt;&gt; project_endpoint.get(213141424)\n        TogglProject(213141424, \"Amaryllis\", ...)\n\n    Args:\n        project_id: TogglProject to retrieve. Either a model with the correct id or integer.\n        refresh: Whether to check cache or not.\n\n    Raises:\n        HTTPStatusError: If any status code that is not '200' or a '404' is returned.\n\n    Returns:\n        A project model or None if nothing was found.\n    \"\"\"\n    if isinstance(project_id, TogglProject):\n        project_id = project_id.id\n\n    if self.cache and not refresh:\n        return self.cache.find({\"id\": project_id})\n\n    try:\n        response = self.request(\n            f\"{self.endpoint}/{project_id}\",\n            refresh=refresh,\n        )\n    except HTTPStatusError as err:\n        if not self.re_raise and err.response.status_code == codes.NOT_FOUND:\n            log.warning(\"Project with id %s was not found!\", project_id)\n            return None\n        raise\n\n    return cast(\"TogglProject\", response) or None\n</code></pre>"},{"location":"api-guide/project.html#toggl_api.ProjectEndpoint.delete","title":"delete","text":"<pre><code>delete(project: TogglProject | int) -&gt; None\n</code></pre> <p>Delete a project based on its id.</p> <p>This endpoint always hits the external API in order to keep projects consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; project_endpoint.delete(213141424)\nNone\n</code></pre> PARAMETER DESCRIPTION <code>project</code> <p>TogglProject to delete. Either an existing model or the integer id.</p> <p> TYPE: <code>TogglProject | int</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything that's not a '200' or '404' status code.</p> Source code in <code>src/toggl_api/_project.py</code> <pre><code>def delete(self, project: TogglProject | int) -&gt; None:\n    \"\"\"Delete a project based on its id.\n\n    This endpoint always hits the external API in order to keep projects consistent.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/projects#delete-workspaceproject)\n\n    Examples:\n        &gt;&gt;&gt; project_endpoint.delete(213141424)\n        None\n\n    Args:\n        project: TogglProject to delete. Either an existing model or the integer id.\n\n    Raises:\n        HTTPStatusError: For anything that's not a '200' or '404' status code.\n    \"\"\"\n    project_id = project if isinstance(project, int) else project.id\n    try:\n        self.request(\n            f\"{self.endpoint}/{project_id}\",\n            method=RequestMethod.DELETE,\n            refresh=True,\n        )\n    except HTTPStatusError as err:\n        if self.re_raise or err.response.status_code != codes.NOT_FOUND:\n            raise\n        log.warning(\n            \"Project with id %s was either already deleted or did not exist in the first place!\",\n            project_id,\n        )\n    if self.cache is None:\n        return\n    if isinstance(project, int):\n        proj = self.cache.find({\"id\": project})\n        if not isinstance(proj, TogglProject):\n            return\n        project = proj\n\n    self.cache.delete(project)\n    self.cache.commit()\n</code></pre>"},{"location":"api-guide/project.html#toggl_api.ProjectEndpoint.edit","title":"edit","text":"<pre><code>edit(project: TogglProject | int, body: ProjectBody) -&gt; TogglProject\n</code></pre> <p>Edit a project based on its id with the parameters provided in the body.</p> <p>This endpoint always hit the external API in order to keep projects consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; body = ProjectBody(name=\"Amaryllis\")\n&gt;&gt;&gt; project_endpoint.add(213141424, body)\nTogglProject(213141424, \"Amaryllis\", client=87695895, ...)\n</code></pre> PARAMETER DESCRIPTION <code>project</code> <p>The existing project to edit. Either the model or the integer id.</p> <p> TYPE: <code>TogglProject | int</code> </p> <code>body</code> <p>The body with the edited attributes.</p> <p> TYPE: <code>ProjectBody</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything that's not a 'ok' status code.</p> RETURNS DESCRIPTION <code>TogglProject</code> <p>The project model with the provided modifications.</p> Source code in <code>src/toggl_api/_project.py</code> <pre><code>def edit(\n    self,\n    project: TogglProject | int,\n    body: ProjectBody,\n) -&gt; TogglProject:\n    \"\"\"Edit a project based on its id with the parameters provided in the body.\n\n    This endpoint always hit the external API in order to keep projects consistent.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/projects#put-workspaceproject)\n\n    Examples:\n        &gt;&gt;&gt; body = ProjectBody(name=\"Amaryllis\")\n        &gt;&gt;&gt; project_endpoint.add(213141424, body)\n        TogglProject(213141424, \"Amaryllis\", client=87695895, ...)\n\n    Args:\n        project: The existing project to edit. Either the model or the integer id.\n        body: The body with the edited attributes.\n\n    Raises:\n        HTTPStatusError: For anything that's not a 'ok' status code.\n\n    Returns:\n        The project model with the provided modifications.\n    \"\"\"\n    if isinstance(project, TogglProject):\n        project = project.id\n\n    return cast(\n        \"TogglProject\",\n        self.request(\n            f\"{self.endpoint}/{project}\",\n            method=RequestMethod.PUT,\n            body=body.format(\"edit\", workspace_id=self.workspace_id),\n            refresh=True,\n        ),\n    )\n</code></pre>"},{"location":"api-guide/project.html#toggl_api.ProjectEndpoint.add","title":"add","text":"<pre><code>add(body: ProjectBody) -&gt; TogglProject\n</code></pre> <p>Create a new project based on the parameters provided in the body.</p> <p>This endpoint always hit the external API in order to keep projects consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; body = ProjectBody(name=\"Zinnia\", client_id=87695895)\n&gt;&gt;&gt; project_endpoint.add(body)\nTogglProject(213141424, \"Zinnia\", client=87695895, ...)\n</code></pre> PARAMETER DESCRIPTION <code>body</code> <p>The body with the new attributes of the project.</p> <p> TYPE: <code>ProjectBody</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything that's not a 'ok' status code.</p> <code>NamingError</code> <p>If the new project name is invalid.</p> RETURNS DESCRIPTION <code>TogglProject</code> <p>The newly created project.</p> Source code in <code>src/toggl_api/_project.py</code> <pre><code>def add(self, body: ProjectBody) -&gt; TogglProject:\n    \"\"\"Create a new project based on the parameters provided in the body.\n\n    This endpoint always hit the external API in order to keep projects consistent.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/projects#post-workspaceprojects)\n\n    Examples:\n        &gt;&gt;&gt; body = ProjectBody(name=\"Zinnia\", client_id=87695895)\n        &gt;&gt;&gt; project_endpoint.add(body)\n        TogglProject(213141424, \"Zinnia\", client=87695895, ...)\n\n    Args:\n        body: The body with the new attributes of the project.\n\n    Raises:\n        HTTPStatusError: For anything that's not a 'ok' status code.\n        NamingError: If the new project name is invalid.\n\n    Returns:\n        The newly created project.\n    \"\"\"\n    if body.name is None:\n        msg = \"Name must be set in order to create a project!\"\n        raise NamingError(msg)\n\n    return cast(\n        \"TogglProject\",\n        self.request(\n            self.endpoint,\n            method=RequestMethod.POST,\n            body=body.format(\"add\", workspace_id=self.workspace_id),\n            refresh=True,\n        ),\n    )\n</code></pre>"},{"location":"api-guide/project.html#toggl_api.ProjectEndpoint.get_color","title":"get_color  <code>classmethod</code>","text":"<pre><code>get_color(name: str) -&gt; str\n</code></pre> <p>Get a color by name. Defaults to gray.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the color.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Color in a hexcode.</p> Source code in <code>src/toggl_api/_project.py</code> <pre><code>@classmethod\ndef get_color(cls, name: str) -&gt; str:\n    \"\"\"Get a color by name. Defaults to gray.\n\n    Args:\n        name: The name of the color.\n\n    Returns:\n        Color in a hexcode.\n    \"\"\"\n    return cls.BASIC_COLORS.get(name, \"#525266\")\n</code></pre>"},{"location":"api-guide/project.html#toggl_api.ProjectEndpoint.get_color_id","title":"get_color_id  <code>classmethod</code>","text":"<pre><code>get_color_id(color: str) -&gt; int\n</code></pre> <p>Get a color id by name.</p> PARAMETER DESCRIPTION <code>color</code> <p>Name of the desired color.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>IndexError</code> <p>If the color name is not a standard color.</p> RETURNS DESCRIPTION <code>int</code> <p>Index of the provided color name.</p> Source code in <code>src/toggl_api/_project.py</code> <pre><code>@classmethod\ndef get_color_id(cls, color: str) -&gt; int:\n    \"\"\"Get a color id by name.\n\n    Args:\n        color: Name of the desired color.\n\n    Raises:\n        IndexError: If the color name is not a standard color.\n\n    Returns:\n        Index of the provided color name.\n    \"\"\"\n    colors = list(cls.BASIC_COLORS.values())\n    return colors.index(color)\n</code></pre>"},{"location":"api-guide/project.html#toggl_api.ProjectEndpoint.status_to_query","title":"status_to_query  <code>staticmethod</code>","text":"<pre><code>status_to_query(status: Status) -&gt; list[TogglQuery[Any]]\n</code></pre> <p>Create a list of queries depending on the desired project status.</p> PARAMETER DESCRIPTION <code>status</code> <p>What is the status you are querying for?</p> <p> TYPE: <code>Status</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>Active &amp; Deleted Statuses are currently not supported for local querying.</p> RETURNS DESCRIPTION <code>list[TogglQuery[Any]]</code> <p>A list of query parameters for the desired status.</p> Source code in <code>src/toggl_api/_project.py</code> <pre><code>@staticmethod\ndef status_to_query(status: TogglProject.Status) -&gt; list[TogglQuery[Any]]:\n    \"\"\"Create a list of queries depending on the desired project status.\n\n    Args:\n        status: What is the status you are querying for?\n\n    Raises:\n        NotImplementedError: Active &amp; Deleted Statuses are currently not\n            supported for local querying.\n\n    Returns:\n        A list of query parameters for the desired status.\n    \"\"\"\n    if status == TogglProject.Status.ARCHIVED:\n        return [TogglQuery(\"active\", value=False)]\n\n    now = datetime.now(timezone.utc)\n    if status == TogglProject.Status.UPCOMING:\n        return [TogglQuery(\"start_date\", now, Comparison.LESS_THEN)]\n\n    if status == TogglProject.Status.ENDED:\n        return [TogglQuery(\"end_date\", now, Comparison.GREATER_THEN)]\n\n    msg = f\"{status} status is not supported by local cache queries!\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"api-guide/project.html#toggl_api.asyncio.AsyncProjectEndpoint","title":"toggl_api.asyncio.AsyncProjectEndpoint","text":"<p>               Bases: <code>TogglAsyncCachedEndpoint[TogglProject]</code></p> <p>Specific endpoints for retrieving and modifying projects.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from toggl_api.utility import get_authentication, retrieve_workspace_id\n&gt;&gt;&gt; from toggl_api.asyncio import AsyncSqliteCache, ProjectEndpoint\n&gt;&gt;&gt; project_endpoint = ProjectEndpoint(retrieve_workspace_id(), get_authentication(), AsyncSqliteCache(...))\n&gt;&gt;&gt; await project_endpoint.get(213141424)\nTogglProject(213141424, \"Amaryllis\", ...)\n</code></pre> <pre><code>&gt;&gt;&gt; await project_endpoint.delete(213141424)\nNone\n</code></pre> PARAMETER DESCRIPTION <code>workspace_id</code> <p>The workspace the projects belong to.</p> <p> TYPE: <code>int | TogglWorkspace</code> </p> <code>auth</code> <p>Basic authentication with an api token or username/password combo.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>cache</code> <p>Cache to push the projects to.</p> <p> TYPE: <code>AsyncSqliteCache[TogglProject] | None</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>Optional async client to be passed to be used for requests.</p> <p> TYPE: <code>AsyncClient | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> ATTRIBUTE DESCRIPTION <code>BASIC_COLORS</code> <p>Default colors that are available for non-premium users.</p> <p> TYPE: <code>Final[dict[str, str]]</code> </p> METHOD DESCRIPTION <code>status_to_query</code> <p>Create a list of queries depending on the desired project status.</p> <code>collect</code> <p>Return all cached or remote projects.</p> <code>get</code> <p>Request a project based on its id.</p> <code>delete</code> <p>Delete a project based on its id.</p> <code>edit</code> <p>Edit a project based on its id with the parameters provided in the body.</p> <code>add</code> <p>Create a new project based on the parameters provided in the body.</p> <code>get_color</code> <p>Get a color by name. Defaults to gray.</p> <code>get_color_id</code> <p>Get a color id by name.</p>"},{"location":"api-guide/project.html#toggl_api.asyncio.AsyncProjectEndpoint.BASIC_COLORS","title":"BASIC_COLORS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BASIC_COLORS: Final[dict[str, str]] = {\n    \"blue\": \"#0b83d9\",\n    \"violet\": \"#9e5bd9\",\n    \"pink\": \"#d94182\",\n    \"orange\": \"#e36a00\",\n    \"gold\": \"#bf7000\",\n    \"green\": \"#2da608\",\n    \"teal\": \"#06a893\",\n    \"beige\": \"#c9806b\",\n    \"dark-blue\": \"#465bb3\",\n    \"purple\": \"#990099\",\n    \"yellow\": \"#c7af14\",\n    \"dark-green\": \"#566614\",\n    \"red\": \"#d92b2b\",\n    \"gray\": \"#525266\",\n}\n</code></pre> <p>Basic colors available for projects in order of the API index.</p>"},{"location":"api-guide/project.html#toggl_api.asyncio.AsyncProjectEndpoint.status_to_query","title":"status_to_query  <code>staticmethod</code>","text":"<pre><code>status_to_query(status: Status, statement: Select[Any]) -&gt; Select[Any]\n</code></pre> <p>Create a list of queries depending on the desired project status.</p> PARAMETER DESCRIPTION <code>status</code> <p>What is the status you are querying for?</p> <p> TYPE: <code>Status</code> </p> <code>statement</code> <p>Base statement to add filters onto.</p> <p> TYPE: <code>Select[Any]</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>Active &amp; Deleted Statuses are currently not supported for local querying.</p> RETURNS DESCRIPTION <code>Select[Any]</code> <p>A list of query parameters for the desired status.</p>"},{"location":"api-guide/project.html#toggl_api.asyncio.AsyncProjectEndpoint.collect","title":"collect  <code>async</code>","text":"<pre><code>collect(\n    body: ProjectBody | None = None,\n    *,\n    refresh: bool = False,\n    sort_pinned: bool = False,\n    only_me: bool = False,\n    only_templates: bool = False,\n) -&gt; list[TogglProject]\n</code></pre> <p>Return all cached or remote projects.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>Optional body for adding query parameters for filtering projects.</p> <p> TYPE: <code>ProjectBody | None</code> DEFAULT: <code>None</code> </p> <code>refresh</code> <p>Whether to fetch from the remote API if true else using the local cache.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sort_pinned</code> <p>Whether to put pinned projects ontop of the results. Only works with the remote API at the moment.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>only_me</code> <p>Only retrieve projects that are assigned to the current user assocciated with the authentication. API specific.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>only_templates</code> <p>Retrieve template projects. API specific.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If any response that is not '200' code is returned.</p> <code>NotImplementedError</code> <p>Deleted or Active status are used with a 'False' refresh argument.</p> RETURNS DESCRIPTION <code>list[TogglProject]</code> <p>A list of projects or an empty list if None are found.</p>"},{"location":"api-guide/project.html#toggl_api.asyncio.AsyncProjectEndpoint.get","title":"get  <code>async</code>","text":"<pre><code>get(\n    project_id: int | TogglProject, *, refresh: bool = False\n) -&gt; TogglProject | None\n</code></pre> <p>Request a project based on its id.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await project_endpoint.get(213141424)\nTogglProject(213141424, \"Amaryllis\", ...)\n</code></pre> PARAMETER DESCRIPTION <code>project_id</code> <p>TogglProject to retrieve. Either a model with the correct id or integer.</p> <p> TYPE: <code>int | TogglProject</code> </p> <code>refresh</code> <p>Whether to check cache or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If any status code that is not '200' or a '404' is returned.</p> RETURNS DESCRIPTION <code>TogglProject | None</code> <p>A project model or None if nothing was found.</p>"},{"location":"api-guide/project.html#toggl_api.asyncio.AsyncProjectEndpoint.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(project: TogglProject | int) -&gt; None\n</code></pre> <p>Delete a project based on its id.</p> <p>This endpoint always hits the external API in order to keep projects consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; project_endpoint.delete(213141424)\nNone\n</code></pre> PARAMETER DESCRIPTION <code>project</code> <p>TogglProject to delete. Either an existing model or the integer id.</p> <p> TYPE: <code>TogglProject | int</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything that's not a '200' or '404' status code.</p>"},{"location":"api-guide/project.html#toggl_api.asyncio.AsyncProjectEndpoint.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(project: TogglProject | int, body: ProjectBody) -&gt; TogglProject\n</code></pre> <p>Edit a project based on its id with the parameters provided in the body.</p> <p>This endpoint always hit the external API in order to keep projects consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; body = ProjectBody(name=\"Amaryllis\")\n&gt;&gt;&gt; project_endpoint.add(213141424, body)\nTogglProject(213141424, \"Amaryllis\", client=87695895, ...)\n</code></pre> PARAMETER DESCRIPTION <code>project</code> <p>The existing project to edit. Either the model or the integer id.</p> <p> TYPE: <code>TogglProject | int</code> </p> <code>body</code> <p>The body with the edited attributes.</p> <p> TYPE: <code>ProjectBody</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything that's not a 'ok' status code.</p> RETURNS DESCRIPTION <code>TogglProject</code> <p>The project model with the provided modifications.</p>"},{"location":"api-guide/project.html#toggl_api.asyncio.AsyncProjectEndpoint.add","title":"add  <code>async</code>","text":"<pre><code>add(body: ProjectBody) -&gt; TogglProject\n</code></pre> <p>Create a new project based on the parameters provided in the body.</p> <p>This endpoint always hit the external API in order to keep projects consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; body = ProjectBody(name=\"Zinnia\", client_id=87695895)\n&gt;&gt;&gt; project_endpoint.add(body)\nTogglProject(213141424, \"Zinnia\", client=87695895, ...)\n</code></pre> PARAMETER DESCRIPTION <code>body</code> <p>The body with the new attributes of the project.</p> <p> TYPE: <code>ProjectBody</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything that's not a 'ok' status code.</p> <code>NamingError</code> <p>If the project name is invalid.</p> RETURNS DESCRIPTION <code>TogglProject</code> <p>The newly created project.</p>"},{"location":"api-guide/project.html#toggl_api.asyncio.AsyncProjectEndpoint.get_color","title":"get_color  <code>classmethod</code>","text":"<pre><code>get_color(name: str) -&gt; str\n</code></pre> <p>Get a color by name. Defaults to gray.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the color.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Color in a hexcode.</p>"},{"location":"api-guide/project.html#toggl_api.asyncio.AsyncProjectEndpoint.get_color_id","title":"get_color_id  <code>classmethod</code>","text":"<pre><code>get_color_id(color: str) -&gt; int\n</code></pre> <p>Get a color id by name.</p> PARAMETER DESCRIPTION <code>color</code> <p>Name of the desired color.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>IndexError</code> <p>If the color name is not a standard color.</p> RETURNS DESCRIPTION <code>int</code> <p>Index of the provided color name.</p>"},{"location":"api-guide/reports.html","title":"Reports","text":"<p>Note</p> <p>Report endpoints are not cached locally.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody","title":"toggl_api.reports.ReportBody  <code>dataclass</code>","text":"<p>               Bases: <code>BaseBody</code></p> <p>Body for summary endpoint which turns into a JSON body.</p> METHOD DESCRIPTION <code>format</code> <p>Format a body into the correct values types.</p> ATTRIBUTE DESCRIPTION <code>start_date</code> <p>Start date, example time.DateOnly. Should be less than End date.</p> <p> TYPE: <code>date | None</code> </p> <code>end_date</code> <p>End date, example time. DateOnly. Should be greater than Start date.</p> <p> TYPE: <code>date | None</code> </p> <code>client_ids</code> <p>Client IDs, optional, filtering attribute. To filter records with no clients, use [None].</p> <p> TYPE: <code>list[int | None]</code> </p> <code>description</code> <p>Description, optional, filtering attribute.</p> <p> TYPE: <code>str | None</code> </p> <code>group_ids</code> <p>Group IDs, optional, filtering attribute.</p> <p> TYPE: <code>list[int]</code> </p> <code>grouping</code> <p>Grouping option, optional.</p> <p> TYPE: <code>str | None</code> </p> <code>grouped</code> <p>Whether time entries should be grouped, optional, default false.</p> <p> TYPE: <code>bool</code> </p> <code>include_time_entry_ids</code> <p>Whether time entry IDs should be included in the results, optional, default true. Not applicable for export.</p> <p> TYPE: <code>bool</code> </p> <code>max_duration_seconds</code> <p>Max duration seconds, optional, filtering attribute. Time Audit only,</p> <p> TYPE: <code>int | None</code> </p> <code>min_duration_seconds</code> <p>Min duration seconds, optional, filtering attribute. Time Audit only,</p> <p> TYPE: <code>int | None</code> </p> <code>project_ids</code> <p>Project IDs, optional, filtering attribute. To filter records with no projects, use [None].</p> <p> TYPE: <code>list[int | None]</code> </p> <code>rounding</code> <p>Whether time should be rounded, optional, default from user preferences.</p> <p> TYPE: <code>int | None</code> </p> <code>rounding_minutes</code> <p>Rounding minutes value, optional, default from user preferences.</p> <p> TYPE: <code>Literal[0, 1, 5, 6, 10, 12, 15, 30, 60, 240] | None</code> </p> <code>sub_grouping</code> <p>SubGrouping option, optional.</p> <p> TYPE: <code>str | None</code> </p> <code>tag_ids</code> <p>Tag IDs, optional, filtering attribute. To filter records with no tags, use [None].</p> <p> TYPE: <code>list[int | None]</code> </p> <code>time_entry_ids</code> <p>TimeEntryIDs filters by time entries.</p> <p> TYPE: <code>list[int]</code> </p> <code>user_ids</code> <p>User IDs, optional, filtering attribute.</p> <p> TYPE: <code>list[int]</code> </p> <code>date_format</code> <p>Date format, optional, default 'YYYY-MM-DD'.</p> <p> TYPE: <code>Literal['MM/DD/YYYY', 'DD-MM-YYYY', 'MM-DD-YYYY', 'YYYY-MM-DD', 'DD/MM/YYYY', 'DD.MM.YYYY']</code> </p> <code>duration_format</code> <p>Duration format, optional, default \"classic\". Can be \"classic\", \"decimal\" or \"improved\".</p> <p> TYPE: <code>Literal['classic', 'decimal', 'improved']</code> </p> <code>order_by</code> <p>Order by option, optional, default title. Can be title or duration.</p> <p> TYPE: <code>Literal['title', 'duration'] | None</code> </p> <code>order_dir</code> <p>Order direction, optional. Can be ASC or DESC.</p> <p> TYPE: <code>Literal['ASC', 'DESC'] | None</code> </p> <code>resolution</code> <p>Graph resolution, optional. Allow clients to explicitly request a resolution.</p> <p> TYPE: <code>str | None</code> </p> <code>enrich_response</code> <p>It will force the detailed report to return as much information as possible, as it does for the export.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>@dataclass\nclass ReportBody(BaseBody):\n    \"\"\"Body for summary endpoint which turns into a JSON body.\"\"\"\n\n    start_date: date | None = field(default=None)\n    \"\"\"Start date, example time.DateOnly. Should be less than End date.\"\"\"\n\n    end_date: date | None = field(default=None)\n    \"\"\"End date, example time. DateOnly. Should be greater than Start date.\"\"\"\n\n    client_ids: list[int | None] = field(default_factory=list)\n    \"\"\"Client IDs, optional, filtering attribute. To filter records with no clients, use [None].\"\"\"\n\n    description: str | None = field(default=None)\n    \"\"\"Description, optional, filtering attribute.\"\"\"\n\n    group_ids: list[int] = field(default_factory=list)\n    \"\"\"Group IDs, optional, filtering attribute.\"\"\"\n\n    grouping: str | None = field(\n        default=None,\n        metadata={\n            \"endpoints\": frozenset(\n                (\n                    \"summary_time_entries\",\n                    \"summary_report_pdf\",\n                    \"summary_report_csv\",\n                ),\n            ),\n        },\n    )\n    \"\"\"Grouping option, optional.\"\"\"\n\n    grouped: bool = field(\n        default=False,\n        metadata={\n            \"endpoints\": frozenset(\n                (\n                    \"detail_search_time\",\n                    \"detail_report_pdf\",\n                    \"detail_report_csv\",\n                    \"detail_totals\",\n                ),\n            ),\n        },\n    )\n    \"\"\"Whether time entries should be grouped, optional, default false.\"\"\"\n\n    include_time_entry_ids: bool = field(\n        default=True,  # NOTE: API default is False. Wrapper sets it as True.\n        metadata={\n            \"endpoints\": frozenset(\n                (\n                    \"summary_time_entries\",\n                    \"summary_report_pdf\",\n                    \"summary_report_csv\",\n                ),\n            ),\n        },\n    )\n    \"\"\"Whether time entry IDs should be included in the results, optional, default true. Not applicable for export.\"\"\"\n\n    max_duration_seconds: int | None = field(default=None)\n    \"\"\"Max duration seconds, optional, filtering attribute. Time Audit only,\n    should be greater than min_duration_seconds.\"\"\"\n\n    min_duration_seconds: int | None = field(default=None)\n    \"\"\"Min duration seconds, optional, filtering attribute. Time Audit only,\n    should be less than max_duration_seconds.\"\"\"\n\n    project_ids: list[int | None] = field(default_factory=list)\n    \"\"\"Project IDs, optional, filtering attribute. To filter records with no projects, use [None].\"\"\"\n\n    rounding: int | None = field(default=None)\n    \"\"\"Whether time should be rounded, optional, default from user preferences.\"\"\"\n\n    rounding_minutes: Literal[0, 1, 5, 6, 10, 12, 15, 30, 60, 240] | None = field(default=None)\n    \"\"\"Rounding minutes value, optional, default from user preferences.\n    Should be 0, 1, 5, 6, 10, 12, 15, 30, 60 or 240.\"\"\"\n\n    sub_grouping: str | None = field(\n        default=None,\n        metadata={\n            \"endpoints\": frozenset(\n                (\n                    \"summary_time_entries\",\n                    \"summary_report_pdf\",\n                    \"summary_report_csv\",\n                ),\n            ),\n        },\n    )\n    \"\"\"SubGrouping option, optional.\"\"\"\n\n    tag_ids: list[int | None] = field(default_factory=list)\n    \"\"\"Tag IDs, optional, filtering attribute. To filter records with no tags, use [None].\"\"\"\n\n    time_entry_ids: list[int] = field(default_factory=list)\n    \"\"\"TimeEntryIDs filters by time entries.\"\"\"\n\n    user_ids: list[int] = field(default_factory=list)\n    \"\"\"User IDs, optional, filtering attribute.\"\"\"\n\n    date_format: Literal[\n        \"MM/DD/YYYY\",\n        \"DD-MM-YYYY\",\n        \"MM-DD-YYYY\",\n        \"YYYY-MM-DD\",\n        \"DD/MM/YYYY\",\n        \"DD.MM.YYYY\",\n    ] = field(\n        default=\"YYYY-MM-DD\",  # NOTE: API Default is 'MM/DD/YYYY'\n        metadata={\n            \"endpoints\": frozenset(\n                (\n                    \"summary_report_pdf\",\n                    \"detail_report_pdf\",\n                    \"weekly_report_pdf\",\n                ),\n            ),\n        },\n    )\n    \"\"\"Date format, optional, default 'YYYY-MM-DD'.\"\"\"\n\n    duration_format: Literal[\"classic\", \"decimal\", \"improved\"] = field(\n        default=\"classic\",\n        metadata={\n            \"endpoints\": frozenset(\n                (\n                    \"summary_report_pdf\",\n                    \"summary_report_csv\",\n                    \"detailed_report_pdf\",\n                    \"detailed_report_csv\",\n                    \"weekly_report_pdf\",\n                ),\n            ),\n        },\n    )\n    \"\"\"Duration format, optional, default \"classic\". Can be \"classic\", \"decimal\" or \"improved\".\"\"\"\n\n    order_by: Literal[\"title\", \"duration\"] | None = field(\n        default=None,\n        metadata={\n            \"endpoints\": frozenset(\n                (\n                    \"summary_report_pdf\",\n                    \"summary_report_csv\",\n                    \"detail_search_time\",\n                    \"detail_report_pdf\",\n                    \"detail_report_csv\",\n                ),\n            ),\n        },\n    )\n    \"\"\"Order by option, optional, default title. Can be title or duration.\"\"\"\n\n    order_dir: Literal[\"ASC\", \"DESC\"] | None = field(\n        default=None,\n        metadata={\n            \"endpoints\": frozenset(\n                (\n                    \"summary_report_pdf\",\n                    \"summary_report_csv\",\n                    \"detail_search_time\",\n                    \"detail_report_pdf\",\n                    \"detail_report_csv\",\n                ),\n            ),\n        },\n    )\n    \"\"\"Order direction, optional. Can be ASC or DESC.\"\"\"\n\n    resolution: str | None = field(\n        default=None,\n        metadata={\n            \"endpoints\": frozenset(\n                (\n                    \"summary_report_pdf\",\n                    \"detail_totals\",\n                ),\n            ),\n        },\n    )\n    \"\"\"Graph resolution, optional. Allow clients to explicitly request a resolution.\"\"\"\n\n    enrich_response: bool = field(\n        default=False,\n        metadata={\n            \"endpoints\": frozenset(\n                (\n                    \"detail_search_time\",\n                    \"detail_report\",\n                ),\n            ),\n        },\n    )\n    \"\"\"It will force the detailed report to return as much information as possible, as it does for the export.\"\"\"\n\n    def format(self, endpoint: str, **body: Any) -&gt; dict[str, Any]:\n        \"\"\"Format a body into the correct values types.\n\n        Args:\n            endpoint: The name of the endpoint for filtering.\n            body: Body pre-filled with miscellanous values:\n\n        Raises:\n            DateTimeError: If the start date is after the end date.\n\n        Returns:\n            Dictionary of formatted values.\n        \"\"\"\n        body.update(\n            {\n                \"client_ids\": self.client_ids,\n                \"project_ids\": self.project_ids,\n                \"tag_ids\": self.tag_ids,\n                \"time_entry_ids\": self.time_entry_ids,\n                \"user_ids\": self.user_ids,\n            },\n        )\n\n        if self.start_date:\n            body[\"start_date\"] = format_iso(self.start_date)\n            if self.end_date is not None and self.start_date &gt; self.end_date:\n                msg = \"Start date needs to be on or before the end date!\"\n                raise DateTimeError(msg)\n\n        if self.end_date:\n            body[\"end_date\"] = format_iso(self.end_date)\n\n        if self._verify_endpoint_parameter(\"date_format\", endpoint):\n            body[\"date_format\"] = self.date_format\n\n        if self._verify_endpoint_parameter(\"duration_format\", endpoint):\n            body[\"duration_format\"] = self.duration_format\n\n        if self.include_time_entry_ids and self._verify_endpoint_parameter(\"include_time_entry_ids\", endpoint):\n            body[\"include_time_entry_ids\"] = self.include_time_entry_ids\n\n        if self.description is not None:\n            body[\"description\"] = self.description\n\n        if self.group_ids:\n            body[\"group_ids\"] = self.group_ids\n\n        if self.grouping and self._verify_endpoint_parameter(\"grouping\", endpoint):\n            body[\"grouping\"] = self.grouping\n\n        if self.grouped and self._verify_endpoint_parameter(\"grouped\", endpoint):\n            body[\"grouped\"] = self.grouped\n\n        if isinstance(self.max_duration_seconds, int):\n            body[\"max_duration_seconds\"] = self.max_duration_seconds\n\n        if isinstance(self.min_duration_seconds, int):\n            body[\"min_duration_seconds\"] = self.min_duration_seconds\n\n        if isinstance(self.rounding, int):\n            body[\"rounding\"] = self.rounding\n\n        if isinstance(self.rounding_minutes, int):\n            body[\"rounding_minutes\"] = self.rounding_minutes\n\n        if self.sub_grouping is not None and self._verify_endpoint_parameter(\"sub_grouping\", endpoint):\n            body[\"sub_grouping\"] = self.sub_grouping\n\n        if self.order_by is not None and self._verify_endpoint_parameter(\"order_by\", endpoint):\n            body[\"order_by\"] = self.order_by\n\n        if self.order_dir is not None and self._verify_endpoint_parameter(\"order_dir\", endpoint):\n            body[\"order_dir\"] = self.order_dir\n\n        if self.resolution is not None and self._verify_endpoint_parameter(\"resolution\", endpoint):\n            body[\"resolution\"] = self.resolution\n\n        if self.enrich_response and self._verify_endpoint_parameter(\"enrich_response\", endpoint):\n            body[\"enrich_response\"] = self.enrich_response\n\n        return body\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.start_date","title":"start_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start_date: date | None = field(default=None)\n</code></pre> <p>Start date, example time.DateOnly. Should be less than End date.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.end_date","title":"end_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_date: date | None = field(default=None)\n</code></pre> <p>End date, example time. DateOnly. Should be greater than Start date.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.client_ids","title":"client_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client_ids: list[int | None] = field(default_factory=list)\n</code></pre> <p>Client IDs, optional, filtering attribute. To filter records with no clients, use [None].</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = field(default=None)\n</code></pre> <p>Description, optional, filtering attribute.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.group_ids","title":"group_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group_ids: list[int] = field(default_factory=list)\n</code></pre> <p>Group IDs, optional, filtering attribute.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.grouping","title":"grouping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grouping: str | None = field(\n    default=None,\n    metadata={\n        \"endpoints\": frozenset(\n            (\n                \"summary_time_entries\",\n                \"summary_report_pdf\",\n                \"summary_report_csv\",\n            )\n        )\n    },\n)\n</code></pre> <p>Grouping option, optional.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.grouped","title":"grouped  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grouped: bool = field(\n    default=False,\n    metadata={\n        \"endpoints\": frozenset(\n            (\n                \"detail_search_time\",\n                \"detail_report_pdf\",\n                \"detail_report_csv\",\n                \"detail_totals\",\n            )\n        )\n    },\n)\n</code></pre> <p>Whether time entries should be grouped, optional, default false.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.include_time_entry_ids","title":"include_time_entry_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>include_time_entry_ids: bool = field(\n    default=True,\n    metadata={\n        \"endpoints\": frozenset(\n            (\n                \"summary_time_entries\",\n                \"summary_report_pdf\",\n                \"summary_report_csv\",\n            )\n        )\n    },\n)\n</code></pre> <p>Whether time entry IDs should be included in the results, optional, default true. Not applicable for export.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.max_duration_seconds","title":"max_duration_seconds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_duration_seconds: int | None = field(default=None)\n</code></pre> <p>Max duration seconds, optional, filtering attribute. Time Audit only, should be greater than min_duration_seconds.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.min_duration_seconds","title":"min_duration_seconds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min_duration_seconds: int | None = field(default=None)\n</code></pre> <p>Min duration seconds, optional, filtering attribute. Time Audit only, should be less than max_duration_seconds.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.project_ids","title":"project_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>project_ids: list[int | None] = field(default_factory=list)\n</code></pre> <p>Project IDs, optional, filtering attribute. To filter records with no projects, use [None].</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.rounding","title":"rounding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rounding: int | None = field(default=None)\n</code></pre> <p>Whether time should be rounded, optional, default from user preferences.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.rounding_minutes","title":"rounding_minutes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rounding_minutes: Literal[0, 1, 5, 6, 10, 12, 15, 30, 60, 240] | None = field(\n    default=None\n)\n</code></pre> <p>Rounding minutes value, optional, default from user preferences. Should be 0, 1, 5, 6, 10, 12, 15, 30, 60 or 240.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.sub_grouping","title":"sub_grouping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sub_grouping: str | None = field(\n    default=None,\n    metadata={\n        \"endpoints\": frozenset(\n            (\n                \"summary_time_entries\",\n                \"summary_report_pdf\",\n                \"summary_report_csv\",\n            )\n        )\n    },\n)\n</code></pre> <p>SubGrouping option, optional.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.tag_ids","title":"tag_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_ids: list[int | None] = field(default_factory=list)\n</code></pre> <p>Tag IDs, optional, filtering attribute. To filter records with no tags, use [None].</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.time_entry_ids","title":"time_entry_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>time_entry_ids: list[int] = field(default_factory=list)\n</code></pre> <p>TimeEntryIDs filters by time entries.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.user_ids","title":"user_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_ids: list[int] = field(default_factory=list)\n</code></pre> <p>User IDs, optional, filtering attribute.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.date_format","title":"date_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date_format: Literal[\n    \"MM/DD/YYYY\",\n    \"DD-MM-YYYY\",\n    \"MM-DD-YYYY\",\n    \"YYYY-MM-DD\",\n    \"DD/MM/YYYY\",\n    \"DD.MM.YYYY\",\n] = field(\n    default=\"YYYY-MM-DD\",\n    metadata={\n        \"endpoints\": frozenset(\n            (\"summary_report_pdf\", \"detail_report_pdf\", \"weekly_report_pdf\")\n        )\n    },\n)\n</code></pre> <p>Date format, optional, default 'YYYY-MM-DD'.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.duration_format","title":"duration_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>duration_format: Literal[\"classic\", \"decimal\", \"improved\"] = field(\n    default=\"classic\",\n    metadata={\n        \"endpoints\": frozenset(\n            (\n                \"summary_report_pdf\",\n                \"summary_report_csv\",\n                \"detailed_report_pdf\",\n                \"detailed_report_csv\",\n                \"weekly_report_pdf\",\n            )\n        )\n    },\n)\n</code></pre> <p>Duration format, optional, default \"classic\". Can be \"classic\", \"decimal\" or \"improved\".</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.order_by","title":"order_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>order_by: Literal[\"title\", \"duration\"] | None = field(\n    default=None,\n    metadata={\n        \"endpoints\": frozenset(\n            (\n                \"summary_report_pdf\",\n                \"summary_report_csv\",\n                \"detail_search_time\",\n                \"detail_report_pdf\",\n                \"detail_report_csv\",\n            )\n        )\n    },\n)\n</code></pre> <p>Order by option, optional, default title. Can be title or duration.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.order_dir","title":"order_dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>order_dir: Literal[\"ASC\", \"DESC\"] | None = field(\n    default=None,\n    metadata={\n        \"endpoints\": frozenset(\n            (\n                \"summary_report_pdf\",\n                \"summary_report_csv\",\n                \"detail_search_time\",\n                \"detail_report_pdf\",\n                \"detail_report_csv\",\n            )\n        )\n    },\n)\n</code></pre> <p>Order direction, optional. Can be ASC or DESC.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.resolution","title":"resolution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resolution: str | None = field(\n    default=None,\n    metadata={\"endpoints\": frozenset((\"summary_report_pdf\", \"detail_totals\"))},\n)\n</code></pre> <p>Graph resolution, optional. Allow clients to explicitly request a resolution.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.enrich_response","title":"enrich_response  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enrich_response: bool = field(\n    default=False,\n    metadata={\"endpoints\": frozenset((\"detail_search_time\", \"detail_report\"))},\n)\n</code></pre> <p>It will force the detailed report to return as much information as possible, as it does for the export.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportBody.format","title":"format","text":"<pre><code>format(endpoint: str, **body: Any) -&gt; dict[str, Any]\n</code></pre> <p>Format a body into the correct values types.</p> PARAMETER DESCRIPTION <code>endpoint</code> <p>The name of the endpoint for filtering.</p> <p> TYPE: <code>str</code> </p> <code>body</code> <p>Body pre-filled with miscellanous values:</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>DateTimeError</code> <p>If the start date is after the end date.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dictionary of formatted values.</p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>def format(self, endpoint: str, **body: Any) -&gt; dict[str, Any]:\n    \"\"\"Format a body into the correct values types.\n\n    Args:\n        endpoint: The name of the endpoint for filtering.\n        body: Body pre-filled with miscellanous values:\n\n    Raises:\n        DateTimeError: If the start date is after the end date.\n\n    Returns:\n        Dictionary of formatted values.\n    \"\"\"\n    body.update(\n        {\n            \"client_ids\": self.client_ids,\n            \"project_ids\": self.project_ids,\n            \"tag_ids\": self.tag_ids,\n            \"time_entry_ids\": self.time_entry_ids,\n            \"user_ids\": self.user_ids,\n        },\n    )\n\n    if self.start_date:\n        body[\"start_date\"] = format_iso(self.start_date)\n        if self.end_date is not None and self.start_date &gt; self.end_date:\n            msg = \"Start date needs to be on or before the end date!\"\n            raise DateTimeError(msg)\n\n    if self.end_date:\n        body[\"end_date\"] = format_iso(self.end_date)\n\n    if self._verify_endpoint_parameter(\"date_format\", endpoint):\n        body[\"date_format\"] = self.date_format\n\n    if self._verify_endpoint_parameter(\"duration_format\", endpoint):\n        body[\"duration_format\"] = self.duration_format\n\n    if self.include_time_entry_ids and self._verify_endpoint_parameter(\"include_time_entry_ids\", endpoint):\n        body[\"include_time_entry_ids\"] = self.include_time_entry_ids\n\n    if self.description is not None:\n        body[\"description\"] = self.description\n\n    if self.group_ids:\n        body[\"group_ids\"] = self.group_ids\n\n    if self.grouping and self._verify_endpoint_parameter(\"grouping\", endpoint):\n        body[\"grouping\"] = self.grouping\n\n    if self.grouped and self._verify_endpoint_parameter(\"grouped\", endpoint):\n        body[\"grouped\"] = self.grouped\n\n    if isinstance(self.max_duration_seconds, int):\n        body[\"max_duration_seconds\"] = self.max_duration_seconds\n\n    if isinstance(self.min_duration_seconds, int):\n        body[\"min_duration_seconds\"] = self.min_duration_seconds\n\n    if isinstance(self.rounding, int):\n        body[\"rounding\"] = self.rounding\n\n    if isinstance(self.rounding_minutes, int):\n        body[\"rounding_minutes\"] = self.rounding_minutes\n\n    if self.sub_grouping is not None and self._verify_endpoint_parameter(\"sub_grouping\", endpoint):\n        body[\"sub_grouping\"] = self.sub_grouping\n\n    if self.order_by is not None and self._verify_endpoint_parameter(\"order_by\", endpoint):\n        body[\"order_by\"] = self.order_by\n\n    if self.order_dir is not None and self._verify_endpoint_parameter(\"order_dir\", endpoint):\n        body[\"order_dir\"] = self.order_dir\n\n    if self.resolution is not None and self._verify_endpoint_parameter(\"resolution\", endpoint):\n        body[\"resolution\"] = self.resolution\n\n    if self.enrich_response and self._verify_endpoint_parameter(\"enrich_response\", endpoint):\n        body[\"enrich_response\"] = self.enrich_response\n\n    return body\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportEndpoint","title":"toggl_api.reports.ReportEndpoint","text":"<p>               Bases: <code>TogglEndpoint[Any]</code></p> <p>Abstract baseclass for the reports endpoint that overrides BASE_ENDPOINT.</p> METHOD DESCRIPTION <code>search_time_entries</code> <p>Search for time entries for the given report endpoint.</p> <code>export_report</code> <p>Export a report for the given report endpoint.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportEndpoint.search_time_entries","title":"search_time_entries  <code>abstractmethod</code>","text":"<pre><code>search_time_entries(body: ReportBody, *args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Search for time entries for the given report endpoint.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.ReportEndpoint.export_report","title":"export_report  <code>abstractmethod</code>","text":"<pre><code>export_report(body: ReportBody, *args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Export a report for the given report endpoint.</p>"},{"location":"api-guide/reports.html#toggl_api.asyncio.AsyncReportEndpoint","title":"toggl_api.asyncio.AsyncReportEndpoint","text":"<p>               Bases: <code>TogglAsyncEndpoint[Any]</code></p> <p>Abstract baseclass for the async report endpoints that overrides BASE_ENDPOINT.</p>"},{"location":"api-guide/reports.html#summary-reports","title":"Summary Reports","text":""},{"location":"api-guide/reports.html#toggl_api.reports.SummaryReportEndpoint","title":"toggl_api.reports.SummaryReportEndpoint","text":"<p>               Bases: <code>ReportEndpoint</code></p> <p>Summary reports endpoints.</p> <p>Official Documentation</p> METHOD DESCRIPTION <code>project_summary</code> <p>Return a specific projects summary within the parameters provided.</p> <code>project_summaries</code> <p>Return a summary of user projects according to parameters provided.</p> <code>search_time_entries</code> <p>Return a list of time entries within the parameters specified.</p> <code>export_report</code> <p>Download summary report in the specified in the specified format: csv or pdf.</p> ATTRIBUTE DESCRIPTION <code>endpoint</code> <p>Summary report endpoint url parameters.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>class SummaryReportEndpoint(ReportEndpoint):\n    \"\"\"Summary reports endpoints.\n\n    [Official Documentation](https://engineering.toggl.com/docs/reports/summary_reports)\n    \"\"\"\n\n    def project_summary(\n        self,\n        project: TogglProject | int,\n        start_date: date | str,\n        end_date: date | str,\n    ) -&gt; dict[str, int]:\n        \"\"\"Return a specific projects summary within the parameters provided.\n\n        [Official Documentation](https://engineering.toggl.com/docs/reports/summary_reports#post-load-project-summary)\n\n        Args:\n            project: Project to retrieve summaries about.\n            start_date: The date to gather project summary data from.\n            end_date: The date to gather project summary data to.\n\n        Returns:\n            A list of dictionary with the summary data.\n        \"\"\"\n        return cast(\n            \"dict[str, int]\",\n            self.request(\n                f\"{self.endpoint}/projects/{project.id if isinstance(project, TogglProject) else project}/summary\",\n                method=RequestMethod.POST,\n                body={\n                    \"start_date\": format_iso(start_date),\n                    \"end_date\": format_iso(end_date),\n                },\n            ),\n        )\n\n    def project_summaries(\n        self,\n        start_date: date | str,\n        end_date: date | str,\n    ) -&gt; list[dict[str, int]]:\n        \"\"\"Return a summary of user projects according to parameters provided.\n\n        [Official Documentation](https://engineering.toggl.com/docs/reports/summary_reports#post-list-project-users)\n\n        Args:\n            start_date: The date to gather project summaries from.\n            end_date: The date to gather project summaries data to.\n\n        Returns:\n            A list of dictionary with the summary data.\n        \"\"\"\n        return cast(\n            \"list[dict[str, int]]\",\n            self.request(\n                f\"{self.endpoint}/projects/summary\",\n                method=RequestMethod.POST,\n                body={\n                    \"start_date\": format_iso(start_date),\n                    \"end_date\": format_iso(end_date),\n                },\n            ),\n        )\n\n    def search_time_entries(self, body: ReportBody) -&gt; list[dict[str, int]]:\n        \"\"\"Return a list of time entries within the parameters specified.\n\n        [Official Documentation](https://engineering.toggl.com/docs/reports/summary_reports#post-search-time-entries)\n\n        Args:\n            body: Body parameters to filter time entries by.\n\n        Returns:\n            A list of dictionaries with the filtered tracker data.\n        \"\"\"\n        return cast(\n            \"list[dict[str, int]]\",\n            self.request(\n                f\"{self.endpoint}/summary/time_entries\",\n                method=RequestMethod.POST,\n                body=body.format(\n                    \"summary_time_entries\",\n                    workspace_id=self.workspace_id,\n                ),\n            ),\n        )\n\n    def export_report(\n        self,\n        body: ReportBody,\n        extension: ReportFormats,\n        *,\n        collapse: bool = False,\n    ) -&gt; bytes:\n        \"\"\"Download summary report in the specified in the specified format: csv or pdf.\n\n        [Official Documentation](https://engineering.toggl.com/docs/reports/summary_reports#post-export-summary-report)\n\n        Args:\n            body: Body parameters to filter the report by.\n            extension: What format to use for the report. CSV or PDF.\n            collapse: Whether collapse others. Inserted into body.\n\n        Raises:\n            InvalidExtensionError: If extension is not pdf or csv.\n\n        Returns:\n            A format ready to be saved as a file or used for further processing.\n        \"\"\"\n        _validate_extension(extension)\n\n        return cast(\n            \"Response\",\n            self.request(\n                f\"{self.endpoint}/summary/time_entries.{extension}\",\n                method=RequestMethod.POST,\n                body=body.format(\n                    f\"summary_report_{extension}\",\n                    workspace_id=self.workspace_id,\n                    collapse=collapse,\n                ),\n                raw=True,\n            ),\n        ).content\n\n    @property\n    def endpoint(self) -&gt; str:\n        \"\"\"Summary report endpoint url parameters.\"\"\"\n        return f\"workspace/{self.workspace_id}\"\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.SummaryReportEndpoint.endpoint","title":"endpoint  <code>property</code>","text":"<pre><code>endpoint: str\n</code></pre> <p>Summary report endpoint url parameters.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.SummaryReportEndpoint.project_summary","title":"project_summary","text":"<pre><code>project_summary(\n    project: TogglProject | int, start_date: date | str, end_date: date | str\n) -&gt; dict[str, int]\n</code></pre> <p>Return a specific projects summary within the parameters provided.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>project</code> <p>Project to retrieve summaries about.</p> <p> TYPE: <code>TogglProject | int</code> </p> <code>start_date</code> <p>The date to gather project summary data from.</p> <p> TYPE: <code>date | str</code> </p> <code>end_date</code> <p>The date to gather project summary data to.</p> <p> TYPE: <code>date | str</code> </p> RETURNS DESCRIPTION <code>dict[str, int]</code> <p>A list of dictionary with the summary data.</p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>def project_summary(\n    self,\n    project: TogglProject | int,\n    start_date: date | str,\n    end_date: date | str,\n) -&gt; dict[str, int]:\n    \"\"\"Return a specific projects summary within the parameters provided.\n\n    [Official Documentation](https://engineering.toggl.com/docs/reports/summary_reports#post-load-project-summary)\n\n    Args:\n        project: Project to retrieve summaries about.\n        start_date: The date to gather project summary data from.\n        end_date: The date to gather project summary data to.\n\n    Returns:\n        A list of dictionary with the summary data.\n    \"\"\"\n    return cast(\n        \"dict[str, int]\",\n        self.request(\n            f\"{self.endpoint}/projects/{project.id if isinstance(project, TogglProject) else project}/summary\",\n            method=RequestMethod.POST,\n            body={\n                \"start_date\": format_iso(start_date),\n                \"end_date\": format_iso(end_date),\n            },\n        ),\n    )\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.SummaryReportEndpoint.project_summaries","title":"project_summaries","text":"<pre><code>project_summaries(\n    start_date: date | str, end_date: date | str\n) -&gt; list[dict[str, int]]\n</code></pre> <p>Return a summary of user projects according to parameters provided.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>start_date</code> <p>The date to gather project summaries from.</p> <p> TYPE: <code>date | str</code> </p> <code>end_date</code> <p>The date to gather project summaries data to.</p> <p> TYPE: <code>date | str</code> </p> RETURNS DESCRIPTION <code>list[dict[str, int]]</code> <p>A list of dictionary with the summary data.</p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>def project_summaries(\n    self,\n    start_date: date | str,\n    end_date: date | str,\n) -&gt; list[dict[str, int]]:\n    \"\"\"Return a summary of user projects according to parameters provided.\n\n    [Official Documentation](https://engineering.toggl.com/docs/reports/summary_reports#post-list-project-users)\n\n    Args:\n        start_date: The date to gather project summaries from.\n        end_date: The date to gather project summaries data to.\n\n    Returns:\n        A list of dictionary with the summary data.\n    \"\"\"\n    return cast(\n        \"list[dict[str, int]]\",\n        self.request(\n            f\"{self.endpoint}/projects/summary\",\n            method=RequestMethod.POST,\n            body={\n                \"start_date\": format_iso(start_date),\n                \"end_date\": format_iso(end_date),\n            },\n        ),\n    )\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.SummaryReportEndpoint.search_time_entries","title":"search_time_entries","text":"<pre><code>search_time_entries(body: ReportBody) -&gt; list[dict[str, int]]\n</code></pre> <p>Return a list of time entries within the parameters specified.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>Body parameters to filter time entries by.</p> <p> TYPE: <code>ReportBody</code> </p> RETURNS DESCRIPTION <code>list[dict[str, int]]</code> <p>A list of dictionaries with the filtered tracker data.</p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>def search_time_entries(self, body: ReportBody) -&gt; list[dict[str, int]]:\n    \"\"\"Return a list of time entries within the parameters specified.\n\n    [Official Documentation](https://engineering.toggl.com/docs/reports/summary_reports#post-search-time-entries)\n\n    Args:\n        body: Body parameters to filter time entries by.\n\n    Returns:\n        A list of dictionaries with the filtered tracker data.\n    \"\"\"\n    return cast(\n        \"list[dict[str, int]]\",\n        self.request(\n            f\"{self.endpoint}/summary/time_entries\",\n            method=RequestMethod.POST,\n            body=body.format(\n                \"summary_time_entries\",\n                workspace_id=self.workspace_id,\n            ),\n        ),\n    )\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.SummaryReportEndpoint.export_report","title":"export_report","text":"<pre><code>export_report(\n    body: ReportBody, extension: ReportFormats, *, collapse: bool = False\n) -&gt; bytes\n</code></pre> <p>Download summary report in the specified in the specified format: csv or pdf.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>Body parameters to filter the report by.</p> <p> TYPE: <code>ReportBody</code> </p> <code>extension</code> <p>What format to use for the report. CSV or PDF.</p> <p> TYPE: <code>ReportFormats</code> </p> <code>collapse</code> <p>Whether collapse others. Inserted into body.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>InvalidExtensionError</code> <p>If extension is not pdf or csv.</p> RETURNS DESCRIPTION <code>bytes</code> <p>A format ready to be saved as a file or used for further processing.</p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>def export_report(\n    self,\n    body: ReportBody,\n    extension: ReportFormats,\n    *,\n    collapse: bool = False,\n) -&gt; bytes:\n    \"\"\"Download summary report in the specified in the specified format: csv or pdf.\n\n    [Official Documentation](https://engineering.toggl.com/docs/reports/summary_reports#post-export-summary-report)\n\n    Args:\n        body: Body parameters to filter the report by.\n        extension: What format to use for the report. CSV or PDF.\n        collapse: Whether collapse others. Inserted into body.\n\n    Raises:\n        InvalidExtensionError: If extension is not pdf or csv.\n\n    Returns:\n        A format ready to be saved as a file or used for further processing.\n    \"\"\"\n    _validate_extension(extension)\n\n    return cast(\n        \"Response\",\n        self.request(\n            f\"{self.endpoint}/summary/time_entries.{extension}\",\n            method=RequestMethod.POST,\n            body=body.format(\n                f\"summary_report_{extension}\",\n                workspace_id=self.workspace_id,\n                collapse=collapse,\n            ),\n            raw=True,\n        ),\n    ).content\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.asyncio.AsyncSummaryReportEndpoint","title":"toggl_api.asyncio.AsyncSummaryReportEndpoint","text":"<p>               Bases: <code>AsyncReportEndpoint</code></p> <p>Summary reports endpoints.</p> <p>Official Documentation</p> METHOD DESCRIPTION <code>project_summary</code> <p>Return a specific projects summary within the parameters provided.</p> <code>project_summaries</code> <p>Return a summary of user projects according to parameters provided.</p> <code>search_time_entries</code> <p>Return a list of time entries within the parameters specified.</p> <code>export_report</code> <p>Download summary report in the specified in the specified format: csv or pdf.</p>"},{"location":"api-guide/reports.html#toggl_api.asyncio.AsyncSummaryReportEndpoint.project_summary","title":"project_summary  <code>async</code>","text":"<pre><code>project_summary(\n    project: TogglProject | int, start_date: date | str, end_date: date | str\n) -&gt; dict[str, int]\n</code></pre> <p>Return a specific projects summary within the parameters provided.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>project</code> <p>Project to retrieve summaries about.</p> <p> TYPE: <code>TogglProject | int</code> </p> <code>start_date</code> <p>The date to gather project summary data from.</p> <p> TYPE: <code>date | str</code> </p> <code>end_date</code> <p>The date to gather project summary data to.</p> <p> TYPE: <code>date | str</code> </p> RETURNS DESCRIPTION <code>dict[str, int]</code> <p>A list of dictionary with the summary data.</p>"},{"location":"api-guide/reports.html#toggl_api.asyncio.AsyncSummaryReportEndpoint.project_summaries","title":"project_summaries  <code>async</code>","text":"<pre><code>project_summaries(\n    start_date: date | str, end_date: date | str\n) -&gt; list[dict[str, int]]\n</code></pre> <p>Return a summary of user projects according to parameters provided.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>start_date</code> <p>The date to gather project summaries from.</p> <p> TYPE: <code>date | str</code> </p> <code>end_date</code> <p>The date to gather project summaries data to.</p> <p> TYPE: <code>date | str</code> </p> RETURNS DESCRIPTION <code>list[dict[str, int]]</code> <p>A list of dictionary with the summary data.</p>"},{"location":"api-guide/reports.html#toggl_api.asyncio.AsyncSummaryReportEndpoint.search_time_entries","title":"search_time_entries  <code>async</code>","text":"<pre><code>search_time_entries(body: ReportBody) -&gt; list[dict[str, int]]\n</code></pre> <p>Return a list of time entries within the parameters specified.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>Body parameters to filter time entries by.</p> <p> TYPE: <code>ReportBody</code> </p> RETURNS DESCRIPTION <code>list[dict[str, int]]</code> <p>A list of dictionaries with the filtered tracker data.</p>"},{"location":"api-guide/reports.html#toggl_api.asyncio.AsyncSummaryReportEndpoint.export_report","title":"export_report  <code>async</code>","text":"<pre><code>export_report(\n    body: ReportBody, extension: ReportFormats, *, collapse: bool = False\n) -&gt; bytes\n</code></pre> <p>Download summary report in the specified in the specified format: csv or pdf.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>Body parameters to filter the report by.</p> <p> TYPE: <code>ReportBody</code> </p> <code>extension</code> <p>What format to use for the report. CSV or PDF.</p> <p> TYPE: <code>ReportFormats</code> </p> <code>collapse</code> <p>Whether collapse others. Inserted into body.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>InvalidExtensionError</code> <p>If extension is not pdf or csv.</p> RETURNS DESCRIPTION <code>bytes</code> <p>A format ready to be saved as a file or used for further processing.</p>"},{"location":"api-guide/reports.html#detailed-reports","title":"Detailed Reports","text":""},{"location":"api-guide/reports.html#toggl_api.reports.PaginatedResult","title":"toggl_api.reports.PaginatedResult  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Generic dataclass for paginated results.</p> METHOD DESCRIPTION <code>__post_init__</code> <p>Post init method that converts any numeric values to actual ints.</p> <code>next_options</code> <p>Create the next options with a newly defined page size.</p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>@dataclass\nclass PaginatedResult(Generic[T]):\n    \"\"\"Generic dataclass for paginated results.\"\"\"\n\n    result: T = field()\n    next_id: int | None = field(default=None)\n    next_row: int | None = field(default=None)\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Post init method that converts any numeric values to actual ints.\"\"\"\n        # NOTE: Header types are strings so post init converts to integer.\n        if self.next_id:\n            self.next_id = int(self.next_id)\n        if self.next_row:\n            self.next_row = int(self.next_row)\n\n    def next_options(self, page_size: int = 50) -&gt; PaginationOptions:\n        \"\"\"Create the next options with a newly defined page size.\n\n        Args:\n            page_size: Override the page size.\n\n        Returns:\n            New pagination options for the next request.\n        \"\"\"\n        return PaginationOptions(page_size, self.next_id, self.next_row)\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.PaginatedResult.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post init method that converts any numeric values to actual ints.</p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Post init method that converts any numeric values to actual ints.\"\"\"\n    # NOTE: Header types are strings so post init converts to integer.\n    if self.next_id:\n        self.next_id = int(self.next_id)\n    if self.next_row:\n        self.next_row = int(self.next_row)\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.PaginatedResult.next_options","title":"next_options","text":"<pre><code>next_options(page_size: int = 50) -&gt; PaginationOptions\n</code></pre> <p>Create the next options with a newly defined page size.</p> PARAMETER DESCRIPTION <code>page_size</code> <p>Override the page size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>PaginationOptions</code> <p>New pagination options for the next request.</p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>def next_options(self, page_size: int = 50) -&gt; PaginationOptions:\n    \"\"\"Create the next options with a newly defined page size.\n\n    Args:\n        page_size: Override the page size.\n\n    Returns:\n        New pagination options for the next request.\n    \"\"\"\n    return PaginationOptions(page_size, self.next_id, self.next_row)\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.PaginationOptions","title":"toggl_api.reports.PaginationOptions  <code>dataclass</code>","text":"<p>Dataclass for paginate endpoints.</p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>@dataclass(frozen=True)\nclass PaginationOptions:\n    \"\"\"Dataclass for paginate endpoints.\"\"\"\n\n    page_size: int = field(default=50)\n    next_id: int | None = field(default=None)\n    next_row: int | None = field(default=None)\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.DetailedReportEndpoint","title":"toggl_api.reports.DetailedReportEndpoint","text":"<p>               Bases: <code>ReportEndpoint</code></p> <p>Detailed reports endpoint.</p> <p>Official Documentation</p> METHOD DESCRIPTION <code>search_time_entries</code> <p>Return time entries for detailed report according to the given filters.</p> <code>export_report</code> <p>Download detailed report in pdf or csv format.</p> <code>totals_report</code> <p>Return totals sums for detailed report.</p> ATTRIBUTE DESCRIPTION <code>endpoint</code> <p>Detailed report endpoint url parameters.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>class DetailedReportEndpoint(ReportEndpoint):\n    \"\"\"Detailed reports endpoint.\n\n    [Official Documentation](https://engineering.toggl.com/docs/reports/detailed_reports)\n    \"\"\"\n\n    @staticmethod\n    def _paginate(request: Response, *, raw: bool = False) -&gt; PaginatedResult[Any]:\n        return PaginatedResult(\n            request.content if raw else request.json(),\n            request.headers.get(\"x-next-id\"),\n            request.headers.get(\"x-next-row-number\"),\n        )\n\n    @staticmethod\n    def _paginate_body(\n        body: dict[str, Any],\n        pagination: PaginationOptions,\n    ) -&gt; dict[str, Any]:\n        body[\"page_size\"] = pagination.page_size\n        if pagination.next_id is not None and pagination.next_row is not None:\n            body[\"first_id\"] = pagination.next_id\n            body[\"first_row_number\"] = pagination.next_row\n\n        return body\n\n    def search_time_entries(\n        self,\n        body: ReportBody,\n        pagination: PaginationOptions | None = None,\n        *,\n        hide_amounts: bool = False,\n    ) -&gt; PaginatedResult[list[dict[str, Any]]]:\n        \"\"\"Return time entries for detailed report according to the given filters.\n\n        [Official Documentation](https://engineering.toggl.com/docs/reports/detailed_reports#post-search-time-entries)\n\n        Args:\n            body: JSON body with filters for time entries.\n            pagination: Pagination options containing page size, next_id and next_row.\n            hide_amounts: Whether amounts should be hidden.\n\n        Returns:\n            Data with pagination information if required.\n        \"\"\"\n        pagination = pagination or PaginationOptions()\n\n        request: Response = cast(\n            \"Response\",\n            self.request(\n                self.endpoint,\n                body=self._paginate_body(\n                    body.format(\n                        \"detail_search_time\",\n                        workspace_id=self.workspace_id,\n                        hide_amounts=hide_amounts,\n                    ),\n                    pagination,\n                ),\n                method=RequestMethod.POST,\n                raw=True,\n            ),\n        )\n\n        return self._paginate(request)\n\n    def export_report(\n        self,\n        body: ReportBody,\n        extension: ReportFormats,\n        pagination: PaginationOptions | None = None,\n        *,\n        hide_amounts: bool = False,\n    ) -&gt; PaginatedResult[bytes]:\n        \"\"\"Download detailed report in pdf or csv format.\n\n        [Official Documentation](https://engineering.toggl.com/docs/reports/detailed_reports#post-export-detailed-report)\n\n        Args:\n            body: JSON body for formatting and filtering the report.\n            extension: Format of the exported report. PDF or CSV.\n            pagination: Pagination options containing page size, next_id and next_row.\n            hide_amounts: Whether amounts should be hidden.\n\n        Raises:\n            InvalidExtensionError: If extension is not pdf or csv.\n            HTTPStatusError: If the request is not a success.\n\n        Returns:\n            Report ready to be saved or further processed in python.\n        \"\"\"\n        _validate_extension(extension)\n\n        pagination = pagination or PaginationOptions()\n        request = cast(\n            \"Response\",\n            self.request(\n                f\"{self.endpoint}.{extension}\",\n                body=self._paginate_body(\n                    body.format(\n                        f\"detail_report_{extension}\",\n                        workspace_id=self.workspace_id,\n                        hide_amounts=hide_amounts,\n                    ),\n                    pagination,\n                ),\n                method=RequestMethod.POST,\n                raw=True,\n            ),\n        )\n        return self._paginate(request, raw=True)\n\n    def totals_report(\n        self,\n        body: ReportBody,\n        *,\n        granularity: Literal[\"day\", \"week\", \"month\"] = \"day\",\n        with_graph: bool = False,\n    ) -&gt; dict[str, int]:\n        \"\"\"Return totals sums for detailed report.\n\n        [Official Documentation](https://engineering.toggl.com/docs/reports/detailed_reports#post-load-totals-detailed-report)\n\n        Args:\n            body: JSON body for filtering the report.\n            granularity: Totals granularity, optional, overrides resolution values.\n            with_graph: Whether Graph information should be loaded.\n\n        Returns:\n            With the totals relevant to the provided filters.\n        \"\"\"\n        return cast(\n            \"dict[str, int]\",\n            self.request(\n                f\"{self.endpoint}/totals\",\n                body=body.format(\n                    \"detail_totals\",\n                    workspace_id=self.workspace_id,\n                    granularity=granularity,\n                    with_graph=with_graph,\n                ),\n                method=RequestMethod.POST,\n            ),\n        )\n\n    @property\n    def endpoint(self) -&gt; str:\n        \"\"\"Detailed report endpoint url parameters.\"\"\"\n        return f\"workspace/{self.workspace_id}/search/time_entries\"\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.DetailedReportEndpoint.endpoint","title":"endpoint  <code>property</code>","text":"<pre><code>endpoint: str\n</code></pre> <p>Detailed report endpoint url parameters.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.DetailedReportEndpoint.search_time_entries","title":"search_time_entries","text":"<pre><code>search_time_entries(\n    body: ReportBody,\n    pagination: PaginationOptions | None = None,\n    *,\n    hide_amounts: bool = False,\n) -&gt; PaginatedResult[list[dict[str, Any]]]\n</code></pre> <p>Return time entries for detailed report according to the given filters.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>JSON body with filters for time entries.</p> <p> TYPE: <code>ReportBody</code> </p> <code>pagination</code> <p>Pagination options containing page size, next_id and next_row.</p> <p> TYPE: <code>PaginationOptions | None</code> DEFAULT: <code>None</code> </p> <code>hide_amounts</code> <p>Whether amounts should be hidden.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>PaginatedResult[list[dict[str, Any]]]</code> <p>Data with pagination information if required.</p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>def search_time_entries(\n    self,\n    body: ReportBody,\n    pagination: PaginationOptions | None = None,\n    *,\n    hide_amounts: bool = False,\n) -&gt; PaginatedResult[list[dict[str, Any]]]:\n    \"\"\"Return time entries for detailed report according to the given filters.\n\n    [Official Documentation](https://engineering.toggl.com/docs/reports/detailed_reports#post-search-time-entries)\n\n    Args:\n        body: JSON body with filters for time entries.\n        pagination: Pagination options containing page size, next_id and next_row.\n        hide_amounts: Whether amounts should be hidden.\n\n    Returns:\n        Data with pagination information if required.\n    \"\"\"\n    pagination = pagination or PaginationOptions()\n\n    request: Response = cast(\n        \"Response\",\n        self.request(\n            self.endpoint,\n            body=self._paginate_body(\n                body.format(\n                    \"detail_search_time\",\n                    workspace_id=self.workspace_id,\n                    hide_amounts=hide_amounts,\n                ),\n                pagination,\n            ),\n            method=RequestMethod.POST,\n            raw=True,\n        ),\n    )\n\n    return self._paginate(request)\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.DetailedReportEndpoint.export_report","title":"export_report","text":"<pre><code>export_report(\n    body: ReportBody,\n    extension: ReportFormats,\n    pagination: PaginationOptions | None = None,\n    *,\n    hide_amounts: bool = False,\n) -&gt; PaginatedResult[bytes]\n</code></pre> <p>Download detailed report in pdf or csv format.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>JSON body for formatting and filtering the report.</p> <p> TYPE: <code>ReportBody</code> </p> <code>extension</code> <p>Format of the exported report. PDF or CSV.</p> <p> TYPE: <code>ReportFormats</code> </p> <code>pagination</code> <p>Pagination options containing page size, next_id and next_row.</p> <p> TYPE: <code>PaginationOptions | None</code> DEFAULT: <code>None</code> </p> <code>hide_amounts</code> <p>Whether amounts should be hidden.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>InvalidExtensionError</code> <p>If extension is not pdf or csv.</p> <code>HTTPStatusError</code> <p>If the request is not a success.</p> RETURNS DESCRIPTION <code>PaginatedResult[bytes]</code> <p>Report ready to be saved or further processed in python.</p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>def export_report(\n    self,\n    body: ReportBody,\n    extension: ReportFormats,\n    pagination: PaginationOptions | None = None,\n    *,\n    hide_amounts: bool = False,\n) -&gt; PaginatedResult[bytes]:\n    \"\"\"Download detailed report in pdf or csv format.\n\n    [Official Documentation](https://engineering.toggl.com/docs/reports/detailed_reports#post-export-detailed-report)\n\n    Args:\n        body: JSON body for formatting and filtering the report.\n        extension: Format of the exported report. PDF or CSV.\n        pagination: Pagination options containing page size, next_id and next_row.\n        hide_amounts: Whether amounts should be hidden.\n\n    Raises:\n        InvalidExtensionError: If extension is not pdf or csv.\n        HTTPStatusError: If the request is not a success.\n\n    Returns:\n        Report ready to be saved or further processed in python.\n    \"\"\"\n    _validate_extension(extension)\n\n    pagination = pagination or PaginationOptions()\n    request = cast(\n        \"Response\",\n        self.request(\n            f\"{self.endpoint}.{extension}\",\n            body=self._paginate_body(\n                body.format(\n                    f\"detail_report_{extension}\",\n                    workspace_id=self.workspace_id,\n                    hide_amounts=hide_amounts,\n                ),\n                pagination,\n            ),\n            method=RequestMethod.POST,\n            raw=True,\n        ),\n    )\n    return self._paginate(request, raw=True)\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.DetailedReportEndpoint.totals_report","title":"totals_report","text":"<pre><code>totals_report(\n    body: ReportBody,\n    *,\n    granularity: Literal[\"day\", \"week\", \"month\"] = \"day\",\n    with_graph: bool = False,\n) -&gt; dict[str, int]\n</code></pre> <p>Return totals sums for detailed report.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>JSON body for filtering the report.</p> <p> TYPE: <code>ReportBody</code> </p> <code>granularity</code> <p>Totals granularity, optional, overrides resolution values.</p> <p> TYPE: <code>Literal['day', 'week', 'month']</code> DEFAULT: <code>'day'</code> </p> <code>with_graph</code> <p>Whether Graph information should be loaded.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict[str, int]</code> <p>With the totals relevant to the provided filters.</p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>def totals_report(\n    self,\n    body: ReportBody,\n    *,\n    granularity: Literal[\"day\", \"week\", \"month\"] = \"day\",\n    with_graph: bool = False,\n) -&gt; dict[str, int]:\n    \"\"\"Return totals sums for detailed report.\n\n    [Official Documentation](https://engineering.toggl.com/docs/reports/detailed_reports#post-load-totals-detailed-report)\n\n    Args:\n        body: JSON body for filtering the report.\n        granularity: Totals granularity, optional, overrides resolution values.\n        with_graph: Whether Graph information should be loaded.\n\n    Returns:\n        With the totals relevant to the provided filters.\n    \"\"\"\n    return cast(\n        \"dict[str, int]\",\n        self.request(\n            f\"{self.endpoint}/totals\",\n            body=body.format(\n                \"detail_totals\",\n                workspace_id=self.workspace_id,\n                granularity=granularity,\n                with_graph=with_graph,\n            ),\n            method=RequestMethod.POST,\n        ),\n    )\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.asyncio.AsyncDetailedReportEndpoint","title":"toggl_api.asyncio.AsyncDetailedReportEndpoint","text":"<p>               Bases: <code>AsyncReportEndpoint</code></p> <p>Detailed reports endpoint.</p> <p>Official Documentation</p> METHOD DESCRIPTION <code>search_time_entries</code> <p>Return time entries for detailed report according to the given filters.</p> <code>export_report</code> <p>Download detailed report in pdf or csv format.</p> <code>totals_report</code> <p>Return totals sums for detailed report.</p>"},{"location":"api-guide/reports.html#toggl_api.asyncio.AsyncDetailedReportEndpoint.search_time_entries","title":"search_time_entries  <code>async</code>","text":"<pre><code>search_time_entries(\n    body: ReportBody,\n    pagination: PaginationOptions | None = None,\n    *,\n    hide_amounts: bool = False,\n) -&gt; PaginatedResult[list[dict[str, Any]]]\n</code></pre> <p>Return time entries for detailed report according to the given filters.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>JSON body with filters for time entries.</p> <p> TYPE: <code>ReportBody</code> </p> <code>pagination</code> <p>Pagination options containing page size, next_id and next_row.</p> <p> TYPE: <code>PaginationOptions | None</code> DEFAULT: <code>None</code> </p> <code>hide_amounts</code> <p>Whether amounts should be hidden.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>PaginatedResult[list[dict[str, Any]]]</code> <p>Data with pagination information if required.</p>"},{"location":"api-guide/reports.html#toggl_api.asyncio.AsyncDetailedReportEndpoint.export_report","title":"export_report  <code>async</code>","text":"<pre><code>export_report(\n    body: ReportBody,\n    extension: ReportFormats,\n    pagination: PaginationOptions | None = None,\n    *,\n    hide_amounts: bool = False,\n) -&gt; PaginatedResult[bytes]\n</code></pre> <p>Download detailed report in pdf or csv format.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>JSON body for formatting and filtering the report.</p> <p> TYPE: <code>ReportBody</code> </p> <code>extension</code> <p>Format of the exported report. PDF or CSV.</p> <p> TYPE: <code>ReportFormats</code> </p> <code>pagination</code> <p>Pagination options containing page size, next_id and next_row.</p> <p> TYPE: <code>PaginationOptions | None</code> DEFAULT: <code>None</code> </p> <code>hide_amounts</code> <p>Whether amounts should be hidden.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>InvalidExtensionError</code> <p>If extension is not pdf or csv.</p> <code>HTTPStatusError</code> <p>If the request is not a success.</p> RETURNS DESCRIPTION <code>PaginatedResult[bytes]</code> <p>Report ready to be saved or further processed in python.</p>"},{"location":"api-guide/reports.html#toggl_api.asyncio.AsyncDetailedReportEndpoint.totals_report","title":"totals_report  <code>async</code>","text":"<pre><code>totals_report(\n    body: ReportBody,\n    *,\n    granularity: Literal[\"day\", \"week\", \"month\"] = \"day\",\n    with_graph: bool = False,\n) -&gt; dict[str, int]\n</code></pre> <p>Return totals sums for detailed report.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>JSON body for filtering the report.</p> <p> TYPE: <code>ReportBody</code> </p> <code>granularity</code> <p>Totals granularity, optional, overrides resolution values.</p> <p> TYPE: <code>Literal['day', 'week', 'month']</code> DEFAULT: <code>'day'</code> </p> <code>with_graph</code> <p>Whether Graph information should be loaded.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict[str, int]</code> <p>With the totals relevant to the provided filters.</p>"},{"location":"api-guide/reports.html#weekly-reports","title":"Weekly Reports","text":""},{"location":"api-guide/reports.html#toggl_api.reports.WeeklyReportEndpoint","title":"toggl_api.reports.WeeklyReportEndpoint","text":"<p>               Bases: <code>ReportEndpoint</code></p> <p>Weekly reports endpoint.</p> <p>Official Documentation</p> METHOD DESCRIPTION <code>search_time_entries</code> <p>Return time entries for weekly report according to the given filters.</p> <code>export_report</code> <p>Download weekly report in pdf or csv format.</p> ATTRIBUTE DESCRIPTION <code>endpoint</code> <p>Weekly report endpoint url parameters.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>class WeeklyReportEndpoint(ReportEndpoint):\n    \"\"\"Weekly reports endpoint.\n\n    [Official Documentation](https://engineering.toggl.com/docs/reports/weekly_reports)\n    \"\"\"\n\n    def search_time_entries(self, body: ReportBody) -&gt; list[dict[str, Any]]:\n        \"\"\"Return time entries for weekly report according to the given filters.\n\n        [Official Documentation](https://engineering.toggl.com/docs/reports/detailed_reports#post-search-time-entries)\n\n        Args:\n            body: JSON body for filtering time entries.\n\n        Returns:\n            A List of time entries filted by the formatted body.\n        \"\"\"\n        return cast(\n            \"list[dict[str, Any]]\",\n            self.request(\n                self.endpoint,\n                body=body.format(\n                    \"weekly_time_entries\",\n                    workspace_id=self.workspace_id,\n                ),\n                method=RequestMethod.POST,\n            ),\n        )\n\n    def export_report(self, body: ReportBody, extension: ReportFormats) -&gt; bytes:\n        \"\"\"Download weekly report in pdf or csv format.\n\n        [Official Documentation](https://engineering.toggl.com/docs/reports/weekly_reports#post-export-weekly-report)\n\n        Args:\n            body: JSON body for filtering time entries.\n            extension: extension: Format of the exported report. PDF or CSV.\n\n        Raises:\n            InvalidExtensionError: If extension is not pdf or csv.\n\n        Returns:\n            Report ready to be saved or further processed in python.\n        \"\"\"\n        _validate_extension(extension)\n        return cast(\n            \"Response\",\n            self.request(\n                f\"{self.endpoint}.{extension}\",\n                body=body.format(\n                    f\"weekly_report_{extension}\",\n                    workspace_id=self.workspace_id,\n                ),\n                method=RequestMethod.POST,\n                raw=True,\n            ),\n        ).content\n\n    @property\n    def endpoint(self) -&gt; str:\n        \"\"\"Weekly report endpoint url parameters.\"\"\"\n        return f\"workspace/{self.workspace_id}/weekly/time_entries\"\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.WeeklyReportEndpoint.endpoint","title":"endpoint  <code>property</code>","text":"<pre><code>endpoint: str\n</code></pre> <p>Weekly report endpoint url parameters.</p>"},{"location":"api-guide/reports.html#toggl_api.reports.WeeklyReportEndpoint.search_time_entries","title":"search_time_entries","text":"<pre><code>search_time_entries(body: ReportBody) -&gt; list[dict[str, Any]]\n</code></pre> <p>Return time entries for weekly report according to the given filters.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>JSON body for filtering time entries.</p> <p> TYPE: <code>ReportBody</code> </p> RETURNS DESCRIPTION <code>list[dict[str, Any]]</code> <p>A List of time entries filted by the formatted body.</p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>def search_time_entries(self, body: ReportBody) -&gt; list[dict[str, Any]]:\n    \"\"\"Return time entries for weekly report according to the given filters.\n\n    [Official Documentation](https://engineering.toggl.com/docs/reports/detailed_reports#post-search-time-entries)\n\n    Args:\n        body: JSON body for filtering time entries.\n\n    Returns:\n        A List of time entries filted by the formatted body.\n    \"\"\"\n    return cast(\n        \"list[dict[str, Any]]\",\n        self.request(\n            self.endpoint,\n            body=body.format(\n                \"weekly_time_entries\",\n                workspace_id=self.workspace_id,\n            ),\n            method=RequestMethod.POST,\n        ),\n    )\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.reports.WeeklyReportEndpoint.export_report","title":"export_report","text":"<pre><code>export_report(body: ReportBody, extension: ReportFormats) -&gt; bytes\n</code></pre> <p>Download weekly report in pdf or csv format.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>JSON body for filtering time entries.</p> <p> TYPE: <code>ReportBody</code> </p> <code>extension</code> <p>extension: Format of the exported report. PDF or CSV.</p> <p> TYPE: <code>ReportFormats</code> </p> RAISES DESCRIPTION <code>InvalidExtensionError</code> <p>If extension is not pdf or csv.</p> RETURNS DESCRIPTION <code>bytes</code> <p>Report ready to be saved or further processed in python.</p> Source code in <code>src/toggl_api/reports.py</code> <pre><code>def export_report(self, body: ReportBody, extension: ReportFormats) -&gt; bytes:\n    \"\"\"Download weekly report in pdf or csv format.\n\n    [Official Documentation](https://engineering.toggl.com/docs/reports/weekly_reports#post-export-weekly-report)\n\n    Args:\n        body: JSON body for filtering time entries.\n        extension: extension: Format of the exported report. PDF or CSV.\n\n    Raises:\n        InvalidExtensionError: If extension is not pdf or csv.\n\n    Returns:\n        Report ready to be saved or further processed in python.\n    \"\"\"\n    _validate_extension(extension)\n    return cast(\n        \"Response\",\n        self.request(\n            f\"{self.endpoint}.{extension}\",\n            body=body.format(\n                f\"weekly_report_{extension}\",\n                workspace_id=self.workspace_id,\n            ),\n            method=RequestMethod.POST,\n            raw=True,\n        ),\n    ).content\n</code></pre>"},{"location":"api-guide/reports.html#toggl_api.asyncio.AsyncWeeklyReportEndpoint","title":"toggl_api.asyncio.AsyncWeeklyReportEndpoint","text":"<p>               Bases: <code>AsyncReportEndpoint</code></p> <p>Weekly reports endpoint.</p> <p>Official Documentation</p> METHOD DESCRIPTION <code>search_time_entries</code> <p>Return time entries for weekly report according to the given filters.</p> <code>export_report</code> <p>Download weekly report in pdf or csv format.</p>"},{"location":"api-guide/reports.html#toggl_api.asyncio.AsyncWeeklyReportEndpoint.search_time_entries","title":"search_time_entries  <code>async</code>","text":"<pre><code>search_time_entries(body: ReportBody) -&gt; list[dict[str, Any]]\n</code></pre> <p>Return time entries for weekly report according to the given filters.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>JSON body for filtering time entries.</p> <p> TYPE: <code>ReportBody</code> </p> RETURNS DESCRIPTION <code>list[dict[str, Any]]</code> <p>A List of time entries filted by the formatted body.</p>"},{"location":"api-guide/reports.html#toggl_api.asyncio.AsyncWeeklyReportEndpoint.export_report","title":"export_report  <code>async</code>","text":"<pre><code>export_report(body: ReportBody, extension: ReportFormats) -&gt; bytes\n</code></pre> <p>Download weekly report in pdf or csv format.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>body</code> <p>JSON body for filtering time entries.</p> <p> TYPE: <code>ReportBody</code> </p> <code>extension</code> <p>extension: Format of the exported report. PDF or CSV.</p> <p> TYPE: <code>ReportFormats</code> </p> RAISES DESCRIPTION <code>InvalidExtensionError</code> <p>If extension is not pdf or csv.</p> RETURNS DESCRIPTION <code>bytes</code> <p>Report ready to be saved or further processed in python.</p>"},{"location":"api-guide/tag.html","title":"Tags","text":""},{"location":"api-guide/tag.html#toggl_api.TagEndpoint","title":"toggl_api.TagEndpoint","text":"<p>               Bases: <code>TogglCachedEndpoint[TogglTag]</code></p> <p>Specific endpoints for retrieving and modifying tags.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tag_endpoint = TagEndpoint(21341214, BasicAuth(...), JSONCache(Path(\"cache\")))\n&gt;&gt;&gt; tag_endpoint.add(\"Eucalyptus\")\nTogglTag(213123132, \"Eucalyptus\")\n</code></pre> <pre><code>&gt;&gt;&gt; tag_endpoint.query(TogglQuery(\"name\", \"Eucalyptus\"))\n[TogglTag(213123132, \"Eucalyptus\")]\n</code></pre> PARAMETER DESCRIPTION <code>workspace_id</code> <p>The workspace the tags belong to.</p> <p> TYPE: <code>int | TogglWorkspace</code> </p> <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>cache</code> <p>Cache object where tags are stored.</p> <p> TYPE: <code>TogglCache[TogglTag] | None</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>Optional client to be passed to be used for requests. Useful when a global client is used and needs to be recycled.</p> <p> TYPE: <code>Client | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>Timeout | int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>collect</code> <p>Gather all tags.</p> <code>add</code> <p>Create a new tag.</p> <code>edit</code> <p>Set the name of the tag based on the tag object.</p> <code>delete</code> <p>Delete a tag based on its ID or model.</p> Source code in <code>src/toggl_api/_tag.py</code> <pre><code>class TagEndpoint(TogglCachedEndpoint[TogglTag]):\n    \"\"\"Specific endpoints for retrieving and modifying tags.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/tags)\n\n    Examples:\n        &gt;&gt;&gt; tag_endpoint = TagEndpoint(21341214, BasicAuth(...), JSONCache(Path(\"cache\")))\n        &gt;&gt;&gt; tag_endpoint.add(\"Eucalyptus\")\n        TogglTag(213123132, \"Eucalyptus\")\n\n        &gt;&gt;&gt; tag_endpoint.query(TogglQuery(\"name\", \"Eucalyptus\"))\n        [TogglTag(213123132, \"Eucalyptus\")]\n\n    Params:\n        workspace_id: The workspace the tags belong to.\n        auth: Authentication for the client.\n        cache: Cache object where tags are stored.\n        client: Optional client to be passed to be used for requests. Useful\n            when a global client is used and needs to be recycled.\n        timeout: How long it takes for the client to timeout. Keyword Only.\n            Defaults to 10 seconds.\n        re_raise: Whether to raise all HTTPStatusError errors and not handle them\n            internally. Keyword Only.\n        retries: Max retries to attempt if the server returns a *5xx* status_code.\n            Has no effect if re_raise is `True`. Keyword Only\n    \"\"\"\n\n    MODEL = TogglTag\n\n    def __init__(\n        self,\n        workspace_id: int | TogglWorkspace,\n        auth: BasicAuth,\n        cache: TogglCache[TogglTag] | None = None,\n        *,\n        client: Client | None = None,\n        timeout: Timeout | int = 10,\n        re_raise: bool = False,\n        retries: int = 3,\n    ) -&gt; None:\n        super().__init__(\n            auth,\n            cache,\n            client=client,\n            timeout=timeout,\n            re_raise=re_raise,\n            retries=retries,\n        )\n        self.workspace_id = workspace_id if isinstance(workspace_id, int) else workspace_id.id\n\n    def get(\n        self,\n        tag: TogglTag | int,\n        *,\n        refresh: bool = False,\n    ) -&gt; TogglTag | None:\n        \"\"\"Get endpoint convenience method for querying single tags from cache.\n\n        This endpoint doesn't exist on the API so it locally queries for tags\n        instead.\n\n        Examples:\n            &gt;&gt;&gt; toggl_endpoint.get(213123132)\n            TogglTag(213123132, \"Eucalyptus\")\n\n        Args:\n            tag: Which tag to retrieve. Can be an existing model or its id.\n            refresh: Whether to collect all tags from the API first.\n\n        Raises:\n            HTTPStatusError: If an error is raised and `re_raise` is True.\n\n        Returns:\n            A tag model if it was found otherwise None.\n        \"\"\"\n        if self.cache is None:\n            return None\n\n        if refresh:\n            try:\n                self.collect(refresh=True)\n            except HTTPStatusError:\n                if self.re_raise:\n                    raise\n                log.exception(\"%s\")\n\n        if isinstance(tag, TogglTag):\n            tag = tag.id\n\n        query = self.query(TogglQuery(\"id\", tag))\n        if query:\n            return query[0]\n\n        return None\n\n    def collect(self, *, refresh: bool = False) -&gt; list[TogglTag]:\n        \"\"\"Gather all tags.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/tags#get-tags)\n\n        Raises:\n            HTTPStatusError: If any issue happens with the Toggl API.\n\n        Returns:\n            A list of tags collected from the API or local cache.\n        \"\"\"\n        return cast(\"list[TogglTag]\", self.request(self.endpoint, refresh=refresh))\n\n    def add(self, name: str) -&gt; TogglTag:\n        \"\"\"Create a new tag.\n\n        This endpoint always hit the external API in order to keep tags consistent.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/tags#post-create-tag)\n\n        Args:\n            name: The name of the new tag.\n\n        Raises:\n            NamingError: IF the tag name is empty.\n            HTTPStatusError: If a tag with the same name exists or any other\n                none *ok* status code is returned.\n\n        Returns:\n            The newly created tag.\n        \"\"\"\n        if not name:\n            msg = \"The tag name needs to be at least one character long.\"\n            raise NamingError(msg)\n\n        return cast(\n            \"TogglTag\",\n            self.request(\n                self.endpoint,\n                body={\"name\": name},\n                method=RequestMethod.POST,\n                refresh=True,\n            ),\n        )\n\n    def edit(self, tag: TogglTag | int, name: str) -&gt; TogglTag:\n        \"\"\"Set the name of the tag based on the tag object.\n\n        This endpoint always hit the external API in order to keep tags consistent.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/tags#put-update-tag)\n\n        Examples:\n            &gt;&gt;&gt; tag = Tag(213123132, \"Eucalyptus\")\n            &gt;&gt;&gt; tag_endpoint.edit(tag)\n            TogglTag(213123132, \"Eucalyptus\")\n\n            &gt;&gt;&gt; tag_endpoint.edit(213123132, \"Eucalyptus\")\n            TogglTag(213123132, \"Eucalyptus\")\n\n        Args:\n            tag: TogglTag or integer as the id.\n            name: New name for the tag.\n\n        Raises:\n            NamingError: If the name is not at the minimum length.\n            HTTPStatusError: If any issue happens with the Toggl API.\n\n        Returns:\n            The edited tag.\n        \"\"\"\n        if not name:\n            msg = \"The tag name needs to be at least one character long.\"\n            raise NamingError(msg)\n\n        return cast(\n            \"TogglTag\",\n            self.request(\n                f\"{self.endpoint}/{tag.id if isinstance(tag, TogglTag) else tag}\",\n                body={\"name\": name},\n                method=RequestMethod.PUT,\n                refresh=True,\n            ),\n        )\n\n    def delete(self, tag: TogglTag | int) -&gt; None:\n        \"\"\"Delete a tag based on its ID or model.\n\n        This endpoint always hit the external API in order to keep tags consistent.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/tags#delete-delete-tag)\n\n        Args:\n            tag: The tag to delete. Either the id or model.\n\n        Raises:\n            HTTPStatusError: For anything thats not an '2xx' or '404' code.\n        \"\"\"\n        tag_id = tag if isinstance(tag, int) else tag.id\n        try:\n            self.request(\n                f\"{self.endpoint}/{tag_id}\",\n                method=RequestMethod.DELETE,\n                refresh=True,\n            )\n        except HTTPStatusError as err:\n            if self.re_raise or err.response.status_code != codes.NOT_FOUND:\n                raise\n            log.warning(\n                \"Tag with id %s was either already deleted or did not exist in the first place!\",\n                tag_id,\n            )\n\n        if self.cache is None:\n            return\n\n        if isinstance(tag, int):\n            tag_model = self.cache.find({\"id\": tag})\n            if not isinstance(tag_model, TogglTag):\n                return\n            tag = tag_model\n\n        self.cache.delete(tag)\n        self.cache.commit()\n\n    @property\n    def endpoint(self) -&gt; str:\n        return f\"workspaces/{self.workspace_id}/tags\"\n</code></pre>"},{"location":"api-guide/tag.html#toggl_api.TagEndpoint.collect","title":"collect","text":"<pre><code>collect(*, refresh: bool = False) -&gt; list[TogglTag]\n</code></pre> <p>Gather all tags.</p> <p>Official Documentation</p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If any issue happens with the Toggl API.</p> RETURNS DESCRIPTION <code>list[TogglTag]</code> <p>A list of tags collected from the API or local cache.</p> Source code in <code>src/toggl_api/_tag.py</code> <pre><code>def collect(self, *, refresh: bool = False) -&gt; list[TogglTag]:\n    \"\"\"Gather all tags.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/tags#get-tags)\n\n    Raises:\n        HTTPStatusError: If any issue happens with the Toggl API.\n\n    Returns:\n        A list of tags collected from the API or local cache.\n    \"\"\"\n    return cast(\"list[TogglTag]\", self.request(self.endpoint, refresh=refresh))\n</code></pre>"},{"location":"api-guide/tag.html#toggl_api.TagEndpoint.add","title":"add","text":"<pre><code>add(name: str) -&gt; TogglTag\n</code></pre> <p>Create a new tag.</p> <p>This endpoint always hit the external API in order to keep tags consistent.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the new tag.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>NamingError</code> <p>IF the tag name is empty.</p> <code>HTTPStatusError</code> <p>If a tag with the same name exists or any other none ok status code is returned.</p> RETURNS DESCRIPTION <code>TogglTag</code> <p>The newly created tag.</p> Source code in <code>src/toggl_api/_tag.py</code> <pre><code>def add(self, name: str) -&gt; TogglTag:\n    \"\"\"Create a new tag.\n\n    This endpoint always hit the external API in order to keep tags consistent.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/tags#post-create-tag)\n\n    Args:\n        name: The name of the new tag.\n\n    Raises:\n        NamingError: IF the tag name is empty.\n        HTTPStatusError: If a tag with the same name exists or any other\n            none *ok* status code is returned.\n\n    Returns:\n        The newly created tag.\n    \"\"\"\n    if not name:\n        msg = \"The tag name needs to be at least one character long.\"\n        raise NamingError(msg)\n\n    return cast(\n        \"TogglTag\",\n        self.request(\n            self.endpoint,\n            body={\"name\": name},\n            method=RequestMethod.POST,\n            refresh=True,\n        ),\n    )\n</code></pre>"},{"location":"api-guide/tag.html#toggl_api.TagEndpoint.edit","title":"edit","text":"<pre><code>edit(tag: TogglTag | int, name: str) -&gt; TogglTag\n</code></pre> <p>Set the name of the tag based on the tag object.</p> <p>This endpoint always hit the external API in order to keep tags consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tag = Tag(213123132, \"Eucalyptus\")\n&gt;&gt;&gt; tag_endpoint.edit(tag)\nTogglTag(213123132, \"Eucalyptus\")\n</code></pre> <pre><code>&gt;&gt;&gt; tag_endpoint.edit(213123132, \"Eucalyptus\")\nTogglTag(213123132, \"Eucalyptus\")\n</code></pre> PARAMETER DESCRIPTION <code>tag</code> <p>TogglTag or integer as the id.</p> <p> TYPE: <code>TogglTag | int</code> </p> <code>name</code> <p>New name for the tag.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>NamingError</code> <p>If the name is not at the minimum length.</p> <code>HTTPStatusError</code> <p>If any issue happens with the Toggl API.</p> RETURNS DESCRIPTION <code>TogglTag</code> <p>The edited tag.</p> Source code in <code>src/toggl_api/_tag.py</code> <pre><code>def edit(self, tag: TogglTag | int, name: str) -&gt; TogglTag:\n    \"\"\"Set the name of the tag based on the tag object.\n\n    This endpoint always hit the external API in order to keep tags consistent.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/tags#put-update-tag)\n\n    Examples:\n        &gt;&gt;&gt; tag = Tag(213123132, \"Eucalyptus\")\n        &gt;&gt;&gt; tag_endpoint.edit(tag)\n        TogglTag(213123132, \"Eucalyptus\")\n\n        &gt;&gt;&gt; tag_endpoint.edit(213123132, \"Eucalyptus\")\n        TogglTag(213123132, \"Eucalyptus\")\n\n    Args:\n        tag: TogglTag or integer as the id.\n        name: New name for the tag.\n\n    Raises:\n        NamingError: If the name is not at the minimum length.\n        HTTPStatusError: If any issue happens with the Toggl API.\n\n    Returns:\n        The edited tag.\n    \"\"\"\n    if not name:\n        msg = \"The tag name needs to be at least one character long.\"\n        raise NamingError(msg)\n\n    return cast(\n        \"TogglTag\",\n        self.request(\n            f\"{self.endpoint}/{tag.id if isinstance(tag, TogglTag) else tag}\",\n            body={\"name\": name},\n            method=RequestMethod.PUT,\n            refresh=True,\n        ),\n    )\n</code></pre>"},{"location":"api-guide/tag.html#toggl_api.TagEndpoint.delete","title":"delete","text":"<pre><code>delete(tag: TogglTag | int) -&gt; None\n</code></pre> <p>Delete a tag based on its ID or model.</p> <p>This endpoint always hit the external API in order to keep tags consistent.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>tag</code> <p>The tag to delete. Either the id or model.</p> <p> TYPE: <code>TogglTag | int</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything thats not an '2xx' or '404' code.</p> Source code in <code>src/toggl_api/_tag.py</code> <pre><code>def delete(self, tag: TogglTag | int) -&gt; None:\n    \"\"\"Delete a tag based on its ID or model.\n\n    This endpoint always hit the external API in order to keep tags consistent.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/tags#delete-delete-tag)\n\n    Args:\n        tag: The tag to delete. Either the id or model.\n\n    Raises:\n        HTTPStatusError: For anything thats not an '2xx' or '404' code.\n    \"\"\"\n    tag_id = tag if isinstance(tag, int) else tag.id\n    try:\n        self.request(\n            f\"{self.endpoint}/{tag_id}\",\n            method=RequestMethod.DELETE,\n            refresh=True,\n        )\n    except HTTPStatusError as err:\n        if self.re_raise or err.response.status_code != codes.NOT_FOUND:\n            raise\n        log.warning(\n            \"Tag with id %s was either already deleted or did not exist in the first place!\",\n            tag_id,\n        )\n\n    if self.cache is None:\n        return\n\n    if isinstance(tag, int):\n        tag_model = self.cache.find({\"id\": tag})\n        if not isinstance(tag_model, TogglTag):\n            return\n        tag = tag_model\n\n    self.cache.delete(tag)\n    self.cache.commit()\n</code></pre>"},{"location":"api-guide/tag.html#toggl_api.asyncio.AsyncTagEndpoint","title":"toggl_api.asyncio.AsyncTagEndpoint","text":"<p>               Bases: <code>TogglAsyncCachedEndpoint[TogglTag]</code></p> <p>Specific endpoints for retrieving and modifying tags.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tag_endpoint = TagEndpoint(21341214, BasicAuth(...), AsyncSqliteCache(Path(\"cache\")))\n&gt;&gt;&gt; await tag_endpoint.add(\"Eucalyptus\")\nTogglTag(213123132, \"Eucalyptus\")\n</code></pre> <pre><code>&gt;&gt;&gt; await tag_endpoint.get(213123132, refresh=True)\nTogglTag(213123132, \"Eucalyptus\")\n</code></pre> PARAMETER DESCRIPTION <code>workspace_id</code> <p>The workspace the tags belong to.</p> <p> TYPE: <code>int | TogglWorkspace</code> </p> <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>cache</code> <p>Cache object where tags are stored.</p> <p> TYPE: <code>AsyncSqliteCache[TogglTag] | None</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>Optional async client to be passed to be used for requests.</p> <p> TYPE: <code>AsyncClient | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>get</code> <p>Get endpoint convenience method for querying single tags from cache.</p> <code>collect</code> <p>Gather all tags.</p> <code>add</code> <p>Create a new tag.</p> <code>edit</code> <p>Rename an existing tag.</p> <code>delete</code> <p>Delete a tag based on its ID or model.</p> ATTRIBUTE DESCRIPTION <code>endpoint</code> <p>Generic tag endpoint params with workspace id prefilled.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api-guide/tag.html#toggl_api.asyncio.AsyncTagEndpoint.endpoint","title":"endpoint  <code>property</code>","text":"<pre><code>endpoint: str\n</code></pre> <p>Generic tag endpoint params with workspace id prefilled.</p>"},{"location":"api-guide/tag.html#toggl_api.asyncio.AsyncTagEndpoint.get","title":"get  <code>async</code>","text":"<pre><code>get(tag: TogglTag | int, *, refresh: bool = False) -&gt; TogglTag | None\n</code></pre> <p>Get endpoint convenience method for querying single tags from cache.</p> <p>This endpoint doesn't exist on the API so it locally queries for tags instead.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await toggl_endpoint.get(213123132)\nTogglTag(213123132, \"Eucalyptus\")\n</code></pre> PARAMETER DESCRIPTION <code>tag</code> <p>Which tag to retrieve. Can be an existing model or its id.</p> <p> TYPE: <code>TogglTag | int</code> </p> <code>refresh</code> <p>Whether to collect all tags from the API first.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>NoCacheAssignedError</code> <p>If no cache has been assigned to the endpoint.</p> <code>HTTPStatusError</code> <p>If any error is raised and <code>re_raise</code> is True.</p> RETURNS DESCRIPTION <code>TogglTag | None</code> <p>A tag model if it was found otherwise None.</p>"},{"location":"api-guide/tag.html#toggl_api.asyncio.AsyncTagEndpoint.collect","title":"collect  <code>async</code>","text":"<pre><code>collect(*, refresh: bool = False) -&gt; list[TogglTag]\n</code></pre> <p>Gather all tags.</p> <p>Official Documentation</p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If any issue happens with the Toggl API.</p> RETURNS DESCRIPTION <code>list[TogglTag]</code> <p>A list of tags collected from the API or local cache.</p>"},{"location":"api-guide/tag.html#toggl_api.asyncio.AsyncTagEndpoint.add","title":"add  <code>async</code>","text":"<pre><code>add(name: str) -&gt; TogglTag\n</code></pre> <p>Create a new tag.</p> <p>This endpoint always hit the external API in order to keep tags consistent.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the new tag.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>NamingError</code> <p>IF the tag name is empty.</p> <code>HTTPStatusError</code> <p>If a tag with the same name exists or any other none ok status code is returned.</p> RETURNS DESCRIPTION <code>TogglTag</code> <p>The newly created tag.</p>"},{"location":"api-guide/tag.html#toggl_api.asyncio.AsyncTagEndpoint.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(tag: TogglTag | int, name: str) -&gt; TogglTag\n</code></pre> <p>Rename an existing tag.</p> <p>This endpoint always hit the external API in order to keep tags consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tag = Tag(213123132, \"Eucalyptus\")\n&gt;&gt;&gt; await tag_endpoint.edit(tag)\nTogglTag(213123132, \"Eucalyptus\")\n</code></pre> <pre><code>&gt;&gt;&gt; await tag_endpoint.edit(213123132, \"Eucalyptus\")\nTogglTag(213123132, \"Eucalyptus\")\n</code></pre> PARAMETER DESCRIPTION <code>tag</code> <p>TogglTag or integer as the id.</p> <p> TYPE: <code>TogglTag | int</code> </p> <code>name</code> <p>New name for the tag.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>NamingError</code> <p>If the name is not at the minimum length.</p> <code>HTTPStatusError</code> <p>If any issue happens with the Toggl API.</p> RETURNS DESCRIPTION <code>TogglTag</code> <p>The edited tag.</p>"},{"location":"api-guide/tag.html#toggl_api.asyncio.AsyncTagEndpoint.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(tag: TogglTag | int) -&gt; None\n</code></pre> <p>Delete a tag based on its ID or model.</p> <p>This endpoint always hit the external API in order to keep tags consistent.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>tag</code> <p>The tag to delete. Either the id or model.</p> <p> TYPE: <code>TogglTag | int</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything thats not an '2xx' or '404' code.</p>"},{"location":"api-guide/tracker.html","title":"Trackers","text":""},{"location":"api-guide/tracker.html#toggl_api.TrackerBody","title":"toggl_api.TrackerBody  <code>dataclass</code>","text":"<p>               Bases: <code>BaseBody</code></p> <p>JSON body dataclass for PUT, POST &amp; PATCH requests.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; TrackerBody(description=\"What a wonderful tracker description!\", project_id=2123132)\nTrackerBody(description=\"What a wonderful tracker description!\", project_id=2123132)\n</code></pre> METHOD DESCRIPTION <code>format</code> <p>Format the body for JSON requests.</p>"},{"location":"api-guide/tracker.html#toggl_api.TrackerBody.format","title":"format","text":"<pre><code>format(endpoint: str, **body: Any) -&gt; dict[str, Any]\n</code></pre> <p>Format the body for JSON requests.</p> <p>Gets called by the endpoint methods before requesting.</p> PARAMETER DESCRIPTION <code>endpoint</code> <p>The endpoints name for filtering purposes.</p> <p> TYPE: <code>str</code> </p> <code>body</code> <p>Additional body arguments that the endpoint requires.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>JSON compatible formatted body.</p>"},{"location":"api-guide/tracker.html#toggl_api.TrackerEndpoint","title":"toggl_api.TrackerEndpoint","text":"<p>               Bases: <code>TogglCachedEndpoint[TogglTracker]</code></p> <p>Endpoint for modifying and creating trackers.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tracker_endpoint = TrackerEndpoint(324525, BasicAuth(...), JSONCache(Path(\"cache\")))\n</code></pre> <pre><code>&gt;&gt;&gt; body = TrackerBody(description=\"What a wonderful tracker description!\", project_id=2123132)\n&gt;&gt;&gt; tracker_endpoint.add(body)\nTogglTracker(id=58687689, name=\"What a wonderful tracker description!\", project=2123132, ...)\n</code></pre> <pre><code>&gt;&gt;&gt; tracker_endpoint.delete(tracker)\nNone\n</code></pre> PARAMETER DESCRIPTION <code>workspace_id</code> <p>The workspace the Toggl trackers belong to.</p> <p> TYPE: <code>int | TogglWorkspace</code> </p> <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>cache</code> <p>Where to cache trackers.</p> <p> TYPE: <code>TogglCache[TogglTracker] | None</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>Optional client to be passed to be used for requests. Useful when a global client is used and needs to be recycled.</p> <p> TYPE: <code>Client | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>Timeout | int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>current</code> <p>Get current running tracker. Returns None if no tracker is running.</p> <code>collect</code> <p>Get a set of trackers depending on specified parameters.</p> <code>get</code> <p>Get a single tracker by ID.</p> <code>add</code> <p>Add a new tracker.</p> <code>edit</code> <p>Edit an existing tracker based on the supplied parameters within the body.</p> <code>bulk_edit</code> <p>Bulk edit multiple trackers at the same time.</p> <code>delete</code> <p>Delete a tracker from Toggl.</p> <code>stop</code> <p>Stop the currently running tracker.</p> Source code in <code>src/toggl_api/_tracker.py</code> <pre><code>class TrackerEndpoint(TogglCachedEndpoint[TogglTracker]):\n    \"\"\"Endpoint for modifying and creating trackers.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/time_entries)\n\n    Examples:\n        &gt;&gt;&gt; tracker_endpoint = TrackerEndpoint(324525, BasicAuth(...), JSONCache(Path(\"cache\")))\n\n        &gt;&gt;&gt; body = TrackerBody(description=\"What a wonderful tracker description!\", project_id=2123132)\n        &gt;&gt;&gt; tracker_endpoint.add(body)\n        TogglTracker(id=58687689, name=\"What a wonderful tracker description!\", project=2123132, ...)\n\n        &gt;&gt;&gt; tracker_endpoint.delete(tracker)\n        None\n\n    Params:\n        workspace_id: The workspace the Toggl trackers belong to.\n        auth: Authentication for the client.\n        cache: Where to cache trackers.\n        client: Optional client to be passed to be used for requests. Useful\n            when a global client is used and needs to be recycled.\n        timeout: How long it takes for the client to timeout. Keyword Only.\n            Defaults to 10 seconds.\n        re_raise: Whether to raise all HTTPStatusError errors and not handle them\n            internally. Keyword Only.\n        retries: Max retries to attempt if the server returns a *5xx* status_code.\n            Has no effect if re_raise is `True`. Keyword Only.\n    \"\"\"\n\n    MODEL = TogglTracker\n    TRACKER_ALREADY_STOPPED: Final[int] = codes.CONFLICT\n    TRACKER_NOT_RUNNING: Final[int] = codes.METHOD_NOT_ALLOWED\n\n    def __init__(\n        self,\n        workspace_id: int | TogglWorkspace,\n        auth: BasicAuth,\n        cache: TogglCache[TogglTracker] | None = None,\n        *,\n        client: Client | None = None,\n        timeout: Timeout | int = 10,\n        re_raise: bool = False,\n        retries: int = 3,\n    ) -&gt; None:\n        super().__init__(\n            auth,\n            cache,\n            client=client,\n            timeout=timeout,\n            re_raise=re_raise,\n            retries=retries,\n        )\n        self.workspace_id = workspace_id if isinstance(workspace_id, int) else workspace_id.id\n\n    def _current_refresh(self, tracker: TogglTracker | None) -&gt; None:\n        if self.cache and tracker is None:\n            try:\n                for t in self.cache.query(TogglQuery(\"stop\", None)):\n                    self.get(t, refresh=True)\n            except HTTPStatusError:\n                log.exception(\"%s\")\n                return\n\n    def current(self, *, refresh: bool = True) -&gt; TogglTracker | None:\n        \"\"\"Get current running tracker. Returns None if no tracker is running.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/time_entries#get-get-current-time-entry)\n\n        Examples:\n            &gt;&gt;&gt; tracker_endpoint.current()\n            None\n\n            &gt;&gt;&gt; tracker_endpoint.current(refresh=True)\n            TogglTracker(...)\n\n        Args:\n            refresh: Whether to check the remote API for running trackers.\n                If 'refresh' is True it will check if there are any other running\n                trackers and update if the 'stop' attribute is None.\n\n        Raises:\n            HTTPStatusError: If the request is not a success or any error that's\n                not a '405' status code.\n\n        Returns:\n            A model from cache or the API. None if nothing is running.\n        \"\"\"\n        if self.cache and not refresh:\n            query = list(self.cache.query(TogglQuery(\"stop\", None)))\n            return query[0] if query else None\n\n        try:\n            response = self.request(\"me/time_entries/current\", refresh=refresh)\n        except HTTPStatusError as err:\n            if not self.re_raise and err.response.status_code == self.TRACKER_NOT_RUNNING:\n                log.warning(\"No tracker is currently running!\")\n                response = None\n            else:\n                raise\n\n        self._current_refresh(cast(\"TogglTracker | None\", response))\n\n        return response if isinstance(response, TogglTracker) else None\n\n    def _collect_cache(\n        self,\n        since: int | datetime | None = None,\n        before: date | None = None,\n        start_date: date | None = None,\n        end_date: date | None = None,\n    ) -&gt; list[TogglTracker]:\n        cache: list[TogglTracker] = []\n        if since or before:\n            queries: list[TogglQuery[date]] = []\n\n            if since:\n                since = datetime.fromtimestamp(since, tz=timezone.utc) if isinstance(since, int) else since\n                queries.append(\n                    TogglQuery(\"timestamp\", since, Comparison.GREATER_THEN),\n                )\n\n            if before:\n                queries.append(\n                    TogglQuery(\"start\", before, Comparison.LESS_THEN),\n                )\n\n            cache.extend(self.query(*queries))\n\n        elif start_date and end_date:\n            cache.extend(\n                self.query(\n                    TogglQuery(\n                        \"start\",\n                        start_date,\n                        Comparison.GREATER_THEN_OR_EQUAL,\n                    ),\n                    TogglQuery(\n                        \"start\",\n                        end_date,\n                        Comparison.LESS_THEN_OR_EQUAL,\n                    ),\n                ),\n            )\n        else:\n            cache.extend(self.load_cache())\n\n        return cache\n\n    def collect(\n        self,\n        since: int | datetime | None = None,\n        before: date | None = None,\n        start_date: date | None = None,\n        end_date: date | None = None,\n        *,\n        refresh: bool = False,\n    ) -&gt; list[TogglTracker]:\n        \"\"\"Get a set of trackers depending on specified parameters.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/time_entries#get-timeentries)\n\n        Missing meta and include_sharing query flags not supported by wrapper at\n        the moment.\n\n        Examples:\n            &gt;&gt;&gt; collect(since=17300032362, before=date(2024, 11, 27))\n\n            &gt;&gt;&gt; collect(refresh=True)\n\n            &gt;&gt;&gt; collect(start_date=date(2024, 11, 27), end_date=date(2024, 12, 27))\n\n        Args:\n            since: Get entries modified since this date using UNIX timestamp.\n                Includes deleted ones if refreshing.\n            before: Get entries with start time, before given date (YYYY-MM-DD)\n                or with time in RFC3339 format.\n            start_date: Get entries with start time, from start_date YYYY-MM-DD\n                or with time in RFC3339 format. To be used with end_date.\n            end_date: Get entries with start time, until end_date YYYY-MM-DD or\n                with time in RFC3339 format. To be used with start_date.\n            refresh: Whether to refresh the cache or not.\n\n        Raises:\n            DateTimeError: If the dates are not in the correct ranges.\n            HTTPStatusError: If the request is not a successful status code.\n\n        Returns:\n           List of TogglTracker objects that are within specified parameters.\n                Empty if none is matched.\n        \"\"\"\n        if start_date and end_date:\n            if end_date &lt; start_date:\n                msg = \"end_date must be after the start_date!\"\n                raise DateTimeError(msg)\n            if start_date &gt; datetime.now(tz=timezone.utc):\n                msg = \"start_date must not be earlier than the current date!\"\n                raise DateTimeError(msg)\n\n        if not refresh:\n            return self._collect_cache(since, before, start_date, end_date)\n\n        params = \"me/time_entries\"\n        if since or before:\n            if since:\n                params += f\"?since={get_timestamp(since)}\"\n\n            if before:\n                params += \"&amp;\" if since else \"?\"\n                params += f\"before={format_iso(before)}\"\n\n        elif start_date and end_date:\n            params += f\"?start_date={format_iso(start_date)}&amp;end_date={format_iso(end_date)}\"\n\n        response = self.request(params, refresh=refresh)\n\n        return response if isinstance(response, list) else []\n\n    def get(\n        self,\n        tracker_id: int | TogglTracker,\n        *,\n        refresh: bool = False,\n    ) -&gt; TogglTracker | None:\n        \"\"\"Get a single tracker by ID.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/time_entries#get-get-a-time-entry-by-id)\n\n        Args:\n            tracker_id: ID of the tracker to get.\n            refresh: Whether to refresh the cache or not.\n\n        Raises:\n            HTTPStatusError: If anything thats not a *ok* or *404* status code\n                is returned.\n\n        Returns:\n            TogglTracker object or None if not found.\n        \"\"\"\n        if isinstance(tracker_id, TogglTracker):\n            tracker_id = tracker_id.id\n\n        if self.cache and not refresh:\n            return self.cache.find({\"id\": tracker_id})\n\n        try:\n            response = self.request(\n                f\"me/time_entries/{tracker_id}\",\n                refresh=refresh,\n            )\n        except HTTPStatusError as err:\n            if not self.re_raise and err.response.status_code == codes.NOT_FOUND:\n                log.warning(\"Tracker with id %s does not exist!\", tracker_id)\n                return None\n            raise\n\n        return cast(\"TogglTracker\", response)\n\n    def edit(\n        self,\n        tracker: TogglTracker | int,\n        body: TrackerBody,\n        *,\n        meta: bool = False,\n    ) -&gt; TogglTracker:\n        \"\"\"Edit an existing tracker based on the supplied parameters within the body.\n\n        This endpoint always hit the external API in order to keep trackers consistent.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/time_entries#put-timeentries)\n\n        Examples:\n            &gt;&gt;&gt; body = TrackerBody(description=\"What a wonderful tracker description!\", project_id=2123132)\n            &gt;&gt;&gt; tracker_endpoint.edit(58687684, body)\n            TogglTracker(id=58687684, name=\"What a wonderful tracker description!\", project=2123132, ...)\n\n        Args:\n            tracker: Target tracker model or id to edit.\n            body: Updated content to add.\n            meta: Should the response contain data for meta entities.\n\n        Raises:\n            HTTPStatusError: For anything thats not a *ok* status code.\n\n        Returns:\n            A new model if successful else None.\n        \"\"\"\n        if (body.tag_ids or body.tags) and not body.tag_action:\n            body.tag_action = \"add\"\n\n        if isinstance(tracker, TogglTracker):\n            tracker = tracker.id\n\n        return cast(\n            \"TogglTracker\",\n            self.request(\n                f\"{self.endpoint}/{tracker}\",\n                method=RequestMethod.PUT,\n                body=body.format(\n                    \"edit\",\n                    workspace_id=self.workspace_id,\n                    meta=meta,\n                ),\n                refresh=True,\n            ),\n        )\n\n    def _bulk_edit(\n        self,\n        trackers: list[int],\n        body: list[BulkEditParameter],\n    ) -&gt; dict[str, list[int]]:\n        return cast(\n            \"dict[str, list[int]]\",\n            cast(\n                \"Response\",\n                self.request(\n                    f\"{self.endpoint}/\" + \",\".join([str(t) for t in trackers]),\n                    body=body,\n                    refresh=True,\n                    method=RequestMethod.PATCH,\n                    raw=True,\n                ),\n            ).json(),\n        )\n\n    def bulk_edit(\n        self,\n        *trackers: int | TogglTracker,\n        body: TrackerBody,\n    ) -&gt; Edits:\n        \"\"\"Bulk edit multiple trackers at the same time.\n\n        Patch will be executed partially when there are errors with some records.\n        No transaction, no rollback.\n\n        There is a limit of editing 100 trackers at the same time, so the\n        method will make multiple calls if the count exceeds that limit.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/time_entries/#patch-bulk-editing-time-entries)\n\n        Examples:\n            &gt;&gt;&gt; body = TrackerBody(description=\"All these trackers belong to me!\")\n            &gt;&gt;&gt; tracker_endpoint.bulk_edit(1235151, 214124, body)\n            Edits(successes=[1235151, 214124], failures=[])\n\n        Args:\n            trackers: All trackers that need to be edited.\n            body: The parameters that need to be edited.\n\n        Raises:\n            HTTPStatusError: For anything thats not a *ok* status code.\n\n        Returns:\n            Successeful or failed ids editing the trackers.\n        \"\"\"\n        tracker_ids = [t if isinstance(t, int) else t.id for t in trackers]\n        requests = math.ceil(len(tracker_ids) / 100)\n        success: list[int]\n        failure: list[int]\n        success, failure = [], []\n\n        fmt_body = body._format_bulk_edit()  # noqa: SLF001\n        for i in range(requests):\n            edit = self._bulk_edit(\n                tracker_ids[100 * i : 100 + (100 * i)],\n                fmt_body,\n            )\n            success.extend(edit[\"success\"])\n            failure.extend(edit[\"failure\"])\n\n        return Edits(success, failure)\n\n    def delete(self, tracker: TogglTracker | int) -&gt; None:\n        \"\"\"Delete a tracker from Toggl.\n\n        This endpoint always hit the external API in order to keep trackers consistent.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/time_entries#delete-timeentries)\n\n        Examples:\n            &gt;&gt;&gt; tracker_endpoint.delete(58687684)\n            None\n\n        Args:\n            tracker: Tracker object with ID to delete.\n\n        Raises:\n            HTTPStatusError: If anything thats not a '404' or 'ok' code is returned.\n\n        \"\"\"\n        tracker_id = tracker if isinstance(tracker, int) else tracker.id\n        try:\n            self.request(\n                f\"{self.endpoint}/{tracker_id}\",\n                method=RequestMethod.DELETE,\n                refresh=True,\n            )\n        except HTTPStatusError as err:\n            if self.re_raise or err.response.status_code != codes.NOT_FOUND:\n                raise\n            log.warning(\n                \"Tracker with id %s was either already deleted or did not exist in the first place!\",\n                tracker_id,\n            )\n        if self.cache is None:\n            return\n\n        if isinstance(tracker, int):\n            trk = self.cache.find({\"id\": tracker})\n            if not isinstance(trk, TogglTracker):\n                return\n            tracker = trk\n\n        self.cache.delete(tracker)\n        self.cache.commit()\n\n    def stop(self, tracker: TogglTracker | int) -&gt; TogglTracker | None:\n        \"\"\"Stop the currently running tracker.\n\n        This endpoint always hit the external API in order to keep trackers consistent.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/time_entries#patch-stop-timeentry)\n\n        Examples:\n            &gt;&gt;&gt; tracker_endpoint.stop(58687684)\n            TogglTracker(id=58687684, name=\"What a wonderful tracker description!\", ...)\n\n        Args:\n            tracker: Tracker id to stop. An integer or model.\n\n        Raises:\n            HTTPStatusError: For anything thats not 'ok' or a '409' status code.\n\n        Returns:\n           If the tracker was stopped or if the tracker wasn't running it will return None.\n        \"\"\"\n        if isinstance(tracker, TogglTracker):\n            tracker = tracker.id\n        try:\n            return cast(\n                \"TogglTracker\",\n                self.request(\n                    f\"{self.endpoint}/{tracker}/stop\",\n                    method=RequestMethod.PATCH,\n                    refresh=True,\n                ),\n            )\n        except HTTPStatusError as err:\n            if self.re_raise or err.response.status_code != self.TRACKER_ALREADY_STOPPED:\n                raise\n            log.warning(\"Tracker with id %s was already stopped!\", tracker)\n        return None\n\n    def add(self, body: TrackerBody) -&gt; TogglTracker:\n        \"\"\"Add a new tracker.\n\n        This endpoint always hit the external API in order to keep trackers consistent.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/time_entries#post-timeentries)\n\n        Examples:\n            &gt;&gt;&gt; body = TrackerBody(description=\"Tracker description!\", project_id=2123132)\n            &gt;&gt;&gt; tracker_endpoint.edit(body)\n            TogglTracker(id=78895400, name=\"Tracker description!\", project=2123132, ...)\n\n        Args:\n            body: Body of the request. Description must be set. If start date\n                is not set it will be set to current time with duration set\n                to -1 for a running tracker.\n\n        Raises:\n            HTTPStatusError: For anything that wasn't an *ok* status code.\n            NamingError: Description must be set in order to create a new tracker.\n\n        Returns:\n            The tracker that was created.\n        \"\"\"\n        if not body.description:\n            msg = \"Description must be set in order to create a tracker!\"\n            raise NamingError(msg)\n\n        if body.start is None:\n            body.start = datetime.now(tz=timezone.utc)\n            log.info(\n                \"Body is missing a start. Setting to %s...\",\n                body.start,\n                extra={\"body\": body},\n            )\n            if body.stop is None:\n                body.duration = -1\n\n        body.tag_action = \"add\"\n\n        return cast(\n            \"TogglTracker\",\n            self.request(\n                self.endpoint,\n                method=RequestMethod.POST,\n                body=body.format(\"add\", workspace_id=self.workspace_id),\n                refresh=True,\n            ),\n        )\n\n    @property\n    def endpoint(self) -&gt; str:\n        return f\"workspaces/{self.workspace_id}/time_entries\"\n</code></pre>"},{"location":"api-guide/tracker.html#toggl_api.TrackerEndpoint.current","title":"current","text":"<pre><code>current(*, refresh: bool = True) -&gt; TogglTracker | None\n</code></pre> <p>Get current running tracker. Returns None if no tracker is running.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tracker_endpoint.current()\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; tracker_endpoint.current(refresh=True)\nTogglTracker(...)\n</code></pre> PARAMETER DESCRIPTION <code>refresh</code> <p>Whether to check the remote API for running trackers. If 'refresh' is True it will check if there are any other running trackers and update if the 'stop' attribute is None.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If the request is not a success or any error that's not a '405' status code.</p> RETURNS DESCRIPTION <code>TogglTracker | None</code> <p>A model from cache or the API. None if nothing is running.</p> Source code in <code>src/toggl_api/_tracker.py</code> <pre><code>def current(self, *, refresh: bool = True) -&gt; TogglTracker | None:\n    \"\"\"Get current running tracker. Returns None if no tracker is running.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/time_entries#get-get-current-time-entry)\n\n    Examples:\n        &gt;&gt;&gt; tracker_endpoint.current()\n        None\n\n        &gt;&gt;&gt; tracker_endpoint.current(refresh=True)\n        TogglTracker(...)\n\n    Args:\n        refresh: Whether to check the remote API for running trackers.\n            If 'refresh' is True it will check if there are any other running\n            trackers and update if the 'stop' attribute is None.\n\n    Raises:\n        HTTPStatusError: If the request is not a success or any error that's\n            not a '405' status code.\n\n    Returns:\n        A model from cache or the API. None if nothing is running.\n    \"\"\"\n    if self.cache and not refresh:\n        query = list(self.cache.query(TogglQuery(\"stop\", None)))\n        return query[0] if query else None\n\n    try:\n        response = self.request(\"me/time_entries/current\", refresh=refresh)\n    except HTTPStatusError as err:\n        if not self.re_raise and err.response.status_code == self.TRACKER_NOT_RUNNING:\n            log.warning(\"No tracker is currently running!\")\n            response = None\n        else:\n            raise\n\n    self._current_refresh(cast(\"TogglTracker | None\", response))\n\n    return response if isinstance(response, TogglTracker) else None\n</code></pre>"},{"location":"api-guide/tracker.html#toggl_api.TrackerEndpoint.collect","title":"collect","text":"<pre><code>collect(\n    since: int | datetime | None = None,\n    before: date | None = None,\n    start_date: date | None = None,\n    end_date: date | None = None,\n    *,\n    refresh: bool = False,\n) -&gt; list[TogglTracker]\n</code></pre> <p>Get a set of trackers depending on specified parameters.</p> <p>Official Documentation</p> <p>Missing meta and include_sharing query flags not supported by wrapper at the moment.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; collect(since=17300032362, before=date(2024, 11, 27))\n</code></pre> <pre><code>&gt;&gt;&gt; collect(refresh=True)\n</code></pre> <pre><code>&gt;&gt;&gt; collect(start_date=date(2024, 11, 27), end_date=date(2024, 12, 27))\n</code></pre> PARAMETER DESCRIPTION <code>since</code> <p>Get entries modified since this date using UNIX timestamp. Includes deleted ones if refreshing.</p> <p> TYPE: <code>int | datetime | None</code> DEFAULT: <code>None</code> </p> <code>before</code> <p>Get entries with start time, before given date (YYYY-MM-DD) or with time in RFC3339 format.</p> <p> TYPE: <code>date | None</code> DEFAULT: <code>None</code> </p> <code>start_date</code> <p>Get entries with start time, from start_date YYYY-MM-DD or with time in RFC3339 format. To be used with end_date.</p> <p> TYPE: <code>date | None</code> DEFAULT: <code>None</code> </p> <code>end_date</code> <p>Get entries with start time, until end_date YYYY-MM-DD or with time in RFC3339 format. To be used with start_date.</p> <p> TYPE: <code>date | None</code> DEFAULT: <code>None</code> </p> <code>refresh</code> <p>Whether to refresh the cache or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>DateTimeError</code> <p>If the dates are not in the correct ranges.</p> <code>HTTPStatusError</code> <p>If the request is not a successful status code.</p> RETURNS DESCRIPTION <code>list[TogglTracker]</code> <p>List of TogglTracker objects that are within specified parameters.   Empty if none is matched.</p> Source code in <code>src/toggl_api/_tracker.py</code> <pre><code>def collect(\n    self,\n    since: int | datetime | None = None,\n    before: date | None = None,\n    start_date: date | None = None,\n    end_date: date | None = None,\n    *,\n    refresh: bool = False,\n) -&gt; list[TogglTracker]:\n    \"\"\"Get a set of trackers depending on specified parameters.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/time_entries#get-timeentries)\n\n    Missing meta and include_sharing query flags not supported by wrapper at\n    the moment.\n\n    Examples:\n        &gt;&gt;&gt; collect(since=17300032362, before=date(2024, 11, 27))\n\n        &gt;&gt;&gt; collect(refresh=True)\n\n        &gt;&gt;&gt; collect(start_date=date(2024, 11, 27), end_date=date(2024, 12, 27))\n\n    Args:\n        since: Get entries modified since this date using UNIX timestamp.\n            Includes deleted ones if refreshing.\n        before: Get entries with start time, before given date (YYYY-MM-DD)\n            or with time in RFC3339 format.\n        start_date: Get entries with start time, from start_date YYYY-MM-DD\n            or with time in RFC3339 format. To be used with end_date.\n        end_date: Get entries with start time, until end_date YYYY-MM-DD or\n            with time in RFC3339 format. To be used with start_date.\n        refresh: Whether to refresh the cache or not.\n\n    Raises:\n        DateTimeError: If the dates are not in the correct ranges.\n        HTTPStatusError: If the request is not a successful status code.\n\n    Returns:\n       List of TogglTracker objects that are within specified parameters.\n            Empty if none is matched.\n    \"\"\"\n    if start_date and end_date:\n        if end_date &lt; start_date:\n            msg = \"end_date must be after the start_date!\"\n            raise DateTimeError(msg)\n        if start_date &gt; datetime.now(tz=timezone.utc):\n            msg = \"start_date must not be earlier than the current date!\"\n            raise DateTimeError(msg)\n\n    if not refresh:\n        return self._collect_cache(since, before, start_date, end_date)\n\n    params = \"me/time_entries\"\n    if since or before:\n        if since:\n            params += f\"?since={get_timestamp(since)}\"\n\n        if before:\n            params += \"&amp;\" if since else \"?\"\n            params += f\"before={format_iso(before)}\"\n\n    elif start_date and end_date:\n        params += f\"?start_date={format_iso(start_date)}&amp;end_date={format_iso(end_date)}\"\n\n    response = self.request(params, refresh=refresh)\n\n    return response if isinstance(response, list) else []\n</code></pre>"},{"location":"api-guide/tracker.html#toggl_api.TrackerEndpoint.get","title":"get","text":"<pre><code>get(\n    tracker_id: int | TogglTracker, *, refresh: bool = False\n) -&gt; TogglTracker | None\n</code></pre> <p>Get a single tracker by ID.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>tracker_id</code> <p>ID of the tracker to get.</p> <p> TYPE: <code>int | TogglTracker</code> </p> <code>refresh</code> <p>Whether to refresh the cache or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If anything thats not a ok or 404 status code is returned.</p> RETURNS DESCRIPTION <code>TogglTracker | None</code> <p>TogglTracker object or None if not found.</p> Source code in <code>src/toggl_api/_tracker.py</code> <pre><code>def get(\n    self,\n    tracker_id: int | TogglTracker,\n    *,\n    refresh: bool = False,\n) -&gt; TogglTracker | None:\n    \"\"\"Get a single tracker by ID.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/time_entries#get-get-a-time-entry-by-id)\n\n    Args:\n        tracker_id: ID of the tracker to get.\n        refresh: Whether to refresh the cache or not.\n\n    Raises:\n        HTTPStatusError: If anything thats not a *ok* or *404* status code\n            is returned.\n\n    Returns:\n        TogglTracker object or None if not found.\n    \"\"\"\n    if isinstance(tracker_id, TogglTracker):\n        tracker_id = tracker_id.id\n\n    if self.cache and not refresh:\n        return self.cache.find({\"id\": tracker_id})\n\n    try:\n        response = self.request(\n            f\"me/time_entries/{tracker_id}\",\n            refresh=refresh,\n        )\n    except HTTPStatusError as err:\n        if not self.re_raise and err.response.status_code == codes.NOT_FOUND:\n            log.warning(\"Tracker with id %s does not exist!\", tracker_id)\n            return None\n        raise\n\n    return cast(\"TogglTracker\", response)\n</code></pre>"},{"location":"api-guide/tracker.html#toggl_api.TrackerEndpoint.add","title":"add","text":"<pre><code>add(body: TrackerBody) -&gt; TogglTracker\n</code></pre> <p>Add a new tracker.</p> <p>This endpoint always hit the external API in order to keep trackers consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; body = TrackerBody(description=\"Tracker description!\", project_id=2123132)\n&gt;&gt;&gt; tracker_endpoint.edit(body)\nTogglTracker(id=78895400, name=\"Tracker description!\", project=2123132, ...)\n</code></pre> PARAMETER DESCRIPTION <code>body</code> <p>Body of the request. Description must be set. If start date is not set it will be set to current time with duration set to -1 for a running tracker.</p> <p> TYPE: <code>TrackerBody</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything that wasn't an ok status code.</p> <code>NamingError</code> <p>Description must be set in order to create a new tracker.</p> RETURNS DESCRIPTION <code>TogglTracker</code> <p>The tracker that was created.</p> Source code in <code>src/toggl_api/_tracker.py</code> <pre><code>def add(self, body: TrackerBody) -&gt; TogglTracker:\n    \"\"\"Add a new tracker.\n\n    This endpoint always hit the external API in order to keep trackers consistent.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/time_entries#post-timeentries)\n\n    Examples:\n        &gt;&gt;&gt; body = TrackerBody(description=\"Tracker description!\", project_id=2123132)\n        &gt;&gt;&gt; tracker_endpoint.edit(body)\n        TogglTracker(id=78895400, name=\"Tracker description!\", project=2123132, ...)\n\n    Args:\n        body: Body of the request. Description must be set. If start date\n            is not set it will be set to current time with duration set\n            to -1 for a running tracker.\n\n    Raises:\n        HTTPStatusError: For anything that wasn't an *ok* status code.\n        NamingError: Description must be set in order to create a new tracker.\n\n    Returns:\n        The tracker that was created.\n    \"\"\"\n    if not body.description:\n        msg = \"Description must be set in order to create a tracker!\"\n        raise NamingError(msg)\n\n    if body.start is None:\n        body.start = datetime.now(tz=timezone.utc)\n        log.info(\n            \"Body is missing a start. Setting to %s...\",\n            body.start,\n            extra={\"body\": body},\n        )\n        if body.stop is None:\n            body.duration = -1\n\n    body.tag_action = \"add\"\n\n    return cast(\n        \"TogglTracker\",\n        self.request(\n            self.endpoint,\n            method=RequestMethod.POST,\n            body=body.format(\"add\", workspace_id=self.workspace_id),\n            refresh=True,\n        ),\n    )\n</code></pre>"},{"location":"api-guide/tracker.html#toggl_api.TrackerEndpoint.edit","title":"edit","text":"<pre><code>edit(\n    tracker: TogglTracker | int, body: TrackerBody, *, meta: bool = False\n) -&gt; TogglTracker\n</code></pre> <p>Edit an existing tracker based on the supplied parameters within the body.</p> <p>This endpoint always hit the external API in order to keep trackers consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; body = TrackerBody(description=\"What a wonderful tracker description!\", project_id=2123132)\n&gt;&gt;&gt; tracker_endpoint.edit(58687684, body)\nTogglTracker(id=58687684, name=\"What a wonderful tracker description!\", project=2123132, ...)\n</code></pre> PARAMETER DESCRIPTION <code>tracker</code> <p>Target tracker model or id to edit.</p> <p> TYPE: <code>TogglTracker | int</code> </p> <code>body</code> <p>Updated content to add.</p> <p> TYPE: <code>TrackerBody</code> </p> <code>meta</code> <p>Should the response contain data for meta entities.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything thats not a ok status code.</p> RETURNS DESCRIPTION <code>TogglTracker</code> <p>A new model if successful else None.</p> Source code in <code>src/toggl_api/_tracker.py</code> <pre><code>def edit(\n    self,\n    tracker: TogglTracker | int,\n    body: TrackerBody,\n    *,\n    meta: bool = False,\n) -&gt; TogglTracker:\n    \"\"\"Edit an existing tracker based on the supplied parameters within the body.\n\n    This endpoint always hit the external API in order to keep trackers consistent.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/time_entries#put-timeentries)\n\n    Examples:\n        &gt;&gt;&gt; body = TrackerBody(description=\"What a wonderful tracker description!\", project_id=2123132)\n        &gt;&gt;&gt; tracker_endpoint.edit(58687684, body)\n        TogglTracker(id=58687684, name=\"What a wonderful tracker description!\", project=2123132, ...)\n\n    Args:\n        tracker: Target tracker model or id to edit.\n        body: Updated content to add.\n        meta: Should the response contain data for meta entities.\n\n    Raises:\n        HTTPStatusError: For anything thats not a *ok* status code.\n\n    Returns:\n        A new model if successful else None.\n    \"\"\"\n    if (body.tag_ids or body.tags) and not body.tag_action:\n        body.tag_action = \"add\"\n\n    if isinstance(tracker, TogglTracker):\n        tracker = tracker.id\n\n    return cast(\n        \"TogglTracker\",\n        self.request(\n            f\"{self.endpoint}/{tracker}\",\n            method=RequestMethod.PUT,\n            body=body.format(\n                \"edit\",\n                workspace_id=self.workspace_id,\n                meta=meta,\n            ),\n            refresh=True,\n        ),\n    )\n</code></pre>"},{"location":"api-guide/tracker.html#toggl_api.TrackerEndpoint.bulk_edit","title":"bulk_edit","text":"<pre><code>bulk_edit(*trackers: int | TogglTracker, body: TrackerBody) -&gt; Edits\n</code></pre> <p>Bulk edit multiple trackers at the same time.</p> <p>Patch will be executed partially when there are errors with some records. No transaction, no rollback.</p> <p>There is a limit of editing 100 trackers at the same time, so the method will make multiple calls if the count exceeds that limit.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; body = TrackerBody(description=\"All these trackers belong to me!\")\n&gt;&gt;&gt; tracker_endpoint.bulk_edit(1235151, 214124, body)\nEdits(successes=[1235151, 214124], failures=[])\n</code></pre> PARAMETER DESCRIPTION <code>trackers</code> <p>All trackers that need to be edited.</p> <p> TYPE: <code>int | TogglTracker</code> DEFAULT: <code>()</code> </p> <code>body</code> <p>The parameters that need to be edited.</p> <p> TYPE: <code>TrackerBody</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything thats not a ok status code.</p> RETURNS DESCRIPTION <code>Edits</code> <p>Successeful or failed ids editing the trackers.</p> Source code in <code>src/toggl_api/_tracker.py</code> <pre><code>def bulk_edit(\n    self,\n    *trackers: int | TogglTracker,\n    body: TrackerBody,\n) -&gt; Edits:\n    \"\"\"Bulk edit multiple trackers at the same time.\n\n    Patch will be executed partially when there are errors with some records.\n    No transaction, no rollback.\n\n    There is a limit of editing 100 trackers at the same time, so the\n    method will make multiple calls if the count exceeds that limit.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/time_entries/#patch-bulk-editing-time-entries)\n\n    Examples:\n        &gt;&gt;&gt; body = TrackerBody(description=\"All these trackers belong to me!\")\n        &gt;&gt;&gt; tracker_endpoint.bulk_edit(1235151, 214124, body)\n        Edits(successes=[1235151, 214124], failures=[])\n\n    Args:\n        trackers: All trackers that need to be edited.\n        body: The parameters that need to be edited.\n\n    Raises:\n        HTTPStatusError: For anything thats not a *ok* status code.\n\n    Returns:\n        Successeful or failed ids editing the trackers.\n    \"\"\"\n    tracker_ids = [t if isinstance(t, int) else t.id for t in trackers]\n    requests = math.ceil(len(tracker_ids) / 100)\n    success: list[int]\n    failure: list[int]\n    success, failure = [], []\n\n    fmt_body = body._format_bulk_edit()  # noqa: SLF001\n    for i in range(requests):\n        edit = self._bulk_edit(\n            tracker_ids[100 * i : 100 + (100 * i)],\n            fmt_body,\n        )\n        success.extend(edit[\"success\"])\n        failure.extend(edit[\"failure\"])\n\n    return Edits(success, failure)\n</code></pre>"},{"location":"api-guide/tracker.html#toggl_api.TrackerEndpoint.delete","title":"delete","text":"<pre><code>delete(tracker: TogglTracker | int) -&gt; None\n</code></pre> <p>Delete a tracker from Toggl.</p> <p>This endpoint always hit the external API in order to keep trackers consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tracker_endpoint.delete(58687684)\nNone\n</code></pre> PARAMETER DESCRIPTION <code>tracker</code> <p>Tracker object with ID to delete.</p> <p> TYPE: <code>TogglTracker | int</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If anything thats not a '404' or 'ok' code is returned.</p> Source code in <code>src/toggl_api/_tracker.py</code> <pre><code>def delete(self, tracker: TogglTracker | int) -&gt; None:\n    \"\"\"Delete a tracker from Toggl.\n\n    This endpoint always hit the external API in order to keep trackers consistent.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/time_entries#delete-timeentries)\n\n    Examples:\n        &gt;&gt;&gt; tracker_endpoint.delete(58687684)\n        None\n\n    Args:\n        tracker: Tracker object with ID to delete.\n\n    Raises:\n        HTTPStatusError: If anything thats not a '404' or 'ok' code is returned.\n\n    \"\"\"\n    tracker_id = tracker if isinstance(tracker, int) else tracker.id\n    try:\n        self.request(\n            f\"{self.endpoint}/{tracker_id}\",\n            method=RequestMethod.DELETE,\n            refresh=True,\n        )\n    except HTTPStatusError as err:\n        if self.re_raise or err.response.status_code != codes.NOT_FOUND:\n            raise\n        log.warning(\n            \"Tracker with id %s was either already deleted or did not exist in the first place!\",\n            tracker_id,\n        )\n    if self.cache is None:\n        return\n\n    if isinstance(tracker, int):\n        trk = self.cache.find({\"id\": tracker})\n        if not isinstance(trk, TogglTracker):\n            return\n        tracker = trk\n\n    self.cache.delete(tracker)\n    self.cache.commit()\n</code></pre>"},{"location":"api-guide/tracker.html#toggl_api.TrackerEndpoint.stop","title":"stop","text":"<pre><code>stop(tracker: TogglTracker | int) -&gt; TogglTracker | None\n</code></pre> <p>Stop the currently running tracker.</p> <p>This endpoint always hit the external API in order to keep trackers consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tracker_endpoint.stop(58687684)\nTogglTracker(id=58687684, name=\"What a wonderful tracker description!\", ...)\n</code></pre> PARAMETER DESCRIPTION <code>tracker</code> <p>Tracker id to stop. An integer or model.</p> <p> TYPE: <code>TogglTracker | int</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything thats not 'ok' or a '409' status code.</p> RETURNS DESCRIPTION <code>TogglTracker | None</code> <p>If the tracker was stopped or if the tracker wasn't running it will return None.</p> Source code in <code>src/toggl_api/_tracker.py</code> <pre><code>def stop(self, tracker: TogglTracker | int) -&gt; TogglTracker | None:\n    \"\"\"Stop the currently running tracker.\n\n    This endpoint always hit the external API in order to keep trackers consistent.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/time_entries#patch-stop-timeentry)\n\n    Examples:\n        &gt;&gt;&gt; tracker_endpoint.stop(58687684)\n        TogglTracker(id=58687684, name=\"What a wonderful tracker description!\", ...)\n\n    Args:\n        tracker: Tracker id to stop. An integer or model.\n\n    Raises:\n        HTTPStatusError: For anything thats not 'ok' or a '409' status code.\n\n    Returns:\n       If the tracker was stopped or if the tracker wasn't running it will return None.\n    \"\"\"\n    if isinstance(tracker, TogglTracker):\n        tracker = tracker.id\n    try:\n        return cast(\n            \"TogglTracker\",\n            self.request(\n                f\"{self.endpoint}/{tracker}/stop\",\n                method=RequestMethod.PATCH,\n                refresh=True,\n            ),\n        )\n    except HTTPStatusError as err:\n        if self.re_raise or err.response.status_code != self.TRACKER_ALREADY_STOPPED:\n            raise\n        log.warning(\"Tracker with id %s was already stopped!\", tracker)\n    return None\n</code></pre>"},{"location":"api-guide/tracker.html#toggl_api.asyncio.AsyncTrackerEndpoint","title":"toggl_api.asyncio.AsyncTrackerEndpoint","text":"<p>               Bases: <code>TogglAsyncCachedEndpoint[TogglTracker]</code></p> <p>Endpoint for modifying and creating trackers.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tracker_endpoint = TrackerEndpoint(324525, BasicAuth(...), AsyncSqliteCache(Path(\"cache\")))\n</code></pre> <pre><code>&gt;&gt;&gt; body = TrackerBody(description=\"What a wonderful tracker description!\", project_id=2123132)\n&gt;&gt;&gt; await tracker_endpoint.add(body)\nTogglTracker(id=58687689, name=\"What a wonderful tracker description!\", project=2123132, ...)\n</code></pre> <pre><code>&gt;&gt;&gt; await tracker_endpoint.delete(tracker)\nNone\n</code></pre> PARAMETER DESCRIPTION <code>workspace_id</code> <p>The workspace the Toggl trackers belong to.</p> <p> TYPE: <code>int | TogglWorkspace</code> </p> <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>cache</code> <p>Where to cache trackers. Currently async only supports SQLite.</p> <p> TYPE: <code>AsyncSqliteCache[TogglTracker] | None</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>Optional async client to be passed to be used for requests.</p> <p> TYPE: <code>AsyncClient | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>current</code> <p>Get current running tracker. Returns None if no tracker is running.</p> <code>collect</code> <p>Get a set of trackers depending on specified parameters.</p> <code>get</code> <p>Get a single tracker by ID.</p> <code>edit</code> <p>Edit an existing tracker based on the supplied parameters within the body.</p> <code>bulk_edit</code> <p>Bulk edit multiple trackers at the same time.</p> <code>delete</code> <p>Delete a tracker from Toggl.</p> <code>stop</code> <p>Stop the current running tracker.</p> <code>add</code> <p>Add a new tracker.</p>"},{"location":"api-guide/tracker.html#toggl_api.asyncio.AsyncTrackerEndpoint.current","title":"current  <code>async</code>","text":"<pre><code>current(*, refresh: bool = True) -&gt; TogglTracker | None\n</code></pre> <p>Get current running tracker. Returns None if no tracker is running.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await tracker_endpoint.current()\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; await tracker_endpoint.current(refresh=True)\nTogglTracker(...)\n</code></pre> PARAMETER DESCRIPTION <code>refresh</code> <p>Whether to check the remote API for running trackers. If 'refresh' is True it will check if there are any other running trackers and update if the 'stop' attribute is None.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If the request is not a success or any error that's not a '405' status code.</p> RETURNS DESCRIPTION <code>TogglTracker | None</code> <p>A model from cache or the API. None if nothing is running.</p>"},{"location":"api-guide/tracker.html#toggl_api.asyncio.AsyncTrackerEndpoint.collect","title":"collect  <code>async</code>","text":"<pre><code>collect(\n    since: int | datetime | None = None,\n    before: date | None = None,\n    start_date: date | None = None,\n    end_date: date | None = None,\n    *,\n    refresh: bool = False,\n) -&gt; list[TogglTracker]\n</code></pre> <p>Get a set of trackers depending on specified parameters.</p> <p>Official Documentation</p> <p>Missing meta and include_sharing query flags not supported by wrapper at the moment.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await tracker_ep.collect(since=17300032362, before=date(2024, 11, 27))\n</code></pre> <pre><code>&gt;&gt;&gt; await tracker_ep.collect(refresh=True)\n</code></pre> <pre><code>&gt;&gt;&gt; await tracker_ep.collect(start_date=date(2024, 11, 27), end_date=date(2024, 12, 27))\n</code></pre> PARAMETER DESCRIPTION <code>since</code> <p>Get entries modified since this date using UNIX timestamp. Includes deleted ones if refreshing.</p> <p> TYPE: <code>int | datetime | None</code> DEFAULT: <code>None</code> </p> <code>before</code> <p>Get entries with start time, before given date (YYYY-MM-DD) or with time in RFC3339 format.</p> <p> TYPE: <code>date | None</code> DEFAULT: <code>None</code> </p> <code>start_date</code> <p>Get entries with start time, from start_date YYYY-MM-DD or with time in RFC3339 format. To be used with end_date.</p> <p> TYPE: <code>date | None</code> DEFAULT: <code>None</code> </p> <code>end_date</code> <p>Get entries with start time, until end_date YYYY-MM-DD or with time in RFC3339 format. To be used with start_date.</p> <p> TYPE: <code>date | None</code> DEFAULT: <code>None</code> </p> <code>refresh</code> <p>Whether to refresh the cache or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>DateTimeError</code> <p>If the dates are not in the correct ranges.</p> <code>HTTPStatusError</code> <p>If the request is not a successful status code.</p> RETURNS DESCRIPTION <code>list[TogglTracker]</code> <p>List of TogglTracker objects that are within specified parameters.   Empty if none is matched.</p>"},{"location":"api-guide/tracker.html#toggl_api.asyncio.AsyncTrackerEndpoint.get","title":"get  <code>async</code>","text":"<pre><code>get(\n    tracker_id: int | TogglTracker, *, refresh: bool = False\n) -&gt; TogglTracker | None\n</code></pre> <p>Get a single tracker by ID.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>tracker_id</code> <p>ID of the tracker to get.</p> <p> TYPE: <code>int | TogglTracker</code> </p> <code>refresh</code> <p>Whether to refresh the cache or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If anything thats not a ok or 404 status code is returned.</p> RETURNS DESCRIPTION <code>TogglTracker | None</code> <p>TogglTracker object or None if not found.</p>"},{"location":"api-guide/tracker.html#toggl_api.asyncio.AsyncTrackerEndpoint.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(\n    tracker: TogglTracker | int, body: TrackerBody, *, meta: bool = False\n) -&gt; TogglTracker\n</code></pre> <p>Edit an existing tracker based on the supplied parameters within the body.</p> <p>This endpoint always hit the external API in order to keep trackers consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; body = TrackerBody(description=\"What a wonderful tracker description!\", project_id=2123132)\n&gt;&gt;&gt; await tracker_endpoint.edit(58687684, body)\nTogglTracker(id=58687684, name=\"What a wonderful tracker description!\", project=2123132, ...)\n</code></pre> PARAMETER DESCRIPTION <code>tracker</code> <p>Target tracker model or id to edit.</p> <p> TYPE: <code>TogglTracker | int</code> </p> <code>body</code> <p>Updated content to add.</p> <p> TYPE: <code>TrackerBody</code> </p> <code>meta</code> <p>Should the response contain data for meta entities.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything thats not a ok status code.</p> RETURNS DESCRIPTION <code>TogglTracker</code> <p>A new model if successful else None.</p>"},{"location":"api-guide/tracker.html#toggl_api.asyncio.AsyncTrackerEndpoint.bulk_edit","title":"bulk_edit  <code>async</code>","text":"<pre><code>bulk_edit(*trackers: int | TogglTracker, body: TrackerBody) -&gt; Edits\n</code></pre> <p>Bulk edit multiple trackers at the same time.</p> <p>Patch will be executed partially when there are errors with some records. No transaction, no rollback.</p> <p>There is a limit of editing 100 trackers at the same time, so the method will make multiple calls if the count exceeds that limit.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; body = TrackerBody(description=\"All these trackers belong to me!\")\n&gt;&gt;&gt; await tracker_endpoint.bulk_edit(1235151, 214124, body)\nEdits(successes=[1235151, 214124], failures=[])\n</code></pre> PARAMETER DESCRIPTION <code>trackers</code> <p>All trackers that need to be edited.</p> <p> TYPE: <code>int | TogglTracker</code> DEFAULT: <code>()</code> </p> <code>body</code> <p>The parameters that need to be edited.</p> <p> TYPE: <code>TrackerBody</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything thats not a ok status code.</p> RETURNS DESCRIPTION <code>Edits</code> <p>Successeful or failed ids editing the trackers.</p>"},{"location":"api-guide/tracker.html#toggl_api.asyncio.AsyncTrackerEndpoint.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(tracker: TogglTracker | int) -&gt; None\n</code></pre> <p>Delete a tracker from Toggl.</p> <p>This endpoint always hit the external API in order to keep trackers consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await tracker_endpoint.delete(58687684)\nNone\n</code></pre> PARAMETER DESCRIPTION <code>tracker</code> <p>Tracker object with ID to delete.</p> <p> TYPE: <code>TogglTracker | int</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If anything thats not a '404' or 'ok' code is returned.</p>"},{"location":"api-guide/tracker.html#toggl_api.asyncio.AsyncTrackerEndpoint.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(tracker: TogglTracker | int) -&gt; TogglTracker | None\n</code></pre> <p>Stop the current running tracker.</p> <p>This endpoint always hit the external API in order to keep trackers consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await tracker_endpoint.stop(58687684)\nTogglTracker(id=58687684, name=\"What a wonderful tracker description!\", ...)\n</code></pre> PARAMETER DESCRIPTION <code>tracker</code> <p>Tracker id to stop. An integer or model.</p> <p> TYPE: <code>TogglTracker | int</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything thats not 'ok' or a '409' status code.</p> RETURNS DESCRIPTION <code>TogglTracker | None</code> <p>If the tracker was stopped or if the tracker wasn't running it will return None.</p>"},{"location":"api-guide/tracker.html#toggl_api.asyncio.AsyncTrackerEndpoint.add","title":"add  <code>async</code>","text":"<pre><code>add(body: TrackerBody) -&gt; TogglTracker\n</code></pre> <p>Add a new tracker.</p> <p>This endpoint always hit the external API in order to keep trackers consistent.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; body = TrackerBody(description=\"Tracker description!\", project_id=2123132)\n&gt;&gt;&gt; await tracker_endpoint.edit(body)\nTogglTracker(id=78895400, name=\"Tracker description!\", project=2123132, ...)\n</code></pre> PARAMETER DESCRIPTION <code>body</code> <p>Body of the request. Description must be set. If start date is not set it will be set to current time with duration set to -1 for a running tracker.</p> <p> TYPE: <code>TrackerBody</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything that wasn't an ok status code.</p> <code>NamingError</code> <p>Description must be set in order to create a new tracker.</p> RETURNS DESCRIPTION <code>TogglTracker</code> <p>The tracker that was created.</p>"},{"location":"api-guide/tracker.html#types","title":"Types","text":""},{"location":"api-guide/tracker.html#toggl_api.BulkEditParameter","title":"toggl_api.BulkEditParameter","text":"<p>               Bases: <code>TypedDict</code></p> Source code in <code>src/toggl_api/_tracker.py</code> <pre><code>class BulkEditParameter(TypedDict):\n    op: Literal[\"add\", \"remove\", \"replace\"]\n    path: str\n    value: Any\n</code></pre>"},{"location":"api-guide/tracker.html#toggl_api.Edits","title":"toggl_api.Edits","text":"<p>               Bases: <code>NamedTuple</code></p> Source code in <code>src/toggl_api/_tracker.py</code> <pre><code>class Edits(NamedTuple):\n    successes: list[int]\n    failures: list[int]\n</code></pre>"},{"location":"api-guide/user.html","title":"User","text":""},{"location":"api-guide/user.html#toggl_api.UserEndpoint","title":"toggl_api.UserEndpoint","text":"<p>               Bases: <code>TogglEndpoint[Any]</code></p> <p>Endpoint for retrieving user data.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>client</code> <p>Optional client to be passed to be used for requests. Useful when a global client is used and needs to be recycled.</p> <p> TYPE: <code>Client | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>Timeout | int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>verify_authentication</code> <p>Check if user is correctly authenticated with the Toggl API.</p> <code>get_details</code> <p>Return details for the current user.</p> Source code in <code>src/toggl_api/_user.py</code> <pre><code>class UserEndpoint(TogglEndpoint[Any]):\n    \"\"\"Endpoint for retrieving user data.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/me)\n\n    Params:\n        auth: Authentication for the client.\n        client: Optional client to be passed to be used for requests. Useful\n            when a global client is used and needs to be recycled.\n        timeout: How long it takes for the client to timeout. Keyword Only.\n            Defaults to 10 seconds.\n        re_raise: Whether to raise all HTTPStatusError errors and not handle them\n            internally. Keyword Only.\n        retries: Max retries to attempt if the server returns a *5xx* status_code.\n            Has no effect if re_raise is `True`. Keyword Only.\n    \"\"\"\n\n    def __init__(\n        self,\n        auth: BasicAuth,\n        *,\n        client: Client | None = None,\n        timeout: Timeout | int = 10,\n        re_raise: bool = False,\n        retries: int = 3,\n    ) -&gt; None:\n        super().__init__(\n            auth,\n            client=client,\n            timeout=timeout,\n            re_raise=re_raise,\n            retries=retries,\n        )\n\n    @staticmethod\n    def verify_authentication(\n        auth: BasicAuth,\n        *,\n        client: Client | None = None,\n    ) -&gt; bool:\n        \"\"\"Check if user is correctly authenticated with the Toggl API.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/me#get-logged)\n\n        Examples:\n            &gt;&gt;&gt; UserEndpoint.verify_authentication(auth)\n            True\n\n            &gt;&gt;&gt; auth = generate_authentication()\n            &gt;&gt;&gt; UserEndpoint.verify_authentication(auth)\n            True\n\n        Args:\n            auth: Basic authentication object either created manually or one\n                of the provided authentication utilities.\n            client: Optional client for making the requests with when using a\n                singleton/global client.\n\n        Raises:\n            HTTPStatusError: If anything that is error status code that is not\n                a FORBIDDEN code.\n\n        Returns:\n            True if successfully verified authentication else False.\n        \"\"\"\n        client = client or Client()\n        try:\n            client.get(\n                TogglEndpoint.BASE_ENDPOINT + \"me/logged\",\n                auth=auth,\n            ).raise_for_status()\n        except HTTPStatusError as err:\n            log.critical(\"Failed to verify authentication!\")\n            log.exception(\"%s\")\n            if err.response.status_code != codes.FORBIDDEN:\n                raise\n\n            return False\n\n        return True\n\n    def get_details(self) -&gt; dict[str, Any]:\n        \"\"\"Return details for the current user.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/me#get-me)\n\n        Raises:\n            HTTPStatusError: If the request is not a successful status code.\n\n        Returns:\n            User details in a raw dictionary.\n        \"\"\"\n        return cast(\n            \"dict[str, Any]\",\n            cast(\n                \"Response\",\n                self.request(\"me\", raw=True),\n            ).json(),\n        )\n</code></pre>"},{"location":"api-guide/user.html#toggl_api.UserEndpoint.verify_authentication","title":"verify_authentication  <code>staticmethod</code>","text":"<pre><code>verify_authentication(\n    auth: BasicAuth, *, client: Client | None = None\n) -&gt; bool\n</code></pre> <p>Check if user is correctly authenticated with the Toggl API.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; UserEndpoint.verify_authentication(auth)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; auth = generate_authentication()\n&gt;&gt;&gt; UserEndpoint.verify_authentication(auth)\nTrue\n</code></pre> PARAMETER DESCRIPTION <code>auth</code> <p>Basic authentication object either created manually or one of the provided authentication utilities.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>client</code> <p>Optional client for making the requests with when using a singleton/global client.</p> <p> TYPE: <code>Client | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If anything that is error status code that is not a FORBIDDEN code.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if successfully verified authentication else False.</p> Source code in <code>src/toggl_api/_user.py</code> <pre><code>@staticmethod\ndef verify_authentication(\n    auth: BasicAuth,\n    *,\n    client: Client | None = None,\n) -&gt; bool:\n    \"\"\"Check if user is correctly authenticated with the Toggl API.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/me#get-logged)\n\n    Examples:\n        &gt;&gt;&gt; UserEndpoint.verify_authentication(auth)\n        True\n\n        &gt;&gt;&gt; auth = generate_authentication()\n        &gt;&gt;&gt; UserEndpoint.verify_authentication(auth)\n        True\n\n    Args:\n        auth: Basic authentication object either created manually or one\n            of the provided authentication utilities.\n        client: Optional client for making the requests with when using a\n            singleton/global client.\n\n    Raises:\n        HTTPStatusError: If anything that is error status code that is not\n            a FORBIDDEN code.\n\n    Returns:\n        True if successfully verified authentication else False.\n    \"\"\"\n    client = client or Client()\n    try:\n        client.get(\n            TogglEndpoint.BASE_ENDPOINT + \"me/logged\",\n            auth=auth,\n        ).raise_for_status()\n    except HTTPStatusError as err:\n        log.critical(\"Failed to verify authentication!\")\n        log.exception(\"%s\")\n        if err.response.status_code != codes.FORBIDDEN:\n            raise\n\n        return False\n\n    return True\n</code></pre>"},{"location":"api-guide/user.html#toggl_api.UserEndpoint.get_details","title":"get_details","text":"<pre><code>get_details() -&gt; dict[str, Any]\n</code></pre> <p>Return details for the current user.</p> <p>Official Documentation</p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If the request is not a successful status code.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>User details in a raw dictionary.</p> Source code in <code>src/toggl_api/_user.py</code> <pre><code>def get_details(self) -&gt; dict[str, Any]:\n    \"\"\"Return details for the current user.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/me#get-me)\n\n    Raises:\n        HTTPStatusError: If the request is not a successful status code.\n\n    Returns:\n        User details in a raw dictionary.\n    \"\"\"\n    return cast(\n        \"dict[str, Any]\",\n        cast(\n            \"Response\",\n            self.request(\"me\", raw=True),\n        ).json(),\n    )\n</code></pre>"},{"location":"api-guide/user.html#toggl_api.asyncio.AsyncUserEndpoint","title":"toggl_api.asyncio.AsyncUserEndpoint","text":"<p>               Bases: <code>TogglAsyncEndpoint[Any]</code></p> <p>Endpoint for retrieving user data.</p> <p>The synchronous sibling UserEndpoint has access to static method for verifying authentication.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>client</code> <p>Optional async client to be passed to be used for requests.</p> <p> TYPE: <code>AsyncClient | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>get_details</code> <p>Return details for the current user.</p>"},{"location":"api-guide/user.html#toggl_api.asyncio.AsyncUserEndpoint.get_details","title":"get_details  <code>async</code>","text":"<pre><code>get_details() -&gt; dict[str, Any]\n</code></pre> <p>Return details for the current user.</p> <p>Official Documentation</p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If the request is not a successful status code.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>User details in a dictionary.</p>"},{"location":"api-guide/utility.html","title":"Utilities","text":""},{"location":"api-guide/utility.html#generate-placeholder-data","title":"Generate Placeholder Data","text":"<p>Info</p> <p>This script requires Faker to be installed. Install with <code>pip install faker</code>.</p>"},{"location":"api-guide/utility.html#entrypoint","title":"Entrypoint","text":"<pre><code>generate-fake-toggl-data\n</code></pre>"},{"location":"api-guide/utility.html#arguments-and-usage","title":"Arguments and Usage","text":""},{"location":"api-guide/utility.html#usage","title":"Usage","text":"<pre><code>usage: generate-fake-toggl-data [-h] [-s SEED] [--cache-type {sqlite,json}] cache_path\n</code></pre>"},{"location":"api-guide/utility.html#arguments","title":"Arguments","text":"Short Long Default Description <code>-h</code> <code>--help</code> Show this help message and exit. <code>-s</code> <code>--seed</code> <code>None</code> Set the seed value. <code>-t</code> <code>--cache-type</code> <code>None</code> Cache storage type. Required if <code>cache_path</code> doesn't end with .json or .sqlite."},{"location":"api-guide/utility.html#clean-toggl-account","title":"Clean Toggl Account","text":"<p>Warning</p> <p>This will permanently delete data off a Toggl account! Be sure of what you are doing before using this script.</p>"},{"location":"api-guide/utility.html#entrypoint_1","title":"Entrypoint","text":"<pre><code>clean-toggl-account\n</code></pre>"},{"location":"api-guide/utility.html#arguments-and-usage_1","title":"Arguments and Usage","text":""},{"location":"api-guide/utility.html#usage_1","title":"Usage","text":"<pre><code>usage: clean-toggl-account [-h] [-o {tracker,project,tag,client,org} [{tracker,project,tag,client,org} ...]]\n</code></pre>"},{"location":"api-guide/utility.html#arguments_1","title":"Arguments","text":"Short Long Default Description <code>-h</code> <code>--help</code> Show this help message and exit. <code>-o</code> <code>--objects</code> <code>None</code> Which objects not to parse."},{"location":"api-guide/workspace.html","title":"Workspace","text":""},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody","title":"toggl_api.WorkspaceBody  <code>dataclass</code>","text":"<p>               Bases: <code>BaseBody</code></p> METHOD DESCRIPTION <code>format</code> <p>Format the body into a usable format for a request.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Name of the workspace. Check TogglWorkspace static method for validation.</p> <p> TYPE: <code>str | None</code> </p> <code>admins</code> <p>List of admins, optional.</p> <p> TYPE: <code>list[int]</code> </p> <code>only_admins_may_create_projects</code> <p>Only admins will be able to create projects, optional,</p> <p> TYPE: <code>bool</code> </p> <code>only_admins_may_create_tags</code> <p>Only admins will be able to create tags, optional,</p> <p> TYPE: <code>bool</code> </p> <code>only_admins_see_billable_rates</code> <p>Whether only admins will be able to see billable rates, premium feature,</p> <p> TYPE: <code>bool</code> </p> <code>only_admins_see_team_dashboard</code> <p>Only admins will be able to see the team dashboard, optional,</p> <p> TYPE: <code>bool</code> </p> <code>projects_billable_by_default</code> <p>Whether projects will be set as billable by default, premium feature,</p> <p> TYPE: <code>bool</code> </p> <code>projects_enforce_billable</code> <p>Whether tracking time to projects will enforce billable setting to be respected.</p> <p> TYPE: <code>bool</code> </p> <code>projects_private_by_default</code> <p>Whether projects will be set to private by default, optional.</p> <p> TYPE: <code>bool</code> </p> <code>rate_change_mode</code> <p>The rate change mode, premium feature, optional, only for existing WS.</p> <p> TYPE: <code>Literal['start-today', 'override-current', 'override-all'] | None</code> </p> <code>reports_collapse</code> <p>Whether reports should be collapsed by default, optional,</p> <p> TYPE: <code>bool</code> </p> <code>rounding</code> <p>Default rounding, premium feature, optional, only for existing WS</p> <p> TYPE: <code>int | None</code> </p> <code>rounding_minutes</code> <p>Default rounding in minutes, premium feature, optional, only for existing WS</p> <p> TYPE: <code>int | None</code> </p> Source code in <code>src/toggl_api/_workspace.py</code> <pre><code>@dataclass\nclass WorkspaceBody(BaseBody):\n    name: str | None = field(default=None)\n    \"\"\"Name of the workspace. Check TogglWorkspace static method for validation.\"\"\"\n\n    admins: list[int] = field(\n        default_factory=list,\n        metadata={\n            \"endpoints\": frozenset((\"add\", \"edit\")),\n        },\n    )\n    \"\"\"List of admins, optional.\"\"\"\n\n    only_admins_may_create_projects: bool = field(\n        default=False,\n        metadata={\n            \"endpoints\": frozenset((\"add\", \"edit\")),\n        },\n    )\n    \"\"\"Only admins will be able to create projects, optional,\n    only for existing WS, will be false initially\"\"\"\n\n    only_admins_may_create_tags: bool = field(\n        default=False,\n        metadata={\n            \"endpoints\": frozenset((\"add\", \"edit\")),\n        },\n    )\n    \"\"\"Only admins will be able to create tags, optional,\n    only for existing WS, will be false initially\"\"\"\n\n    only_admins_see_billable_rates: bool = field(\n        default=False,\n        metadata={\n            \"endpoints\": frozenset((\"add\", \"edit\")),\n        },\n    )\n    \"\"\"Whether only admins will be able to see billable rates, premium feature,\n    optional, only for existing WS. Will be false initially\"\"\"\n\n    only_admins_see_team_dashboard: bool = field(\n        default=False,\n        metadata={\n            \"endpoints\": frozenset((\"add\", \"edit\")),\n        },\n    )\n    \"\"\"Only admins will be able to see the team dashboard, optional,\n    only for existing WS, will be false initially\"\"\"\n\n    projects_billable_by_default: bool = field(\n        default=False,\n        metadata={\n            \"endpoints\": frozenset((\"add\", \"edit\")),\n        },\n    )\n    \"\"\"Whether projects will be set as billable by default, premium feature,\n    optional, only for existing WS. Will be true initially\"\"\"\n\n    projects_enforce_billable: bool = field(\n        default=False,\n        metadata={\n            \"endpoints\": frozenset((\"add\", \"edit\")),\n        },\n    )\n    \"\"\"Whether tracking time to projects will enforce billable setting to be respected.\"\"\"\n\n    projects_private_by_default: bool = field(\n        default=False,\n        metadata={\n            \"endpoints\": frozenset((\"add\", \"edit\")),\n        },\n    )\n    \"\"\"Whether projects will be set to private by default, optional.\n    Will be true initially.\"\"\"\n\n    rate_change_mode: Literal[\"start-today\", \"override-current\", \"override-all\"] | None = field(\n        default=None,\n        metadata={\n            \"endpoints\": frozenset((\"add\", \"edit\")),\n        },\n    )\n    \"\"\"The rate change mode, premium feature, optional, only for existing WS.\n    Can be 'start-today', 'override-current', 'override-all'\"\"\"\n\n    reports_collapse: bool = field(\n        default=False,\n        metadata={\n            \"endpoints\": frozenset((\"add\", \"edit\")),\n        },\n    )\n    \"\"\"Whether reports should be collapsed by default, optional,\n    only for existing WS, will be true initially\"\"\"\n\n    rounding: int | None = field(\n        default=None,\n        metadata={\n            \"endpoints\": frozenset((\"add\", \"edit\")),\n        },\n    )\n    \"\"\"Default rounding, premium feature, optional, only for existing WS\"\"\"\n\n    rounding_minutes: int | None = field(\n        default=None,\n        metadata={\n            \"endpoints\": frozenset((\"add\", \"edit\")),\n        },\n    )\n    \"\"\"Default rounding in minutes, premium feature, optional, only for existing WS\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        if self.name:\n            try:\n                TogglWorkspace.validate_name(self.name)\n            except NamingError as err:\n                if str(err) != \"No spaces allowed in the workspace name!\":\n                    raise\n                log.warning(err)\n                self.name = self.name.replace(\" \", \"-\")\n                log.warning(\"Updated to new name: %s!\", self.name)\n\n    def format(self, endpoint: str, **body: Any) -&gt; dict[str, Any]:\n        \"\"\"Format the body into a usable format for a request.\n\n        Gets called form within an endpoint method.\n\n        Args:\n            endpoint: Which endpoint to target.\n            body: Prefilled body with extra arguments.\n\n        Returns:\n            A JSON body with the relevant parameters prefilled.\n        \"\"\"\n        for fld in fields(self):\n            if not self._verify_endpoint_parameter(fld.name, endpoint):\n                continue\n\n            value = getattr(self, fld.name)\n            if not value:\n                continue\n\n            body[fld.name] = value\n\n        return body\n</code></pre>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = field(default=None)\n</code></pre> <p>Name of the workspace. Check TogglWorkspace static method for validation.</p>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody.admins","title":"admins  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>admins: list[int] = field(\n    default_factory=list, metadata={\"endpoints\": frozenset((\"add\", \"edit\"))}\n)\n</code></pre> <p>List of admins, optional.</p>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody.only_admins_may_create_projects","title":"only_admins_may_create_projects  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>only_admins_may_create_projects: bool = field(\n    default=False, metadata={\"endpoints\": frozenset((\"add\", \"edit\"))}\n)\n</code></pre> <p>Only admins will be able to create projects, optional, only for existing WS, will be false initially</p>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody.only_admins_may_create_tags","title":"only_admins_may_create_tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>only_admins_may_create_tags: bool = field(\n    default=False, metadata={\"endpoints\": frozenset((\"add\", \"edit\"))}\n)\n</code></pre> <p>Only admins will be able to create tags, optional, only for existing WS, will be false initially</p>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody.only_admins_see_billable_rates","title":"only_admins_see_billable_rates  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>only_admins_see_billable_rates: bool = field(\n    default=False, metadata={\"endpoints\": frozenset((\"add\", \"edit\"))}\n)\n</code></pre> <p>Whether only admins will be able to see billable rates, premium feature, optional, only for existing WS. Will be false initially</p>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody.only_admins_see_team_dashboard","title":"only_admins_see_team_dashboard  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>only_admins_see_team_dashboard: bool = field(\n    default=False, metadata={\"endpoints\": frozenset((\"add\", \"edit\"))}\n)\n</code></pre> <p>Only admins will be able to see the team dashboard, optional, only for existing WS, will be false initially</p>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody.projects_billable_by_default","title":"projects_billable_by_default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>projects_billable_by_default: bool = field(\n    default=False, metadata={\"endpoints\": frozenset((\"add\", \"edit\"))}\n)\n</code></pre> <p>Whether projects will be set as billable by default, premium feature, optional, only for existing WS. Will be true initially</p>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody.projects_enforce_billable","title":"projects_enforce_billable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>projects_enforce_billable: bool = field(\n    default=False, metadata={\"endpoints\": frozenset((\"add\", \"edit\"))}\n)\n</code></pre> <p>Whether tracking time to projects will enforce billable setting to be respected.</p>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody.projects_private_by_default","title":"projects_private_by_default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>projects_private_by_default: bool = field(\n    default=False, metadata={\"endpoints\": frozenset((\"add\", \"edit\"))}\n)\n</code></pre> <p>Whether projects will be set to private by default, optional. Will be true initially.</p>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody.rate_change_mode","title":"rate_change_mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rate_change_mode: (\n    Literal[\"start-today\", \"override-current\", \"override-all\"] | None\n) = field(default=None, metadata={\"endpoints\": frozenset((\"add\", \"edit\"))})\n</code></pre> <p>The rate change mode, premium feature, optional, only for existing WS. Can be 'start-today', 'override-current', 'override-all'</p>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody.reports_collapse","title":"reports_collapse  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reports_collapse: bool = field(\n    default=False, metadata={\"endpoints\": frozenset((\"add\", \"edit\"))}\n)\n</code></pre> <p>Whether reports should be collapsed by default, optional, only for existing WS, will be true initially</p>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody.rounding","title":"rounding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rounding: int | None = field(\n    default=None, metadata={\"endpoints\": frozenset((\"add\", \"edit\"))}\n)\n</code></pre> <p>Default rounding, premium feature, optional, only for existing WS</p>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody.rounding_minutes","title":"rounding_minutes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rounding_minutes: int | None = field(\n    default=None, metadata={\"endpoints\": frozenset((\"add\", \"edit\"))}\n)\n</code></pre> <p>Default rounding in minutes, premium feature, optional, only for existing WS</p>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceBody.format","title":"format","text":"<pre><code>format(endpoint: str, **body: Any) -&gt; dict[str, Any]\n</code></pre> <p>Format the body into a usable format for a request.</p> <p>Gets called form within an endpoint method.</p> PARAMETER DESCRIPTION <code>endpoint</code> <p>Which endpoint to target.</p> <p> TYPE: <code>str</code> </p> <code>body</code> <p>Prefilled body with extra arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>A JSON body with the relevant parameters prefilled.</p> Source code in <code>src/toggl_api/_workspace.py</code> <pre><code>def format(self, endpoint: str, **body: Any) -&gt; dict[str, Any]:\n    \"\"\"Format the body into a usable format for a request.\n\n    Gets called form within an endpoint method.\n\n    Args:\n        endpoint: Which endpoint to target.\n        body: Prefilled body with extra arguments.\n\n    Returns:\n        A JSON body with the relevant parameters prefilled.\n    \"\"\"\n    for fld in fields(self):\n        if not self._verify_endpoint_parameter(fld.name, endpoint):\n            continue\n\n        value = getattr(self, fld.name)\n        if not value:\n            continue\n\n        body[fld.name] = value\n\n    return body\n</code></pre>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceEndpoint","title":"toggl_api.WorkspaceEndpoint","text":"<p>               Bases: <code>TogglCachedEndpoint[TogglWorkspace]</code></p> <p>Specific endpoints for retrieving and modifying workspaces.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; org_id = 123213324\n&gt;&gt;&gt; workspace_endpoint = WorkspaceEndpoint(org_id, BasicAuth(...), SqliteCache(...))\n</code></pre> PARAMETER DESCRIPTION <code>organization_id</code> <p>Workspace endpoint takes an organization id instead of a workspace id.</p> <p> TYPE: <code>int | TogglOrganization</code> </p> <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>cache</code> <p>Cache object for caching toggl workspace data to disk. Builtin cache types are JSONCache and SqliteCache.</p> <p> TYPE: <code>TogglCache[TogglWorkspace] | None</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>Optional client to be passed to be used for requests. Useful when a global client is used and needs to be recycled.</p> <p> TYPE: <code>Client | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>Timeout | int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>get</code> <p>Get the current workspace based on an id or model.</p> <code>add</code> <p>Create a new workspace.</p> <code>collect</code> <p>List workspaces for given user.</p> <code>edit</code> <p>Update a specific workspace.</p> <code>tracker_constraints</code> <p>Get the time entry constraints for a given workspace.</p> <code>statistics</code> <p>Return workspace admins list, members count and groups count.</p> Source code in <code>src/toggl_api/_workspace.py</code> <pre><code>class WorkspaceEndpoint(TogglCachedEndpoint[TogglWorkspace]):\n    \"\"\"Specific endpoints for retrieving and modifying workspaces.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/workspaces)\n\n    Examples:\n        &gt;&gt;&gt; org_id = 123213324\n        &gt;&gt;&gt; workspace_endpoint = WorkspaceEndpoint(org_id, BasicAuth(...), SqliteCache(...))\n\n    Params:\n        organization_id: Workspace endpoint takes an organization id instead of\n            a workspace id.\n        auth: Authentication for the client.\n        cache: Cache object for caching toggl workspace data to disk. Builtin cache\n            types are JSONCache and SqliteCache.\n        client: Optional client to be passed to be used for requests. Useful\n            when a global client is used and needs to be recycled.\n        timeout: How long it takes for the client to timeout. Keyword Only.\n            Defaults to 10 seconds.\n        re_raise: Whether to raise all HTTPStatusError errors and not handle them\n            internally. Keyword Only.\n        retries: Max retries to attempt if the server returns a *5xx* status_code.\n            Has no effect if re_raise is `True`. Keyword Only.\n    \"\"\"\n\n    MODEL = TogglWorkspace\n\n    def __init__(\n        self,\n        organization_id: int | TogglOrganization,\n        auth: BasicAuth,\n        cache: TogglCache[TogglWorkspace] | None = None,\n        *,\n        client: Client | None = None,\n        timeout: Timeout | int = 10,\n        re_raise: bool = False,\n        retries: int = 3,\n    ) -&gt; None:\n        super().__init__(\n            auth,\n            cache,\n            client=client,\n            timeout=timeout,\n            re_raise=re_raise,\n            retries=retries,\n        )\n        self.organization_id = organization_id if isinstance(organization_id, int) else organization_id.id\n\n    def get(\n        self,\n        workspace: TogglWorkspace | int,\n        *,\n        refresh: bool = False,\n    ) -&gt; TogglWorkspace | None:\n        \"\"\"Get the current workspace based on an id or model.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/workspaces#get-get-single-workspace)\n\n        Args:\n            workspace: Workspace id or model.\n            refresh: Whether to use cache or not.\n\n        Raises:\n            HTTPStatusError: If anything that's not a '2xx' or '404' status_code is returned.\n\n        Returns:\n            Model of workspace if found else none.\n        \"\"\"\n        if isinstance(workspace, TogglWorkspace):\n            workspace = workspace.id\n\n        if self.cache and not refresh:\n            return self.cache.find({\"id\": workspace})\n\n        try:\n            response = self.request(f\"workspaces/{workspace}\", refresh=refresh)\n        except HTTPStatusError as err:\n            log.exception(\"%s\")\n            if not self.re_raise and err.response.status_code == codes.NOT_FOUND:\n                return None\n            raise\n\n        return cast(\"TogglWorkspace\", response)\n\n    def add(self, body: WorkspaceBody) -&gt; TogglWorkspace:\n        \"\"\"Create a new workspace.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/workspaces#post-create-a-new-workspace)\n\n        Enterprise plan feature.\n\n        Args:\n            body: All settings for the workspace to be attached to as a body.\n\n        Returns:\n            A newly created workspace with the supplied params.\n        \"\"\"\n        return cast(\n            \"TogglWorkspace\",\n            self.request(\n                f\"organizations/{self.organization_id}/workspaces\",\n                body=body.format(\"add\", organization_id=self.organization_id),\n                method=RequestMethod.POST,\n                refresh=True,\n            ),\n        )\n\n    def _collect_cache(self, since: int | None) -&gt; list[TogglWorkspace]:\n        if isinstance(since, int):\n            ts = datetime.fromtimestamp(since, timezone.utc)\n            return list(self.query(TogglQuery(\"timestamp\", ts, Comparison.GREATER_THEN)))\n        return list(self.load_cache())\n\n    def _validate_collect_since(self, since: datetime | int) -&gt; int:\n        since = get_timestamp(since)\n        now = int(time.mktime(datetime.now(tz=timezone.utc).timetuple()))\n        if since &gt; now:\n            msg = \"The 'since' argument needs to be before the current time!\"\n            raise DateTimeError(msg)\n        return since\n\n    def collect(\n        self,\n        since: datetime | int | None = None,\n        *,\n        refresh: bool = False,\n    ) -&gt; list[TogglWorkspace]:\n        \"\"\"List workspaces for given user.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/me#get-workspaces)\n\n        Args:\n            since: Optional argument to filter any workspace after the timestamp.\n            refresh: Whether to use cache or not.\n\n        Raises:\n            DateTimeError: If the since argument is after the current time.\n\n        Returns:\n            A list of workspaces or empty if there are None assocciated with the user.\n        \"\"\"\n        if since is not None:\n            since = self._validate_collect_since(since)\n\n        if self.cache and not refresh:\n            return self._collect_cache(since)\n\n        body = {\"since\": since} if since else None\n\n        return cast(\n            \"list[TogglWorkspace]\",\n            self.request(\"me/workspaces\", body=body, refresh=refresh),\n        )\n\n    def edit(self, workspace_id: TogglWorkspace | int, body: WorkspaceBody) -&gt; TogglWorkspace:\n        \"\"\"Update a specific workspace.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/workspaces#put-update-workspace)\n\n        Raises:\n            HTTPStatusError: For anything thats not an *ok* status code.\n\n        Returns:\n            A workspace model with the supplied edits.\n        \"\"\"\n        if isinstance(workspace_id, TogglWorkspace):\n            workspace_id = workspace_id.id\n\n        return cast(\n            \"TogglWorkspace\",\n            self.request(\n                f\"workspaces/{workspace_id}\",\n                body=body.format(\"edit\"),\n                method=RequestMethod.PUT,\n                refresh=True,\n            ),\n        )\n\n    def tracker_constraints(self, workspace_id: TogglWorkspace | int) -&gt; dict[str, bool]:\n        \"\"\"Get the time entry constraints for a given workspace.\n\n        [Official Documentation](https://engineering.toggl.com/docs/api/workspaces#get-get-workspace-time-entry-constraints)\n\n        Toggl premium feature.\n\n        Examples:\n            &gt;&gt;&gt; workspace_endpoint.get_workspace_constraints(24214214)\n            {\n                \"description_present\": True,\n                \"project_present\": False,\n                \"tag_present\": False\",\n                \"task_present\": False,\n                \"time_entry_constraints_enabled\": True,\n            }\n\n        Args:\n            workspace_id: Id of the workspace to retrieve constraints from.\n\n        Returns:\n            A dictionary of booleans containing the settings.\n        \"\"\"\n        if isinstance(workspace_id, TogglWorkspace):\n            workspace_id = workspace_id.id\n\n        return cast(\n            \"dict[str, bool]\",\n            cast(\n                \"Response\",\n                self.request(\n                    f\"workspaces/{workspace_id}/time_entry_constraints\",\n                    raw=True,\n                    refresh=True,\n                ),\n            ).json(),\n        )\n\n    def statistics(self, workspace_id: TogglWorkspace | int) -&gt; WorkspaceStatistics:\n        \"\"\"Return workspace admins list, members count and groups count.\n\n        [Official Documentation](https://api.track.toggl.com/api/v9/workspaces/{workspace_id}/statistics)\n\n        Args:\n            workspace_id: Id of the workspace to fetch the statistics from.\n\n        Returns:\n            A dictionary containing relevant statistics.\n                Refer to WorkspaceStatistics typed dict for reference.\n        \"\"\"\n        if isinstance(workspace_id, TogglWorkspace):\n            workspace_id = workspace_id.id\n\n        return cast(\n            \"WorkspaceStatistics\",\n            cast(\n                \"Response\",\n                self.request(\n                    f\"workspaces/{workspace_id}/statistics\",\n                    refresh=True,\n                    raw=True,\n                ),\n            ).json(),\n        )\n</code></pre>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceEndpoint.get","title":"get","text":"<pre><code>get(\n    workspace: TogglWorkspace | int, *, refresh: bool = False\n) -&gt; TogglWorkspace | None\n</code></pre> <p>Get the current workspace based on an id or model.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>workspace</code> <p>Workspace id or model.</p> <p> TYPE: <code>TogglWorkspace | int</code> </p> <code>refresh</code> <p>Whether to use cache or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If anything that's not a '2xx' or '404' status_code is returned.</p> RETURNS DESCRIPTION <code>TogglWorkspace | None</code> <p>Model of workspace if found else none.</p> Source code in <code>src/toggl_api/_workspace.py</code> <pre><code>def get(\n    self,\n    workspace: TogglWorkspace | int,\n    *,\n    refresh: bool = False,\n) -&gt; TogglWorkspace | None:\n    \"\"\"Get the current workspace based on an id or model.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/workspaces#get-get-single-workspace)\n\n    Args:\n        workspace: Workspace id or model.\n        refresh: Whether to use cache or not.\n\n    Raises:\n        HTTPStatusError: If anything that's not a '2xx' or '404' status_code is returned.\n\n    Returns:\n        Model of workspace if found else none.\n    \"\"\"\n    if isinstance(workspace, TogglWorkspace):\n        workspace = workspace.id\n\n    if self.cache and not refresh:\n        return self.cache.find({\"id\": workspace})\n\n    try:\n        response = self.request(f\"workspaces/{workspace}\", refresh=refresh)\n    except HTTPStatusError as err:\n        log.exception(\"%s\")\n        if not self.re_raise and err.response.status_code == codes.NOT_FOUND:\n            return None\n        raise\n\n    return cast(\"TogglWorkspace\", response)\n</code></pre>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceEndpoint.add","title":"add","text":"<pre><code>add(body: WorkspaceBody) -&gt; TogglWorkspace\n</code></pre> <p>Create a new workspace.</p> <p>Official Documentation</p> <p>Enterprise plan feature.</p> PARAMETER DESCRIPTION <code>body</code> <p>All settings for the workspace to be attached to as a body.</p> <p> TYPE: <code>WorkspaceBody</code> </p> RETURNS DESCRIPTION <code>TogglWorkspace</code> <p>A newly created workspace with the supplied params.</p> Source code in <code>src/toggl_api/_workspace.py</code> <pre><code>def add(self, body: WorkspaceBody) -&gt; TogglWorkspace:\n    \"\"\"Create a new workspace.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/workspaces#post-create-a-new-workspace)\n\n    Enterprise plan feature.\n\n    Args:\n        body: All settings for the workspace to be attached to as a body.\n\n    Returns:\n        A newly created workspace with the supplied params.\n    \"\"\"\n    return cast(\n        \"TogglWorkspace\",\n        self.request(\n            f\"organizations/{self.organization_id}/workspaces\",\n            body=body.format(\"add\", organization_id=self.organization_id),\n            method=RequestMethod.POST,\n            refresh=True,\n        ),\n    )\n</code></pre>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceEndpoint.collect","title":"collect","text":"<pre><code>collect(\n    since: datetime | int | None = None, *, refresh: bool = False\n) -&gt; list[TogglWorkspace]\n</code></pre> <p>List workspaces for given user.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>since</code> <p>Optional argument to filter any workspace after the timestamp.</p> <p> TYPE: <code>datetime | int | None</code> DEFAULT: <code>None</code> </p> <code>refresh</code> <p>Whether to use cache or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>DateTimeError</code> <p>If the since argument is after the current time.</p> RETURNS DESCRIPTION <code>list[TogglWorkspace]</code> <p>A list of workspaces or empty if there are None assocciated with the user.</p> Source code in <code>src/toggl_api/_workspace.py</code> <pre><code>def collect(\n    self,\n    since: datetime | int | None = None,\n    *,\n    refresh: bool = False,\n) -&gt; list[TogglWorkspace]:\n    \"\"\"List workspaces for given user.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/me#get-workspaces)\n\n    Args:\n        since: Optional argument to filter any workspace after the timestamp.\n        refresh: Whether to use cache or not.\n\n    Raises:\n        DateTimeError: If the since argument is after the current time.\n\n    Returns:\n        A list of workspaces or empty if there are None assocciated with the user.\n    \"\"\"\n    if since is not None:\n        since = self._validate_collect_since(since)\n\n    if self.cache and not refresh:\n        return self._collect_cache(since)\n\n    body = {\"since\": since} if since else None\n\n    return cast(\n        \"list[TogglWorkspace]\",\n        self.request(\"me/workspaces\", body=body, refresh=refresh),\n    )\n</code></pre>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceEndpoint.edit","title":"edit","text":"<pre><code>edit(\n    workspace_id: TogglWorkspace | int, body: WorkspaceBody\n) -&gt; TogglWorkspace\n</code></pre> <p>Update a specific workspace.</p> <p>Official Documentation</p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything thats not an ok status code.</p> RETURNS DESCRIPTION <code>TogglWorkspace</code> <p>A workspace model with the supplied edits.</p> Source code in <code>src/toggl_api/_workspace.py</code> <pre><code>def edit(self, workspace_id: TogglWorkspace | int, body: WorkspaceBody) -&gt; TogglWorkspace:\n    \"\"\"Update a specific workspace.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/workspaces#put-update-workspace)\n\n    Raises:\n        HTTPStatusError: For anything thats not an *ok* status code.\n\n    Returns:\n        A workspace model with the supplied edits.\n    \"\"\"\n    if isinstance(workspace_id, TogglWorkspace):\n        workspace_id = workspace_id.id\n\n    return cast(\n        \"TogglWorkspace\",\n        self.request(\n            f\"workspaces/{workspace_id}\",\n            body=body.format(\"edit\"),\n            method=RequestMethod.PUT,\n            refresh=True,\n        ),\n    )\n</code></pre>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceEndpoint.tracker_constraints","title":"tracker_constraints","text":"<pre><code>tracker_constraints(workspace_id: TogglWorkspace | int) -&gt; dict[str, bool]\n</code></pre> <p>Get the time entry constraints for a given workspace.</p> <p>Official Documentation</p> <p>Toggl premium feature.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; workspace_endpoint.get_workspace_constraints(24214214)\n{\n    \"description_present\": True,\n    \"project_present\": False,\n    \"tag_present\": False\",\n    \"task_present\": False,\n    \"time_entry_constraints_enabled\": True,\n}\n</code></pre> PARAMETER DESCRIPTION <code>workspace_id</code> <p>Id of the workspace to retrieve constraints from.</p> <p> TYPE: <code>TogglWorkspace | int</code> </p> RETURNS DESCRIPTION <code>dict[str, bool]</code> <p>A dictionary of booleans containing the settings.</p> Source code in <code>src/toggl_api/_workspace.py</code> <pre><code>def tracker_constraints(self, workspace_id: TogglWorkspace | int) -&gt; dict[str, bool]:\n    \"\"\"Get the time entry constraints for a given workspace.\n\n    [Official Documentation](https://engineering.toggl.com/docs/api/workspaces#get-get-workspace-time-entry-constraints)\n\n    Toggl premium feature.\n\n    Examples:\n        &gt;&gt;&gt; workspace_endpoint.get_workspace_constraints(24214214)\n        {\n            \"description_present\": True,\n            \"project_present\": False,\n            \"tag_present\": False\",\n            \"task_present\": False,\n            \"time_entry_constraints_enabled\": True,\n        }\n\n    Args:\n        workspace_id: Id of the workspace to retrieve constraints from.\n\n    Returns:\n        A dictionary of booleans containing the settings.\n    \"\"\"\n    if isinstance(workspace_id, TogglWorkspace):\n        workspace_id = workspace_id.id\n\n    return cast(\n        \"dict[str, bool]\",\n        cast(\n            \"Response\",\n            self.request(\n                f\"workspaces/{workspace_id}/time_entry_constraints\",\n                raw=True,\n                refresh=True,\n            ),\n        ).json(),\n    )\n</code></pre>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceEndpoint.statistics","title":"statistics","text":"<pre><code>statistics(workspace_id: TogglWorkspace | int) -&gt; WorkspaceStatistics\n</code></pre> <p>Return workspace admins list, members count and groups count.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>workspace_id</code> <p>Id of the workspace to fetch the statistics from.</p> <p> TYPE: <code>TogglWorkspace | int</code> </p> RETURNS DESCRIPTION <code>WorkspaceStatistics</code> <p>A dictionary containing relevant statistics. Refer to WorkspaceStatistics typed dict for reference.</p> Source code in <code>src/toggl_api/_workspace.py</code> <pre><code>def statistics(self, workspace_id: TogglWorkspace | int) -&gt; WorkspaceStatistics:\n    \"\"\"Return workspace admins list, members count and groups count.\n\n    [Official Documentation](https://api.track.toggl.com/api/v9/workspaces/{workspace_id}/statistics)\n\n    Args:\n        workspace_id: Id of the workspace to fetch the statistics from.\n\n    Returns:\n        A dictionary containing relevant statistics.\n            Refer to WorkspaceStatistics typed dict for reference.\n    \"\"\"\n    if isinstance(workspace_id, TogglWorkspace):\n        workspace_id = workspace_id.id\n\n    return cast(\n        \"WorkspaceStatistics\",\n        cast(\n            \"Response\",\n            self.request(\n                f\"workspaces/{workspace_id}/statistics\",\n                refresh=True,\n                raw=True,\n            ),\n        ).json(),\n    )\n</code></pre>"},{"location":"api-guide/workspace.html#toggl_api.asyncio.AsyncWorkspaceEndpoint","title":"toggl_api.asyncio.AsyncWorkspaceEndpoint","text":"<p>               Bases: <code>TogglAsyncCachedEndpoint[TogglWorkspace]</code></p> <p>Specific endpoints for retrieving and modifying workspaces.</p> <p>Official Documentation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; org_id = 123213324\n&gt;&gt;&gt; workspace_endpoint = AsyncWorkspaceEndpoint(org_id, BasicAuth(...), AsyncSqliteCache(...))\n</code></pre> PARAMETER DESCRIPTION <code>organization_id</code> <p>Workspace endpoint takes an organization id instead of a workspace id.</p> <p> TYPE: <code>int | TogglOrganization</code> </p> <code>auth</code> <p>Authentication for the client.</p> <p> TYPE: <code>BasicAuth</code> </p> <code>client</code> <p>Optional async client to be passed to be used for requests.</p> <p> TYPE: <code>AsyncClient | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long it takes for the client to timeout. Keyword Only. Defaults to 10 seconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>re_raise</code> <p>Whether to raise all HTTPStatusError errors and not handle them internally. Keyword Only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>retries</code> <p>Max retries to attempt if the server returns a 5xx status_code. Has no effect if re_raise is <code>True</code>. Keyword Only.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>get</code> <p>Get the current workspace based on an id or model.</p> <code>add</code> <p>Create a new workspace.</p> <code>collect</code> <p>List workspaces for given user.</p> <code>edit</code> <p>Update a specific workspace.</p> <code>tracker_constraints</code> <p>Get the time entry constraints for a given workspace.</p> <code>statistics</code> <p>Return workspace admins list, members count and groups count.</p>"},{"location":"api-guide/workspace.html#toggl_api.asyncio.AsyncWorkspaceEndpoint.get","title":"get  <code>async</code>","text":"<pre><code>get(\n    workspace: TogglWorkspace | int, *, refresh: bool = False\n) -&gt; TogglWorkspace | None\n</code></pre> <p>Get the current workspace based on an id or model.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>workspace</code> <p>Workspace id or model.</p> <p> TYPE: <code>TogglWorkspace | int</code> </p> <code>refresh</code> <p>Whether to use cache or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If anything that's not a '2xx' or '404' status_code is returned.</p> RETURNS DESCRIPTION <code>TogglWorkspace | None</code> <p>Model of workspace if found else none.</p>"},{"location":"api-guide/workspace.html#toggl_api.asyncio.AsyncWorkspaceEndpoint.add","title":"add  <code>async</code>","text":"<pre><code>add(body: WorkspaceBody) -&gt; TogglWorkspace\n</code></pre> <p>Create a new workspace.</p> <p>Official Documentation</p> <p>Enterprise plan feature.</p> PARAMETER DESCRIPTION <code>body</code> <p>All settings for the workspace to be attached to as a body.</p> <p> TYPE: <code>WorkspaceBody</code> </p> RETURNS DESCRIPTION <code>TogglWorkspace</code> <p>A newly created workspace with the supplied params.</p>"},{"location":"api-guide/workspace.html#toggl_api.asyncio.AsyncWorkspaceEndpoint.collect","title":"collect  <code>async</code>","text":"<pre><code>collect(\n    since: datetime | int | None = None, *, refresh: bool = False\n) -&gt; list[TogglWorkspace]\n</code></pre> <p>List workspaces for given user.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>since</code> <p>Optional argument to filter any workspace after the timestamp.</p> <p> TYPE: <code>datetime | int | None</code> DEFAULT: <code>None</code> </p> <code>refresh</code> <p>Whether to use cache or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>DateTimeError</code> <p>If the since argument is after the current time.</p> RETURNS DESCRIPTION <code>list[TogglWorkspace]</code> <p>A list of workspaces or empty if there are None assocciated with the user.</p>"},{"location":"api-guide/workspace.html#toggl_api.asyncio.AsyncWorkspaceEndpoint.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(\n    workspace_id: TogglWorkspace | int, body: WorkspaceBody\n) -&gt; TogglWorkspace\n</code></pre> <p>Update a specific workspace.</p> <p>Official Documentation</p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>For anything thats not an ok status code.</p> RETURNS DESCRIPTION <code>TogglWorkspace</code> <p>A workspace model with the supplied edits.</p>"},{"location":"api-guide/workspace.html#toggl_api.asyncio.AsyncWorkspaceEndpoint.tracker_constraints","title":"tracker_constraints  <code>async</code>","text":"<pre><code>tracker_constraints(workspace_id: TogglWorkspace | int) -&gt; dict[str, bool]\n</code></pre> <p>Get the time entry constraints for a given workspace.</p> <p>Official Documentation</p> <p>Toggl premium feature.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await workspace_endpoint.get_workspace_constraints(24214214)\n{\n    \"description_present\": True,\n    \"project_present\": False,\n    \"tag_present\": False\",\n    \"task_present\": False,\n    \"time_entry_constraints_enabled\": True,\n}\n</code></pre> PARAMETER DESCRIPTION <code>workspace_id</code> <p>Id of the workspace to retrieve constraints from.</p> <p> TYPE: <code>TogglWorkspace | int</code> </p> RETURNS DESCRIPTION <code>dict[str, bool]</code> <p>A dictionary of booleans containing the settings.</p>"},{"location":"api-guide/workspace.html#toggl_api.asyncio.AsyncWorkspaceEndpoint.statistics","title":"statistics  <code>async</code>","text":"<pre><code>statistics(workspace_id: TogglWorkspace | int) -&gt; WorkspaceStatistics\n</code></pre> <p>Return workspace admins list, members count and groups count.</p> <p>Official Documentation</p> PARAMETER DESCRIPTION <code>workspace_id</code> <p>Id of the workspace to fetch the statistics from.</p> <p> TYPE: <code>TogglWorkspace | int</code> </p> RETURNS DESCRIPTION <code>WorkspaceStatistics</code> <p>Dictionary containing relevant statistics. Refer to <code>WorkspaceStatistics</code> typed dict for reference.</p>"},{"location":"api-guide/workspace.html#types","title":"Types","text":""},{"location":"api-guide/workspace.html#toggl_api.User","title":"toggl_api.User","text":"<p>               Bases: <code>TypedDict</code></p> Source code in <code>src/toggl_api/_workspace.py</code> <pre><code>class User(TypedDict):\n    user_id: int\n    name: str\n</code></pre>"},{"location":"api-guide/workspace.html#toggl_api.WorkspaceStatistics","title":"toggl_api.WorkspaceStatistics","text":"<p>               Bases: <code>TypedDict</code></p> Source code in <code>src/toggl_api/_workspace.py</code> <pre><code>class WorkspaceStatistics(TypedDict):\n    admins: list[User]\n    groups_count: int\n    members_count: int\n</code></pre>"},{"location":"user-guide/examples.html","title":"Examples","text":"<p>All Tracker, Client, Project &amp; Tag endpoints will have most of these methods:</p> <ol> <li>collect: Gathering models.</li> <li>get: Retrieving a model.</li> <li>delete: Deleting a model.</li> <li>edit: Editing a model.</li> <li>add: Creating a new model.</li> </ol> <p>Info</p> <p>With environment variables setup correctly.</p>"},{"location":"user-guide/examples.html#tracker-example","title":"Tracker Example","text":"<pre><code>from datetime import timedelta\nfrom pathlib import Path\n\nfrom toggl_api import TogglTracker, TrackerBody, TrackerEndpoint\nfrom toggl_api.config import generate_authentication\nfrom toggl_api.meta.cache.sqlite_cache import SqliteCache\n\nWORKSPACE_ID = 2313123123\nAUTH = generate_authentication()\ncache = SqliteCache[TogglTracker](Path(\"cache\"), timedelta(hours=24))\nendpoint = TrackerEndpoint(WORKSPACE_ID, AUTH, cache)\n\nbody = TrackerBody(\"My First Tracker\", tags=[\"My First Tag\"])\ntracker = endpoint.add(body)\nprint(tracker)\n</code></pre> <p>Outputs:</p> <pre><code>&gt;&gt;&gt; TogglTracker(\n        id=3482231563,\n        name=\"My First Tracker\",\n        workspace=2313123123,\n        start=datetime.datetime(2024, 6, 10, 14, 59, 20, tzinfo=datetime.timezone.utc),\n        duration=datetime.timedelta(seconds=1, microseconds=179158),\n        stop=None,\n        project=None,\n        tags=[],\n    )\n</code></pre>"},{"location":"user-guide/examples.html#project-example","title":"Project Example","text":"<p>Info</p> <p>Using an existing togglrc file.</p> <pre><code>from datetime import timedelta\nfrom pathlib import Path\n\nfrom toggl_api import ProjectBody, ProjectEndpoint, TogglProject\nfrom toggl_api.config import retrieve_togglrc_workspace_id, use_togglrc\nfrom toggl_api.meta.cache import JSONCache\n\nWORKSPACE_ID = retrieve_togglrc_workspace_id()\nAUTH = use_togglrc()\ncache = JSONCache[TogglProject](Path(\"cache\"), timedelta(hours=24))\nendpoint = ProjectEndpoint(WORKSPACE_ID, AUTH, cache)\n\ncolor = ProjectEndpoint.get_color(\"red\")\nbody = ProjectBody(\n    \"My First Project\",\n    client_name=\"My First Client\",\n    color=color,\n)\nproject = endpoint.add(body)\nprint(project)\n</code></pre> <p>Outputs:</p> <pre><code>&gt;&gt;&gt; TogglProject(\n        id=203366783,\n        name='My First Project',\n        workspace=2313123123,\n        color='#d92b2b',\n        client=65298912,\n        active=True,\n    )\n</code></pre>"},{"location":"user-guide/examples.html#report-example","title":"Report Example","text":"<ul> <li>With Plotly, Pandas and Kaleidoscope installed.</li> </ul> <pre><code>import os\nimport time\nfrom collections import defaultdict\nfrom datetime import date, datetime\n\nimport pandas as pd\nimport plotly.express as px\n\nfrom toggl_api.config import generate_authentication\nfrom toggl_api.reports import DetailedReportEndpoint, ReportBody\n\n# Setup Endpoint\nWORKSPACE_ID = int(os.environ.get(\"TOGGL_WORKSPACE_ID\", \"0\"))\nAUTH = generate_authentication()\ndetailed_report_endpoint = DetailedReportEndpoint(WORKSPACE_ID, AUTH)\n\nstart_date = date(2024, 1, 1)\nend_date = date(2024, 11, 9)\nbody = ReportBody(\n    start_date=start_date,\n    end_date=end_date,\n    project_ids=[202484947],\n)\n\n# Retrieve Data\nprint(\"Initial Request\")\nfirst = detailed_report_endpoint.search_time_entries(body)\nnext_page = first.next_options()\ncontent = first.result\nwhile next_page.next_id is not None and next_page.next_row is not None:\n    time.sleep(1)\n    print(f\"Requesting id {next_page.next_id} and row {next_page.next_row}\")\n    search = detailed_report_endpoint.search_time_entries(body, next_page)\n    content.extend(search.result)\n    next_page = search.next_options()\n\n\n# Process Target Data\naggregrate: defaultdict[str, int] = defaultdict(lambda: 0)\nfor tracker in content:\n    time_data = tracker[\"time_entries\"][0]\n    start = datetime.strptime(time_data[\"at\"], \"%Y-%m-%dT%H:%M:%S%z\")\n    aggregrate[start.strftime(\"%B\")] += time_data[\"seconds\"] // 60\n\n# Plot &amp; View Data\nmonthly_minutes = pd.DataFrame(\n    aggregrate.items(),\n    index=aggregrate.keys(),\n    columns=[\"month\", \"minutes\"],\n)\nfig = px.bar(\n    monthly_minutes,\n    \"month\",\n    \"minutes\",\n    title=\"Total recorded monthly minutes spent on Toggl API Wrapper in 2024\",\n)\nfig.show()\nfig.write_image(\"total-minutes-may-to-october-2024.svg\")\n</code></pre> <p>Outputs:</p> <p></p>"},{"location":"user-guide/examples.html#asyncio-example","title":"Asyncio Example","text":"<ul> <li>With all dependencies from <code>toggl-api-wrapper[async]</code></li> </ul> <pre><code>import asyncio\nfrom datetime import datetime, timezone\n\nfrom toggl_api import ProjectBody\nfrom toggl_api.asyncio import AsyncProjectEndpoint\nfrom toggl_api.config import generate_authentication, retrieve_workspace_id\n\nbody = ProjectBody(\"New Project\", start_date=datetime.now(timezone.utc).date(), active=True)\n\nproj_ep = AsyncProjectEndpoint(retrieve_workspace_id(), generate_authentication())\nproject = asyncio.run(proj_ep.add(body), debug=True)\nprint(project)\n</code></pre> <p>Outputs:</p> <pre><code>&gt;&gt;&gt; TogglProject(\n        id=208596838,\n        name='New Project',\n        workspace=8876353,\n        color='#0b83d9',\n        client=None,\n        active=True,\n        start_date=datetime.date(2025, 1, 22),\n        end_date=None\n    )\n</code></pre>"},{"location":"user-guide/examples.html#logging-example","title":"Logging Example","text":"<pre><code>import logging\nimport os\nfrom pathlib import Path\n\nfrom toggl_api import JSONCache, UserEndpoint, generate_authentication\n\nlogging.basicConfig(\n    format=\"%(levelname)s [%(asctime)s] %(name)s - %(message)s\",\n    datefmt=\"%Y-%m-%d %H:%M:%S\",\n    level=logging.INFO,\n)\n\nWORKSPACE_ID = int(os.environ.get(\"TOGGL_WORKSPACE_ID\", 0))\nAUTH = generate_authentication()\ncache = JSONCache(Path(\"cache\"))\nendpoint = UserEndpoint(WORKSPACE_ID, AUTH, cache)\n\nendpoint.check_authentication()\n</code></pre> <p>Outputs:</p> <pre><code>INFO [2024-10-15 12:08:21] toggl-api-wrapper - Detected an api token as authentication.\nINFO [2024-10-15 12:08:21] httpx - HTTP Request: GET https://api.track.toggl.com/api/v9/me/logged \"HTTP/1.1 200 OK\"\n</code></pre>"},{"location":"user-guide/examples.html#applications-using-toggl-api-wrapper","title":"Applications Using Toggl API Wrapper","text":"<ul> <li>Ulauncher Toggl Extension</li> </ul>"},{"location":"user-guide/installation.html","title":"Installation","text":""},{"location":"user-guide/installation.html#install-using-pip","title":"Install using pip:","text":"<pre><code>pip install toggl-api-wrapper\n</code></pre>"},{"location":"user-guide/installation.html#or-if-using-sqlite-cache","title":"Or if using SQLite cache:","text":"<pre><code>pip install \"toggl-api-wrapper[sqlite]\"\n</code></pre>"},{"location":"user-guide/installation.html#or-if-using-async-classes","title":"Or if using Async classes:","text":"<pre><code>pip install \"toggl-api-wrapper[async]\"\n</code></pre>"},{"location":"user-guide/installation.html#dependencies","title":"Dependencies","text":""},{"location":"user-guide/installation.html#main","title":"Main","text":"<ul> <li>HTTPX - For requests</li> </ul>"},{"location":"user-guide/installation.html#optional","title":"Optional","text":"<ul> <li>SQLAlchemy - For Sqlite cache</li> <li>Greenlet - For Async functionality</li> <li>AIOSQLite - For Async SQLite cache</li> </ul>"}]}